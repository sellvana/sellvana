{% set ctrl = APP.instance('Sellvana_ShopperFields_Admin') %}
{% set frontendFieldGrid = ctrl.frontendFieldGrid(model) %}
{% set frontendOptionsGrid = ctrl.frontendOptionsGrid(model) %}
{% set optionsConfigCompiled = THIS.view('core/griddle').set('grid', frontendOptionsGrid).getGridConfig() %}

{% set loadCustomerGroups = MODULES.isLoaded('Sellvana_CustomerGroups') %}
{% if loadCustomerGroups %}
    {% set customerGroups = APP.instance('Sellvana_CustomerGroups_Model_Group').groupsOptions() %}
{% endif %}

{% set loadSites = MODULES.isLoaded('Sellvana_MultiSite') %}
{% if loadSites %}
    {% set sites = APP.instance('Sellvana_MultiSite_Model_Site').siteOptions() %}
{% endif %}

{% set loadCurrency = MODULES.isLoaded('Sellvana_MultiCurrency') %}
{% if loadCurrency %}
    {% set currencies = APP.instance('Sellvana_MultiCurrency_Main').getAvailableCurrencies() %}
{% endif %}
{% set priceHelper = APP.instance('Sellvana_Catalog_Model_ProductPrice') %}

<script>
    /*require(['backbone', 'underscore', 'jquery'], function(Backbone, _, $) {
        var mainGrid;
        var inputName = 'input[data-col="name"]';
        var inputOption = 'input[data-col="options"]';
        var selectFieldType = 'select[data-col="input_type"]';
        window.frontendFieldGridRegister = function(grid) {
            mainGrid = grid;
            grid.getGridSkeleton().Views.RowView.prototype.afterRender = function() {
                var self = this;
                this.$el.find(inputName).addClass('unique');
                this.$el.find(inputOption).addClass('requiredOptions');
                if (this.model.get('input_type') != 'select') {
                    this.$el.find(inputOption).prop('disabled', true);
                }
                this.$el.find(selectFieldType).change(function() {
                    if ($(this).val() == 'select') {
                        self.$el.find(inputOption).prop('disabled', false);
                    } else {
                        self.$el.find(inputOption).prop('disabled', true);
                    }
                })
            }
            grid.build();
        }
        $('#catalog-products-form').submit(function (ev) {
            var rows = mainGrid.getRows().toJSON();

            var res = [];
            for (var i in rows) {
                if (rows[i].position.length == 0) {
                    rows[i].position = 0;
                }
                res.push(_.pick(rows[i], 'id', 'name', 'label', 'input_type', 'required', 'options', 'position'));
            }

            $("#prod_frontend_data").val(JSON.stringify(res));
        });
        function checkUnique(value, elem, params) {
            var error = true;
            if (typeof (elem) !== 'undefined') {
                var parent = $(elem).parents('tr');
                var val = parent.find(inputName).val();
                mainGrid.getRows().each(function (data) {
                    if (parent.attr('id') != data.get('id') && val == data.get('name')) {
                        error = false;
                    }
                });
            }

            return error;
        }

        $.validator.addMethod('checkUnique', checkUnique , 'Field Name are already taken place.');

        $.validator.addClassRules("requiredOptions", {
            required: function (value, elem, params) {
                var error = true;
                if (typeof (elem) !== 'undefined') {
                    var parent = $(elem).parents('tr');
                    if (parent.find(selectFieldType).val() == 'select' &&  value.trim().length == 0) {
                        error = false;
                    }
                }
                return error;
            }
        });

        $.validator.addClassRules("unique", {
            required: true,
            checkUnique: true
        });

    });*/
</script>
<script>
    var shopperGrid, shopperNode, shopperModalNode,optionsModalGrid, optionsModalNode, fieldModalGrid;

    require(['react', 'underscore', 'jquery', 'fcom.components'], function(React, _, $, Components) {

        var inputName       = 'input[data-col="name"]';
        var inputOption     = 'a[data-col="options"]';
        // var inputOption     = 'input[data-col="options"]';
        var selectFieldType = 'select[data-col="input_type"]';

        /**
         * Main grid register callback
         * @param  {Object} grid
         * @return mixed
         */
        window.fieldsGridRegister = function(grid) {
            shopperGrid = grid;
            shopperNode = $(shopperGrid.getDOMNode());
            updateValidation();
            shopperNode.on('removedRows.griddle', function (e, removedRows, grid) {
                console.log('removedRows callback');
            })
            .on('addedRows.griddle', function (e, removedRows, grid) {
                updateValidation();
            });
        }

        /**
         * Add blank row to grid
         */
        window.addBlankRows = function(grid) {
            shopperGrid.addRows([{id : guid()}]);
        }

        /*
         *function to set attachment grid data into form fields to send them server
         *This function is callend when 'save' button of product form is clicked.
         */
        window.submitCallback.push(function () {
            shopperNode.find('form').validate();
            var rows = shopperGrid.getRows();

            var res = [];
            _(rows).each(function(row, index) {
                var optionsSerialized = '';
                if (row.position == 0) {
                    row.position = 0;
                }

                var data = _.pick(row, 'id', 'name', 'label', 'group', 'input_type', 'required', 'options', 'position');
                data['id'] = ++index;
                if (row.input_type === 'select') { // Only save prices when field is select
                    var $priceEle = $('input[data-shopper-id="'+row.id+'"]');
                    if ($priceEle.length) { // If price modal is saved changed
                        optionsSerialized = $priceEle.val();
                    } else {
                        if (typeof row.options_serialized === 'string' && row.options_serialized.length) { // 
                            optionsSerialized = row.options_serialized;
                        } else { // If added prices but not saved changed then remove
                            _(row.options_serialized).each(function(optionPrice, index) {
                                if (isNaN(optionPrice.prices[0].id)) {
                                    delete row.options_serialized[index];
                                }
                            });
                            optionsSerialized = JSON.stringify(row.options_serialized);
                        }
                    }
                    data['options_serialized'] = optionsSerialized;
                }
                res.push(data);
            });

            $("#prod_frontend_data").val(JSON.stringify(res));
        });

        /**
         * Update validation class for all rows
         * @return mixed
         */
        function updateValidation() {
            shopperNode.find(inputName).addClass('unique');
            shopperNode.find(inputOption).addClass('requiredOptions');
            var rows = shopperGrid.getRows();
            _.each(rows, function(row) {
                if (row.input_type != 'select') {
                    // shopperNode.find('tr#' + row.id).find(inputOption).prop('disabled', true);
                    shopperNode.find('tr#' + row.id).find(inputOption)[0].innerText = '';
                }
            });

            /**
             * Disable options upon field type is not dropdown
             */
            shopperNode.find(selectFieldType).on('change', function(e) {
                var pId = $(this).parents('tr').attr('id');
                var count = $(this).parents('tr#'+pId).find(inputOption).data('length');
                if ($(this).val() == 'select') {
                    var optionLabel = count <= 1 ? ' Option' : ' Options';
                    $(this).parents('tr#'+pId).find(inputOption)[0].innerText = count + optionLabel;
                } else {
                    $(this).parents('tr#'+pId).find(inputOption)[0].innerText = '';
                }
            });

            /**
             * Check grid field name is unique
             * @return boolean
             */
            function checkUnique(value, elem, params) {
                var error = true;
                if (typeof (elem) !== 'undefined') {
                    var parent = $(elem).parents('tr');
                    var val = parent.find(inputName).val();
                    _.each(shopperGrid.getRows(), function(data) {
                        if (parent.attr('id') != data.id && val == data.name) {
                            error = false;
                        }
                    });
                }
                return error;
            }

            $.validator.addMethod('checkUnique', checkUnique , 'Field Name are already taken place.');

            $.validator.addClassRules("requiredOptions", {
                required: function (value, elem, params) {
                    var error = true;
                    if (typeof (elem) !== 'undefined') {
                        var parent = $(elem).parents('tr');
                        if (parent.find(selectFieldType).val() == 'select' &&  value.trim().length == 0) {
                            error = false;
                        }
                    }
                    return error;
                }
            });

            $.validator.addClassRules("unique", {
                required: true,
                checkUnique: true
            });
        }
    });

    require(['react', 'underscore', 'jquery', 'fcom.griddle', 'griddle.fcomModalForm', 'fcom.components', 'fcom.catalog.product.price', 'fcom.locale', 'fcom.catalog.components'], function(React, _, $, FComGriddleComponent, FComModalForm, Components, Price, Locale) {

        // var deletedPrices  = [];
        var shopper     = {};
        var addedRows   = [];
        var editedRows  = [];
        var deletedRows = [];
        var shopperId   = '';
        // Global objec event to connect two components fcom.griddle and fcom.catalog.product.price grid
        var OPTS        = {};
        /**
         * Toggle tabs when edit trigger
         * @param  {string} label 
         * @return {mixed}
         */
        function toggleTab(label) {
            shopperModalNode.find('#btn'+capitalizeFirstLetter(toggleSpace(label))+'Tab').click();
            shopperModalNode.find('#btnShopperTab').click();
        }

        /**
         * Toggle action buttons if valid false
         * @param  {Boolean} valid 
         * @return {mixed}
         */
        function toggleActionButton(valid) {
            if (!valid) {
                shopperModalNode.find('tbody .btn-edit').prop('disabled', true);
                shopperModalNode.find('.modal-footer button.btn-primary').prop('disabled', true);
            } else {
                shopperModalNode.find('tbody .btn-edit').prop('disabled', false);
                shopperModalNode.find('.modal-footer button.btn-primary').prop('disabled', false);
            }
        }

        /**
         * Convert space chars to hyphen or on the contrary
         * @param  {string}  string
         * @param  {Boolean} isRevert
         * @return {string}
         */
        function toggleSpace(string, isRevert) {
            string = $.trim(string);
            if (isRevert) {
                return string.replace(/\-/g, ' ');
            } else {
                return string.replace(/\s/g, '-');
            }
        }

        /**
         * Parse options string to array
         * @param  {string} options 
         * @return {Array}
         */
        function parseOptions(options) {
            if (typeof options === 'string' && options.length) {
                return options.replace(/\,+$/, '').split(',').map(function(option) {
                    return option;
                });
            }
            return [];
        }

        /**
         * Capitalize first letter
         * @param  {string} string 
         * @return {string}
         */
        function capitalizeFirstLetter(string) {
            return string.toLowerCase().charAt(0).toUpperCase() + string.slice(1);
        }

        /**
         * Merge options of current row to global added options of specify row's options
         * @param  {string} curOptions
         * @param  {Object} addedOptions
         * @return {string}
         */
        function mergeOptions(curOptions, addedOptions) {
            _(addedOptions).map(function(addedOption) {
                if (curOptions.indexOf(addedOption) === -1) {
                    return curOptions += ',' + addedOption;
                }
            });

            return curOptions;
        }

        /**
         * Validate unique option attributes
         * @return boolean
         */
        var validateAttrs = function() {
            var valid = true;
            shopperModalNode.find('input[data-col="label"], input[data-col="position"]').each(function (el) {
                if (!$(this).valid()) {
                    valid = false;
                }
            });
            return valid;
        }

        /**
         * Options grid register
         * @param  {Objec} grid 
         * @return {mixed}
         */
        window.optionsGridRegister = function(grid) {
            optionsModalGrid = grid;
            optionsModalNode = $(optionsModalGrid.getDOMNode());

            // Update local data and re-render components
            optionsModalNode.on('removedRows.griddle', function (e, removedRows, grid) {
                var options = optionsModalGrid.getRows().map(function(row) {
                    return toggleSpace(row.label);
                });
                $(OPTS).trigger('remove', [options, removedRows]);
            })
            .on('addedRows.griddle', function (e, addedRows, grid) {
                // 
            });
        }

        /**
         * Add new option row
         */
        window.insertNewFieldOption = function() {
            optionsModalGrid.addRows([{id : guid()}]);
        }

        /**
         * Callback for edit row on option grid
         * @param  {Object} editedRow 
         * @return {mixed}
         */
        window.editShopperOption = function(editedRow, e) {
            var form = shopperModalNode.find('#frontend-field-grid_options_form');
            if (form.valid()) {
                // If available row is edited
                if (!isNaN(editedRow.id)) {
                    if (!_.contains(editedRows, editedRow.id)) {
                        // Edited row do not exist on local data then just toggle tab
                        $(OPTS).trigger('edit', [editedRow]);
                    } else {
                        // Edited row exist on local data then update local data and re-render price tabs grid
                        $(OPTS).trigger('edit', [editedRow, true]);

                        // Clear local data
                        _(editedRows).each(function(id, i) {
                            if (id == editedRow.id) delete editedRows[i];
                        });
                    }
                } else { // edit new row
                    var existedRow = _.contains(_.pluck(addedRows, 'id'), editedRow.id);
                    if (!existedRow) // item does not exist in local data then add to local data and re-render price tabs
                        $(OPTS).trigger('add', [editedRow]);
                    else // item has existed in local data then edit
                        $(OPTS).trigger('edit', [editedRow]);
                }
            }
        }

        /**
         * Callback functions onchange option name
         * @param  {Object} e 
         * @return {mixed}
         */
        window.editShopperOptionLabelCallback = function(e) {
            // Disable save change button if validation fail
            if (shopper.options_serialized && !shopper.options_serialized[e.target.value]) {
                shopperModalNode.find('.modal-footer button.btn-primary').prop('disabled', true);
            } else {
                shopperModalNode.find('.modal-footer button.btn-primary').prop('disabled', false);
            }

            // If validation passes then save edited row on local data
            if (validateAttrs()) {
                var id = $(e.target).attr('id').substring($(e.target).attr('id').length - 1);
                id = parseInt(id);
                // if row id is number
                if (!isNaN(id)) {
                    if (!_.contains(editedRows, id)) {
                        editedRows.push(id);
                    }
                }
            }
        }

        /**
         * Callback functions onchange option position
         * @param  {Object} e 
         * @return {mixed}
         */
        window.editShopperOptionPositionCallback = function(e) {
            validateAttrs();
        }

        /**
         * Callback function for storing prices
         * @param {Object} prices 
         * @param {string} option
         */
        window.shopperPriceTypeCallback = function(prices, option) {
            if (!shopper.options_serialized) {
                shopper.options_serialized = {};
            }

            if (!shopper.options_serialized[option]) {
                shopper.options_serialized[option] = {};
            }

            shopper.options_serialized[option].prices = prices;
        }

        /**
         * React component for render prices tab list
         */
        var PriceTabList = React.createClass({
            getInitialState: function () {
                return { active: 0 };
            },
            mixins: [FCom.Mixin, FCom.PriceMixin],
            init: function(option) {
                var optionsSerialized = {};
                if (!_.isEmpty(this.props.row.options_serialized)) {
                    optionsSerialized = this.props.row.options_serialized;
                }
                var prices    = [];

                shopperPrices = !_.isEmpty(optionsSerialized) && optionsSerialized[option] ? optionsSerialized[option].prices : (shopper.options_serialized && !_.isEmpty(shopper.options_serialized[option]) ? shopper.options_serialized[option].prices : []);

                if (shopperPrices && shopperPrices.length) {
                    prices = typeof shopperPrices === 'string' ? JSON.parse(shopperPrices) : shopperPrices;
                }

                /**
                 * Validate unique price
                 * @return mixed
                 */
                var validatePrices = function() {
                    var valid = true;
                    $('#{{ frontendFieldGrid.config.id }}_options_form').find('select.'+option+'PriceUnique').each(function (el) {
                        if (!$(this).valid()) {
                            valid = false;
                        }
                    });
                    return valid;
                }

                var validateUniqueMethod = option + 'PriceUnique',
                    validateBaseMethod   = option + 'BaseField',
                    validateUniqueRule   = {},
                    validateBaseRule     = {};

                validateUniqueRule[validateUniqueMethod] = true;
                $.validator.addMethod(validateUniqueMethod, this.validateUniquePrice(option), '{{"Price already exists."|_}}');
                $.validator.addClassRules(validateUniqueMethod, validateUniqueRule);

                validateBaseRule[validateBaseMethod] = true;
                $.validator.addMethod(validateBaseMethod, this.validateBasePrice(option), '{{"No matching base price"|_}}');
                $.validator.addClassRules(option+"BaseField", validateBaseRule);

                return {
                    title: Locale._(capitalizeFirstLetter(option) + ' Prices'),
                    prices: prices,
                    // deleted: deletedPrices,
                    option: option,
                    addPriceCallback: 'shopperPriceTypeCallback',
                    priceTypes: {{ UTIL.toJson(model.priceTypeOptions()) | raw }},
                    editablePrices: {{ UTIL.toJson(priceHelper.fieldOptions('editable_prices')) | raw }},
                    customerGroups: {{ customerGroups ? UTIL.toJson(customerGroups) | raw: 'null' }},
                    sites: {{ sites ? UTIL.toJson(sites) | raw : 'null' }},
                    currencies: {{ currencies ? UTIL.toJson(currencies) | raw : 'null' }},
                    productId: '{{ model.id() }}',
                    optionId: toggleSpace(this.props.row.name),
                    validatePrices: validatePrices,
                    priceRelationOptions: {{ UTIL.toJson(priceHelper.fieldOptions('price_relation_options')) | raw }},
                    operationOptions: {{ UTIL.toJson(priceHelper.fieldOptions('operation_options')) | raw }},
                    showCustomers: {{ loadCustomerGroups ? 'true' : 'false' }},
                    showSites: {{ loadSites ? 'true' : 'false' }},
                    showCurrency: {{ loadCurrency ? 'true' : 'false' }}
                };
            },
            render: function(){
                var navTabs = [], tabPanes = [];
                _(this.props.elements).each(function(option, i) {
                    option = toggleSpace(option);
                    priceOptions = this.init(option);

                    var className;
                    if (i == this.state.active){
                        className = "active"
                    } else {
                        className = ""
                    }

                    var navTab = React.DOM.li({ className: className, role: 'presentation', key: option, id: option + '-tab' }, 
                        React.DOM.a({ 
                                id: 'btn'+capitalizeFirstLetter(option)+'Tab', 
                                href: '#'+option, 
                                role: 'tab', 
                                'data-toggle': 'tab',
                                'aria-controls': option,
                                onClick: (function(event) {
                                    // TODO: Re-rendering price grid if needed when tab changed or something like that
                                }).bind(this)
                            }, capitalizeFirstLetter(toggleSpace(option, true))
                        )
                    );

                    var tabPane = React.DOM.div({ role: 'tabpanel', className: 'tab-pane ' + className, id: option , key: option}, 
                        React.createElement(Price, { key: option, id: option, options: priceOptions })
                    );

                    navTabs.push(navTab);
                    tabPanes.push(tabPane);
                }.bind(this));

                return React.DOM.div({ className:"tab-pane", id: 'shopper-tab', role: 'tabpanel' }, 
                    React.DOM.ul({ id: shopperGrid.getConfig('id') + '-tabs', className: "nav nav-tabs prod-type f-horiz-nav-tabs" }, navTabs),
                    React.DOM.div({ id: shopperGrid.getConfig('id') + '-data-tabs', className: "tab-content" }, tabPanes)
                );
            }
        });

        /**
         * React component for render prices tab
         */
        var PriceTabs = React.createClass({
            displayName: "PriceTabs",
            getInitialState: function() {
                return {
                    options: []
                };
            },
            getDefaultProps: function() {
                return {
                    tabIndex: ''
                };
            },
            updateLocalData: function(rows, type) {
                switch(type) {
                    case 'add':
                        addedRows.push(rows);
                        break;
                    case 'remove':
                        deletedRows.push(rows[0]);
                        break;
                }
            },
            clearDeletedRows: function(options) {
                if (deletedRows.length) { // Remove delete options before re-render price tabs
                    var deletedOpts = _.pluck(deletedRows, 'label');
                    _(options).each(function(option, i) {
                        if (_.contains(deletedOpts, toggleSpace(option, true))) {
                            delete options[i];
                        }
                    });
                }
                return options;
            },
            componentDidMount: function() {
                var options = shopper.options ? parseOptions(shopper.options) : [];

                // Global event system for add row action on option grid
                $(OPTS).on('add', function(e, addedRow) { // console.log('add', addedRow);
                    this.updateLocalData(addedRow, 'add');
                    options.push(toggleSpace(addedRow.label));

                    // If local data contains rows has been deleted then clear them before re-render
                    options = this.clearDeletedRows(options);

                    this.props.tabIndex = addedRow ? addedRow.label : options[0].label;
                    this.setState({ options: options });
                }.bind(this));

                // Global event system for edit row action on option grid
                $(OPTS).on('edit', function(e, editedRow, isEditAttrs) { // console.log('edit', editedRow);
                    if (isEditAttrs) {
                        // Update row attrs
                        options = _(shopper.options_serialized).map(function(item, index) {
                            index = toggleSpace(index);
                            if (item.id == editedRow.id) {
                                item.sku      = editedRow.sku;
                                item.position = editedRow.position;
                                shopper.options_serialized[toggleSpace(editedRow.label)] = _.clone(item);
                                // Delete old option field
                                delete shopper.options_serialized[index];

                                return toggleSpace(editedRow.label);
                            } else return index;
                        });

                        // If local data contains rows has been deleted then clear them before re-render
                        options = this.clearDeletedRows(options);

                        this.props.tabIndex = editedRow ? editedRow.label : options[0].label;
                        this.setState({ options: options });
                    } else {
                        toggleTab(toggleSpace(editedRow.label));
                    }
                }.bind(this));

                // Global event system for remove row action on option grid
                $(OPTS).on('remove', function(e, options, removedRow) { // console.log('remove', removedRow);
                    this.updateLocalData(removedRow, 'remove');
                    this.setState({ options: options });
                }.bind(this));
            },
            componentDidUpdate: function(prevProps, prevState) {
                if (prevProps.tabIndex !== '') {
                    toggleTab(toggleSpace(prevProps.tabIndex));
                    // Reset tabIndex for next time edited
                    prevProps.tabIndex = '';
                }
            },
            componentWillUnmount: function () {
                $(OPTS).off('add');
                $(OPTS).off('edit');
                $(OPTS).off('remove');
            },
            getOptions: function() {
                return _.isEmpty(this.state.options) ? this.props.options : this.state.options;
            },
            render: function() {
                var optionLabelIndex = optionDataIndex = 0;
                var options = this.getOptions();
                return React.DOM.div({ className: "tabbable" },
                    React.DOM.ul({ className: "nav nav-tabs prod-type f-horiz-nav-tabs" },
                        React.DOM.li({ className: 'active', role: 'presentation' }, 
                            React.DOM.a({ id: 'btnOptionsTab',href: '#options-tab', 'aria-controls': 'options-tab', role: 'tab', 'data-toggle': 'tab' }, 'Options')
                        ),
                        React.DOM.li({ className: '', role: 'presentation' }, 
                            React.DOM.a({ id: 'btnShopperTab', href: '#shopper-tab', 'aria-controls': 'shopper-tab', role: 'tab', 'data-toggle': 'tab' }, 'Price rule')
                        )
                    ),
                    React.DOM.div({ className: "tab-content" }, 
                        React.DOM.div({ className: "tab-pane active", id: 'options-tab', role: 'tabpanel' }, 
                            React.DOM.div({ id: '{{ frontendFieldGrid.config.id }}_options_grid' })
                        ),
                        React.createElement(PriceTabList, { key: 'shopper-tab', elements: options, row: this.props.row })
                    )
                );
            }
        });

        /**
         * Modal for editing shopper field item
         * @param  {Object} row
         * @return React modal form
         */
        window.showModalToEditShopperField = function(row) {
            // Return if input type does not select
            if (row.input_type !== 'select') {
                return;
            }

            shopper = row;
            shopperId       = row.id;

            if (shopper.options_serialized && _.isString(shopper.options_serialized)) {
                shopper.options_serialized = JSON.parse(shopper.options_serialized);
            }

            var options = row.options ? parseOptions(row.options) : [];

            var modalContainerEle = document.getElementById('fcom_append_form');
            React.unmountComponentAtNode(modalContainerEle);
            React.render(
                React.createElement(Components.Modal, {
                        id: "editShopperFieldsModal",
                        show: true,
                        title: 'Edit Form',
                        confirm: 'Save changes',
                        cancel: 'Close',
                        onCancel: function(modal) {
                            // Remove added rows on cancel
                            var addedRows = _(optionsModalGrid.getRows()).filter(function(row) {
                                if (isNaN(row.id)) {
                                    // Clear new price on current shopper
                                    if (shopper.options_serialized[toggleSpace(row.label)]) {
                                        delete shopper.options_serialized[toggleSpace(row.label)];
                                    }

                                    // Clear new options string for update main grid options
                                    var options = shopper.options.split(',').filter(function(option) {
                                        if (option != row.label) {
                                            return option;
                                        }
                                    });
                                    shopper.options = options.join(',');

                                    return row;
                                }
                            });

                            if (addedRows.length) {
                                // Clear new options modal grid
                                optionsModalGrid.removeRows(addedRows);

                                // Update shopper grid data
                                shopperGrid.updateRows([shopper]);
                            }

                            modal.close();
                        },
                        onLoad: function(modal) {
                            shopperModalNode = $(modal.getDOMNode());
                            shopperModalNode.find('.modal-dialog').css('width', '1280px');
                        },
                        onConfirm: window.saveShopperModal
                    },
                    React.DOM.div({ className: "row f-grid-wrapper" }, 
                        React.DOM.form({id:'{{ frontendFieldGrid.config.id }}_options_form'},
                            React.createElement(PriceTabs, { row: shopper, options: options })
                        )
                    )
                ), modalContainerEle
            );

            // Register options grid
            var optionsConfigCompiled = {{ UTIL.toJson(optionsConfigCompiled) | raw }};
            var attachGridContainerEle = document.getElementById('{{ frontendFieldGrid.config.id }}_options_grid');

            // Add available shopper dropdown options to options grid
            if (options.length) {
                var optionsSerialized = row.options_serialized;
                options = options.map(function(option, i) {
                    var index = ++i;
                    if (shopper.options_serialized[toggleSpace(option)]) {
                        shopper.options_serialized[toggleSpace(option)].id = index;
                    }
                    return {
                        id: index,
                        label: toggleSpace(option, true),
                        sku: (optionsSerialized && optionsSerialized[option] && optionsSerialized[option].sku) ? optionsSerialized[option].sku : option,
                        position: (optionsSerialized && optionsSerialized[option] && optionsSerialized[option].position) ? optionsSerialized[option].position : i
                    };
                });
                optionsConfigCompiled.data.data = options;
            }

            React.render(
                React.createElement(FComGriddleComponent, { config: optionsConfigCompiled }
            ), attachGridContainerEle);

            // Position unique validation
            function validateUniquePosition (value, elem) {
                var valid = true;
                if (typeof elem !== 'undefined') {
                    var $parent = $(elem).parents('tr');

                    var items = optionsModalNode.find('tr');
                    items.each(function() {
                        if (!valid) {
                            return;
                        }

                        var item = $(this);
                        if (this === $parent[0]) {
                            return;
                        }

                        valid = value !== item.find('input[data-col="position"]').val();
                        toggleActionButton(valid);
                    });
                    return valid;
                }
            }
            $.validator.addMethod('validateUniquePosition', validateUniquePosition, '{{"Position already exists."|_}}');
            $.validator.addClassRules('optionPositionUnique', {
                validateUniquePosition: true
            });

            // Option unique validation
            function validateUniqueOption (value, elem) {
                var valid = true;
                if (typeof elem !== 'undefined') {
                    var $parent = $(elem).parents('tr');

                    var items = optionsModalNode.find('tr');
                    items.each(function() {
                        if (!valid) {
                            return;
                        }

                        var item = $(this);
                        if (this === $parent[0]) {
                            return;
                        }

                        valid = value !== item.find('input[data-col="label"]').val();
                        toggleActionButton(valid);
                    });
                    return valid;
                }
            }
            $.validator.addMethod('validateUniqueOption', validateUniqueOption, '{{"Option already exists."|_}}');
            $.validator.addClassRules('optionLabelUnique', {
                validateUniqueOption: true
            });
        }

        /**
         * Callback function for update field
         * @return mixed
         */
        window.saveShopperModal = function(modal) {
            var form            = shopperModalNode.find('#frontend-field-grid_options_form');
            if (form.valid()) { // Passes validation
                // If has deleted rows local data
                if (deletedRows && !_.isEmpty(deletedRows)) {
                    // Clear new options modal grid
                    optionsModalGrid.removeRows(deletedRows);

                    // Update shopper grid data
                    shopperGrid.updateRows([shopper]);
                }

                processPostData();
                modal.close();
            }
        }

        /**
         * Process post data
         * @return {mixed}
         */
        function processPostData() {
            var rows            = optionsModalGrid.getRows(),
                optionSaveStr   = '',
                data            = {};

            _(rows).each(function(row, index) {
                var optionLabel = toggleSpace(row.label);
                if (typeof data[optionLabel] === 'undefined') {
                    data[optionLabel] = {};
                }

                var $container  = $('#'+optionLabel+'-prices'),
                    $trItems    = $container.find('.'+optionLabel+'-price-item'),
                    prices      = [];

                optionSaveStr += optionLabel + ',';

                if (!shopper.options_serialized) {
                    shopper.options_serialized = {};
                }

                if (!shopper.options_serialized[optionLabel]) {
                    shopper.options_serialized[optionLabel] = {};
                }

                shopper.options_serialized[optionLabel].sku      = row.sku;
                shopper.options_serialized[optionLabel].position = row.position;

                data[optionLabel]['sku']      = row.sku; 
                data[optionLabel]['position'] = row.position;

                $trItems.each(function(i, item) {
                    var price           = {};
                    price['id']         = ++i;
                    price['product_id'] = {{ model.id }};
                    $(item).find('input, select').each(function(index, el) {
                        var key = $(this).data('type'),
                            val = $(this).val();
                        if (typeof key !== 'undefined') {
                            price[key] = shopperGrid.html2text(val);
                        }
                    });
                    prices.push(price);
                });

                if (prices.length) {
                    data[optionLabel]['prices'] = prices;
                }
            });

            // If input data container does not exist then create
            if ($('#shopper_field_prices_'+shopperId).length === 0) {
                $('#tab-shopper_fields').append('<input type="hidden" data-shopper-id="'+shopperId+'" id="shopper_field_prices_'+shopperId+'" />');
            }

            var hiddenInput = $('#shopper_field_prices_'+shopperId);
            if (hiddenInput.data('shopper-id') === shopperId) {
                $('#shopper_field_prices_'+shopperId).val(JSON.stringify(data));
            }

            shopper.options = optionSaveStr.slice(0, optionSaveStr.length - 1);
            shopperGrid.updateRows([shopper]);
        }

    });
</script>
<div class="row">
    <div class="col-sm-10">
        {{ THIS.view('core/griddle').set('grid', frontendFieldGrid) | raw }}
    </div>
</div>
<input type='hidden' id='prod_frontend_data' name='prod_frontend_data' />

{% set ctrl = APP.instance('Sellvana_ShopperFields_Admin') %}
{% set frontendFieldGrid = ctrl.frontendFieldGrid(model) %}
{% set frontendOptionsGrid = ctrl.frontendOptionsGrid(model) %}
{% set optionsConfigCompiled = THIS.view('core/griddle').set('grid', frontendOptionsGrid).getGridConfig() %}

{% set loadCustomerGroups = MODULES.isLoaded('Sellvana_CustomerGroups') %}
{% if loadCustomerGroups %}
    {% set customerGroups = APP.instance('Sellvana_CustomerGroups_Model_Group').groupsOptions() %}
{% endif %}

{% set loadSites = MODULES.isLoaded('Sellvana_MultiSite') %}
{% if loadSites %}
    {% set sites = APP.instance('Sellvana_MultiSite_Model_Site').siteOptions() %}
{% endif %}

{% set loadCurrency = MODULES.isLoaded('Sellvana_MultiCurrency') %}
{% if loadCurrency %}
    {% set currencies = APP.instance('Sellvana_MultiCurrency_Main').getAvailableCurrencies() %}
{% endif %}
{% set priceHelper = APP.instance('Sellvana_Catalog_Model_ProductPrice') %}

<script>
    /*require(['backbone', 'underscore', 'jquery'], function(Backbone, _, $) {
        var mainGrid;
        var inputName = 'input[data-col="name"]';
        var inputOption = 'input[data-col="options"]';
        var selectFieldType = 'select[data-col="input_type"]';
        window.frontendFieldGridRegister = function(grid) {
            mainGrid = grid;
            grid.getGridSkeleton().Views.RowView.prototype.afterRender = function() {
                var self = this;
                this.$el.find(inputName).addClass('unique');
                this.$el.find(inputOption).addClass('requiredOptions');
                if (this.model.get('input_type') != 'select') {
                    this.$el.find(inputOption).prop('disabled', true);
                }
                this.$el.find(selectFieldType).change(function() {
                    if ($(this).val() == 'select') {
                        self.$el.find(inputOption).prop('disabled', false);
                    } else {
                        self.$el.find(inputOption).prop('disabled', true);
                    }
                })
            }
            grid.build();
        }
        $('#catalog-products-form').submit(function (ev) {
            var rows = mainGrid.getRows().toJSON();

            var res = [];
            for (var i in rows) {
                if (rows[i].position.length == 0) {
                    rows[i].position = 0;
                }
                res.push(_.pick(rows[i], 'id', 'name', 'label', 'input_type', 'required', 'options', 'position'));
            }

            $("#prod_frontend_data").val(JSON.stringify(res));
        });
        function checkUnique(value, elem, params) {
            var error = true;
            if (typeof (elem) !== 'undefined') {
                var parent = $(elem).parents('tr');
                var val = parent.find(inputName).val();
                mainGrid.getRows().each(function (data) {
                    if (parent.attr('id') != data.get('id') && val == data.get('name')) {
                        error = false;
                    }
                });
            }

            return error;
        }

        $.validator.addMethod('checkUnique', checkUnique , 'Field Name are already taken place.');

        $.validator.addClassRules("requiredOptions", {
            required: function (value, elem, params) {
                var error = true;
                if (typeof (elem) !== 'undefined') {
                    var parent = $(elem).parents('tr');
                    if (parent.find(selectFieldType).val() == 'select' &&  value.trim().length == 0) {
                        error = false;
                    }
                }
                return error;
            }
        });

        $.validator.addClassRules("unique", {
            required: true,
            checkUnique: true
        });

    });*/
</script>
<script>
    var shopperGrid, 
        shopperNode, 
        shopperModalNode,
        optionsModalGrid, 
        optionsModalNode, 
        fieldModalGrid, 
        currentPrices, 
        oldPrices, 
        deletedPrices = [],
        optionId,
        fieldId,
        shopperOptions = [],
        currentShopper,
        shopperPrices = [],
        OPTS = {};

    require(['react', 'underscore', 'jquery', 'fcom.components'], function(React, _, $, Components) {

        var inputName       = 'input[data-col="name"]';
        var inputOption     = 'a[data-col="options"]';
        // var inputOption     = 'input[data-col="options"]';
        var selectFieldType = 'select[data-col="input_type"]';

        /**
         * Main grid register callback
         * @param  {Object} grid
         * @return mixed
         */
        window.fieldsGridRegister = function(grid) {
            shopperGrid = grid;
            shopperNode = $(shopperGrid.getDOMNode());
            updateValidation();
            shopperNode.on('removedRows.griddle', function (e, removedRows, grid) {
                console.log('removedRows callback');
            })
            .on('addedRows.griddle', function (e, removedRows, grid) {
                updateValidation();
            });
        }

        /**
         * Add blank row to grid
         */
        window.addBlankRows = function(grid) {
            shopperGrid.addRows([{id : guid()}]);
        }

        /*
         *function to set attachment grid data into form fields to send them server
         *This function is callend when 'save' button of product form is clicked.
         */
        window.submitCallback.push(function () {
            shopperNode.find('form').validate();
            var rows = shopperGrid.getRows();

            var res = [];
            _(rows).each(function(row) {
                var optionSerialized = '';
                if (row.position == 0) {
                    row.position = 0;
                }

                var data = _.pick(row, 'id', 'name', 'label', 'input_type', 'required', 'options', 'position');
                if (row.input_type === 'select') { // Only save prices when field is select
                    var $priceEle = $('input[data-shopper-id="'+row.id+'"]');
                    if ($priceEle.length) { // If price modal is saved changed
                        optionSerialized = $priceEle.val();
                    } else {
                        if (typeof row.option_serialized === 'string' && row.option_serialized.length) { // 
                            optionSerialized = row.option_serialized;
                        } else { // If added prices but not saved changed then remove
                            _(row.option_serialized).each(function(optionPrice, index) {
                                if (isNaN(optionPrice.prices[0].id)) {
                                    delete row.option_serialized[index];
                                }
                            });
                            optionSerialized = JSON.stringify(row.option_serialized);
                        }
                    }
                    data['option_serialized'] = optionSerialized;
                }
                res.push(data);
            });

            $("#prod_frontend_data").val(JSON.stringify(res));
        });

        /**
         * Update validation class for all rows
         * @return mixed
         */
        function updateValidation() {
            shopperNode.find(inputName).addClass('unique');
            shopperNode.find(inputOption).addClass('requiredOptions');
            var rows = shopperGrid.getRows();
            _.each(rows, function(row) {
                if (row.input_type != 'select') {
                    // shopperNode.find('tr#' + row.id).find(inputOption).prop('disabled', true);
                    shopperNode.find('tr#' + row.id).find(inputOption)[0].innerText = '';
                }
            });

            /**
             * Disable options upon field type is not dropdown
             */
            shopperNode.find(selectFieldType).on('change', function(e) {
                var pId = $(this).parents('tr').attr('id');
                var count = $(this).parents('tr#'+pId).find(inputOption).data('length');
                if ($(this).val() == 'select') {
                    var optionLabel = count <= 1 ? ' Option' : ' Options';
                    $(this).parents('tr#'+pId).find(inputOption)[0].innerText = count + optionLabel;
                } else {
                    $(this).parents('tr#'+pId).find(inputOption)[0].innerText = '';
                }
            });

            /**
             * Check grid field name is unique
             * @return boolean
             */
            function checkUnique(value, elem, params) {
                var error = true;
                if (typeof (elem) !== 'undefined') {
                    var parent = $(elem).parents('tr');
                    var val = parent.find(inputName).val();
                    _.each(shopperGrid.getRows(), function(data) {
                        if (parent.attr('id') != data.id && val == data.name) {
                            error = false;
                        }
                    });
                }
                return error;
            }

            $.validator.addMethod('checkUnique', checkUnique , 'Field Name are already taken place.');

            $.validator.addClassRules("requiredOptions", {
                required: function (value, elem, params) {
                    var error = true;
                    if (typeof (elem) !== 'undefined') {
                        var parent = $(elem).parents('tr');
                        if (parent.find(selectFieldType).val() == 'select' &&  value.trim().length == 0) {
                            error = false;
                        }
                    }
                    return error;
                }
            });

            $.validator.addClassRules("unique", {
                required: true,
                checkUnique: true
            });
        }
    });

    require(['react', 'underscore', 'jquery', 'fcom.griddle', 'griddle.fcomModalForm', 'fcom.components', 'fcom.catalog.price', 'fcom.locale', 'fcom.catalog.components'], function(React, _, $, FComGriddleComponent, FComModalForm, Components, Price, Locale) {

        /**
         * Options grid register
         * @param  {Objec} grid 
         * @return {mixed}
         */
        window.optionsGridRegister = function(grid) {
            optionsModalGrid = grid;
            optionsModalNode = $(optionsModalGrid.getDOMNode());
            optionsModalNode.on('removedRows.griddle', function (e, removedRow, grid) {
                var options = optionsModalGrid.getRows().map(function(row) {
                    return toggleSpace(row.label);
                });
                $(OPTS).trigger('remove', [options, removedRow]);
            })
            .on('addedRows.griddle', function (e, addedRows, grid) {

            });
        }

        /**
         * Add new option row
         */
        window.insertNewFieldOption = function() {
            optionsModalGrid.addRows([{id : guid()}]);
        }

        /**
         * Callback for edit row on option grid
         * @param  {Object} editedRow 
         * @return {mixed}
         */
        window.editShopperOption = function(editedRow, e) {
            var form = shopperModalNode.find('#frontend-field-grid_options_form');
            if (form.valid()) {
                var options = currentShopper.options ? parseOptions(currentShopper.options) : [];
                var newOptions = _(options).map(function(option, index) {
                    if (++index == editedRow.id) {
                        var regex = new RegExp(option, 'g');
                        var optionsStr = currentShopper.options.replace(regex, editedRow.label);
                        currentShopper.options = optionsStr;

                        _(currentShopper.option_serialized).each(function(item, index) {
                            if (index == option) {
                                item.sku = editedRow.sku;
                                item.position = editedRow.position;
                                currentShopper.option_serialized[editedRow.label] = item;
                                delete currentShopper.option_serialized[option];
                            }
                        });

                        return toggleSpace(editedRow.label);
                    } else return option;
                });
                
                shopperGrid.updateRows([currentShopper]); // Update shopper grid data
                $(OPTS).trigger('edit', [newOptions, editedRow]); // Subcribe global event for re-rendering react component
                $(e.target).parent().addClass('disabled'); // Disable save button
            }
        }

        /**
         * Add all new prices on options grid
         */
        window.addPrices = function() {
            var form = shopperModalNode.find('#frontend-field-grid_options_form');
            if (form.valid()) {
                var options = optionsModalGrid.getRows().map(function(row) {
                    if (isNaN(row.id) && $.inArray(row.label, shopperOptions) === -1) {
                        if (typeof shopperOptions[fieldId] === 'undefined') {
                            shopperOptions[fieldId] = [];
                        }

                        if (!row.label in shopperOptions[fieldId]) {
                            shopperOptions[fieldId].push(toggleSpace(row.label));
                        }
                    }
                    return toggleSpace(row.label);
                });

                $(OPTS).trigger('add', [options]); // Subcribe global event for re-rendering react component
            }
        }

        /**
         * Callback functions onchange on option input attribute
         * @param  {Object} e 
         * @return {mixed}
         */
        window.editShopperOptionLabelCallback = window.editShopperOptionPositionCallback = window.editShopperOptionSkuCallback = function(e) {
            if (e.target.value != e.target.getAttribute('data-tmp-value')) {
                optionsModalNode.find('#add-prices').prop('disabled', true);
                $(e.target).parents('tr').find('.btn-edit').removeClass('disabled');
            } else {
                optionsModalNode.find('#add-prices').prop('disabled', false);
                $(e.target).parents('tr').find('.btn-edit').addClass('disabled');
            }
        }

        /**
         * Callback function for storing prices
         * @param {Object} prices 
         * @param {string} option
         */
        window.shopperPriceTypeCallback = function(prices, option) {
            if (typeof shopperOptions[fieldId] === 'undefined') {
                shopperOptions[fieldId] = [];
            }

            if (!currentShopper.options && !_.contains(shopperOptions[fieldId], option)) {
                shopperOptions[fieldId].push(toggleSpace(option));
            }

            if (currentShopper.options && !_.contains(parseOptions(currentShopper.options), option)) {
                shopperOptions[fieldId].push(toggleSpace(option));
            }

            if (currentShopper.option_serialized === '' || typeof currentShopper.option_serialized === 'undefined') {
                currentShopper.option_serialized = [];
            }

            if (typeof currentShopper.option_serialized[option] === 'undefined') {
                currentShopper.option_serialized[option] = {};
            }

            currentShopper.option_serialized[option].prices = prices;
        }

        /**
         * Toggle tabs when edit trigger
         * @param  {string} label 
         * @return {mixed}
         */
        window.toggleTab = function(label) {
            shopperModalNode.find('#btn'+capitalizeFirstLetter(toggleSpace(label))+'Tab').click();
            shopperModalNode.find('#btnShopperTab').click();
        }

        /**
         * Convert space chars to hyphen or on the contrary
         * @param  {string}  string
         * @param  {Boolean} isRevert
         * @return {string}
         */
        function toggleSpace(string, isRevert) {
            string = $.trim(string);
            if (isRevert) {
                return string.replace(/\-/g, ' ');
            } else {
                return string.replace(/\s/g, '-');
            }
        }

        /**
         * Parse options string to array
         * @param  {string} options 
         * @return {Array}
         */
        function parseOptions(options) {
            if (typeof options === 'string' && options.length) {
                return options.split(',');
            }
            return [];
        }

        /**
         * Capitalize first letter
         * @param  {string} string 
         * @return {string}
         */
        function capitalizeFirstLetter(string) {
            return string.toLowerCase().charAt(0).toUpperCase() + string.slice(1);
        }

        /**
         * Merge options of current row to global added options of specify row's options
         * @param  {string} curOptions
         * @param  {Object} addedOptions
         * @return {string}
         */
        function mergeOptions(curOptions, addedOptions) {
            _(addedOptions).map(function(addedOption) {
                if (curOptions.indexOf(addedOption) === -1) {
                    return curOptions += ',' + addedOption;
                }
            });

            return curOptions;
        }

        /**
         * React component for render option's price
         */
        var PriceTabs = React.createClass({
            displayName: "PriceTabs",
            mixins: [FCom.Mixin, FCom.PriceMixin],
            getInitialState: function() {
                return {
                    options: []
                };
            },
            getDefaultProps: function() {
                return  {
                    row: {},
                    addedOption: '',
                    editedOption: '',
                    removedOption: ''
                }
            },
            componentDidMount: function() {
                // Global event system for add row action on option grid
                $(OPTS).on('add', function(e, options, addedRow) {
                    this.props.addedOption = addedRow ? addedRow.label : options[0].label;
                    this.setState({ options: options });
                }.bind(this));

                // Global event system for edit row action on option grid
                $(OPTS).on('edit', function(e, options, editedRow) {
                    this.props.editedOption = editedRow ? editedRow.label : options[0].label;
                    this.setState({ options: options });
                }.bind(this));

                // Global event system for remove row action on option grid
                $(OPTS).on('remove', function(e, options, removedRow) {
                    this.setState({ options: options });
                }.bind(this));
            },
            componentDidUpdate: function(prevProps, prevState) {
                if (this.props.addedOption !== '') {
                    toggleTab(this.props.addedOption);
                    this.props.addedOption = '';
                }

                if (this.props.editedOption !== '') {
                    optionsModalNode.find('#add-prices').prop('disabled', false);
                    this.props.editedOption = '';
                }

            },
            componentWillUnmount: function () {
                $(OPTS).off('add');
                $(OPTS).off('edit');
                $(OPTS).off('remove');
            },
            getOptions: function() {
                return _.isEmpty(this.state.options) ? this.props.options : this.state.options;
            },
            render: function() {
                var optionLabelIndex = optionDataIndex = 0;
                var options = this.getOptions();
                return React.createElement("div", { className: "tabbable" },
                    React.createElement("ul", { className: "nav nav-tabs prod-type f-horiz-nav-tabs" },
                        React.createElement('li', { className: 'active', role: 'presentation' }, 
                            React.createElement('a', { id: 'btnOptionsTab',href: '#options-tab', 'aria-controls': 'options-tab', role: 'tab', 'data-toggle': 'tab' }, 'Options')
                        ),
                        React.createElement('li', { className: '', role: 'presentation' }, 
                            React.createElement('a', { id: 'btnShopperTab', href: '#shopper-tab', 'aria-controls': 'shopper-tab', role: 'tab', 'data-toggle': 'tab' }, 'Price rule')
                        )
                    ),
                    React.createElement("div", { className: "tab-content" }, 
                        React.createElement("div", { className: "tab-pane fade in active", id: 'options-tab', role: 'tabpanel' }, 
                            React.createElement("div", {id:'{{ frontendFieldGrid.config.id }}_options_grid'})
                        ),
                        React.createElement("div", { className: "tab-pane fade", id: 'shopper-tab', role: 'tabpanel' },
                            React.createElement("ul", { id: shopperGrid.getConfig('id') + '-tabs', className: "nav nav-tabs prod-type f-horiz-nav-tabs" },
                                _(options).map(function(option) {
                                    option = toggleSpace(option);
                                    var className = '';
                                    if (optionLabelIndex == 0) {
                                        className = 'active';
                                        optionLabelIndex++;
                                    }
                                    return React.createElement('li', { className: className, role: 'presentation', key: option, id: option + '-tab' }, 
                                            React.createElement('a', { id: 'btn'+capitalizeFirstLetter(option)+'Tab', href: '#'+option, 'aria-controls': option, role: 'tab', 'data-toggle': 'tab' }, capitalizeFirstLetter(toggleSpace(option, true)))
                                        );
                                }.bind(this))
                            ),
                            React.createElement("div", { id: shopperGrid.getConfig('id') + '-data-tabs', className: "tab-content" }, 
                                _(options).map(function(option, index) {
                                    option = toggleSpace(option);
                                    var optionSerialized = {};
                                    if (!_.isEmpty(this.props.row.option_serialized)) {
                                        // optionSerialized = JSON.parse(this.props.row.option_serialized);
                                        optionSerialized = this.props.row.option_serialized;
                                    }
                                    var className = '',
                                        prices    = [];

                                    shopperPrices = !_.isEmpty(optionSerialized) && optionSerialized[option] ? optionSerialized[option].prices : (currentShopper.option_serialized && !_.isEmpty(currentShopper.option_serialized[option]) ? currentShopper.option_serialized[option].prices : []);

                                    if (optionDataIndex == 0) {
                                        className = 'in active';
                                        optionDataIndex++;
                                    }

                                    if (shopperPrices && shopperPrices.length) {
                                        prices = typeof shopperPrices === 'string' ? JSON.parse(shopperPrices) : shopperPrices;
                                    }

                                    /**
                                     * Validate unique price
                                     * @return mixed
                                     */
                                    var validatePrices = function() {
                                        var valid = true;
                                        $('#{{ frontendFieldGrid.config.id }}_options_form').find('select.'+option+'PriceUnique').each(function (el) {
                                            if (!$(this).valid()) {
                                                valid = false;
                                            }
                                        });
                                        return valid;
                                    }

                                    var priceOptions = {
                                        id: 'shopper',
                                        title: Locale._(capitalizeFirstLetter(option) + ' Prices'),
                                        data_mode: 'local',
                                        prices: prices,
                                        deleted: deletedPrices,
                                        add_price_type_callback: 'shopperPriceTypeCallback',
                                        price_types: {{ UTIL.toJson(model.priceTypeOptions()) | raw }},
                                        editable_prices: {{ UTIL.toJson(priceHelper.fieldOptions('editable_prices')) | raw }},
                                        customer_groups: {{ customerGroups ? UTIL.toJson(customerGroups) | raw: 'null' }},
                                        sites: {{ sites ? UTIL.toJson(sites) | raw: 'null' }},
                                        currencies: {{ currencies ? UTIL.toJson(currencies) | raw: 'null' }},
                                        product_id: '{{ model.id() }}',
                                        field_id: toggleSpace(this.props.row.name),
                                        validatePrices: validatePrices,
                                        priceRelationOptions: {{ UTIL.toJson(priceHelper.fieldOptions('price_relation_options')) | raw }},
                                        operationOptions: {{ UTIL.toJson(priceHelper.fieldOptions('operation_options')) | raw }},
                                        show_customers: {{ loadCustomerGroups ? 'true' : 'false' }},
                                        show_sites: {{ loadSites ? 'true' : 'false' }},
                                        show_currency: {{ loadCurrency ? 'true' : 'false' }}
                                    };

                                    var node = React.createElement('div', { role: 'tabpanel', className: 'tab-pane fade ' + className, id: option , key: option}, 
                                            React.createElement(Price, { id: option, options: priceOptions })
                                        );

                                    var validateUniqueMethod = option+'PriceUnique',
                                        validateBaseMethod = option+'BaseField',
                                        validateUniqueRule = {};

                                    validateUniqueRule[validateUniqueMethod] = true;
                                    $.validator.addMethod(validateUniqueMethod, this.validateUniquePrice(option), '{{"Price already exists."|_}}');
                                    $.validator.addClassRules(validateUniqueMethod, validateUniqueRule);

                                    $.validator.addMethod(validateBaseMethod, this.validateBasePrice(option), '{{"No matching base price"|_}}');
                                    $.validator.addClassRules("base_field", {
                                        base_field: true
                                    });

                                    return node;
                                }.bind(this))
                            )
                        )
                    )
                );
            }
        });

        /**
         * Modal for editing shopper field item
         * @param  {Object} row
         * @return React modal form
         */
        window.showModalToEditShopperField = function(row) {
            // Return if input type does not select
            if (row.input_type !== 'select') {
                return;
            }

            currentShopper = row;
            optionId       = row.id;
            fieldId        = toggleSpace(row.name);
            var options    = [];

            if ('option_serialized' in row) {
                if (currentShopper.option_serialized && typeof currentShopper.option_serialized === 'string') {
                    currentShopper.option_serialized = currentShopper.option_serialized ? JSON.parse(currentShopper.option_serialized) : [];
                }
                options = row.options ? (_.isEmpty(shopperOptions[fieldId]) ? parseOptions(row.options) : parseOptions(mergeOptions(row.options, shopperOptions[fieldId]))) : (shopperOptions[fieldId] ? shopperOptions[fieldId] : []);

                // Preventive case if has duplicate options
                options = _.unique(options);
            }

            var modalContainerEle = document.getElementById('fcom_append_form');
            React.unmountComponentAtNode(modalContainerEle);
            React.render(
                React.createElement(Components.Modal, {
                        id: "editShopperFieldsModal",
                        show: true,
                        title: 'Edit Form',
                        confirm: 'Save changes',
                        cancel: 'Close',
                        onCancel: function(modal) {
                            modal.close();
                        },
                        onLoad: function(modal) {
                            shopperModalNode = $(modal.getDOMNode());
                            shopperModalNode.find('.modal-dialog').css('width', '1280px');
                        },
                        onConfirm: window.saveShopperModal
                    },
                    React.createElement("div", { className: "row f-grid-wrapper" }, 
                        React.createElement("form", {id:'{{ frontendFieldGrid.config.id }}_options_form'},
                            React.createElement(PriceTabs, { row: currentShopper, options: options })
                        )
                    )
                ), modalContainerEle
            );

            // Register options grid
            var optionsConfigCompiled = {{ UTIL.toJson(optionsConfigCompiled) | raw }};
            var attachGridContainerEle = document.getElementById('{{ frontendFieldGrid.config.id }}_options_grid');

            // Add available shopper dropdown options to options grid
            if (options.length) {
                var optionSerialized = row.option_serialized;
                options = options.map(function(option, i) {
                    return {
                        id: ++i,
                        label: option,
                        sku: optionSerialized[option] && optionSerialized[option].sku ? optionSerialized[option].sku : option,
                        position: optionSerialized[option] && optionSerialized[option].position ? optionSerialized[option].position : i
                    };
                });
                optionsConfigCompiled.data.data = options;
            }

            React.render(
                React.createElement(FComGriddleComponent, { config: optionsConfigCompiled }
            ), attachGridContainerEle);
        }

        /**
         * Callback function for update field
         * @return mixed
         */
        window.saveShopperModal = function(modal) {
            var form            = shopperModalNode.find('#frontend-field-grid_options_form'),
                options         = optionsModalGrid.getRows(),
                optionSaveStr   = '',
                data            = {};

            if (form.valid()) { // Passes validation
                // Process prices grid
                _.each(options, function(option) {
                    var optionLabel = toggleSpace(option.label)
                    if (typeof data[optionLabel] === 'undefined') {
                        data[optionLabel] = {};
                    }
                    var $container  = $('#'+optionLabel+'-prices'),
                        $trItems    = $container.find('.'+optionLabel+'-price-item'),
                        prices      = [];

                    optionSaveStr += optionLabel + ',';

                    data[optionLabel]['sku']      = option.sku; 
                    data[optionLabel]['position'] = option.position;
                    $trItems.each(function(i, item) {
                        var price           = {};
                        price['id']         = ++i;
                        price['product_id'] = {{ model.id }};
                        $(item).find('input, select').each(function(index, el) {
                            var key = $(this).data('type'),
                                val = $(this).val();
                            if (typeof key !== 'undefined') {
                                price[key] = shopperGrid.html2text(val);
                            }
                        });
                        prices.push(price);
                    });
                    if (prices.length) {
                        data[optionLabel]['prices'] = prices;
                    }
                });

                // If input data container does not exist then create
                if ($('#shopper_field_prices_'+optionId).length == 0) {
                    $('#tab-shopper_fields').append('<input type="hidden" data-shopper-id="'+optionId+'" id="shopper_field_prices_'+optionId+'" />');
                }

                var hiddenInput = $('#shopper_field_prices_'+optionId);
                if (hiddenInput.data('shopper-id') === optionId) {
                    $('#shopper_field_prices_'+optionId).val(JSON.stringify(data));
                }

                currentShopper.options = optionSaveStr.slice(0, optionSaveStr.length - 1);
                shopperGrid.updateRows([currentShopper]);
                modal.close();
            }
        }

    });
</script>
<div class="row">
    <div class="col-sm-10">
        {{ THIS.view('core/griddle').set('grid', frontendFieldGrid) | raw }}
    </div>
</div>
<input type='hidden' id='prod_frontend_data' name='prod_frontend_data' />

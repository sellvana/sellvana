<?php define('BNULL', '!@BNULL#$'); class BClass { static protected $_origClass; public static function origClass() { return static::$_origClass; } public static function i($new=false, array $args=array()) { if (is_object($new)) { $class = get_class($new); $new = false; } else { $class = get_called_class(); } return BClassRegistry::i()->instance($class, $args, !$new); } public function __call($name, $args) { return BClassRegistry::i()->callMethod($this, $name, $args, static::$_origClass); } public static function __callStatic($name, $args) { return BClassRegistry::i()->callStaticMethod(get_called_class(), $name, $args, static::$_origClass); } } class BApp extends BClass { protected static $_compat = array(); protected $_vars = array(); protected $_isConst = array(); public static function compat($feature) { if (!empty(static::$_compat[$feature])) { return static::$_compat[$feature]; } switch ($feature) { case 'PHP5.3': $compat = version_compare(phpversion(), '5.3.0', '>='); break; default: BDebug::error(BLocale::_('Unknown feature: %s', $feature)); } static::$_compat[$feature] = $compat; return $compat; } public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function __construct() { BDebug::i(); umask(0); } public function config($config) { if (is_array($config)) { BConfig::i()->add($config); } elseif (is_string($config) && is_file($config)) { BConfig::i()->addFile($config); } else { BDebug::error("Invalid configuration argument"); } return $this; } public function load($folders='.') { if (is_string($folders)) { $folders = explode(',', $folders); } $modules = BModuleRegistry::i(); foreach ($folders as $folder) { $modules->scan($folder); } return $this; } public function run() { BSession::i()->open(); BModuleRegistry::i()->bootstrap(); if (BConfig::i()->get('db/implicit_migration')) { BMigrate::i()->migrateModules(true); } BRouting::i()->dispatch(); BSession::i()->close(); return $this; } public static function t($string, $args=array()) { return Blocale::_($string, $args); } public static function m($modName=null) { $reg = BModuleRegistry::i(); return is_null($modName) ? $reg->currentModule() : $reg->module($modName); } public static function baseUrl($full=true, $method=1) { static $baseUrl = array(); $full = (int)$full; $key = $full.'|'.$method; if (empty($baseUrl[$key])) { $r = BRequest::i(); $c = BConfig::i(); $scriptPath = pathinfo($r->scriptName()); switch ($method) { case 1: $url = $c->get('web/base_href'); if (!$url) { $url = $scriptPath['dirname']; } break; case 2: $url = $scriptPath['dirname']; break; } if (!($r->modRewriteEnabled() && $c->get('web/hide_script_name'))) { $url = rtrim($url, "\\"); $url = rtrim($url, '/').'/'.$scriptPath['basename']; } if ($full) { $url = $r->scheme().'://'.$r->httpHost().$url; } $baseUrl[$key] = rtrim($url, '/').'/'; } return $baseUrl[$key]; } public static function url($modName, $url='', $method='baseHref') { $m = BApp::m($modName); if (!$m) { BDebug::error('Invalid module: '.$modName); return ''; } return $m->$method() . $url; } public static function href($url='', $full=true, $method=2) { return BApp::baseUrl($full, $method) . BRouting::processHref($url); } public static function src($modName, $url='', $method='baseSrc') { if ($modName[0]==='@' && !$url) { list($modName, $url) = explode('/', substr($modName, 1), 2); } $m = BApp::m($modName); if (!$m) { BDebug::error('Invalid module: '.$modName); return ''; } return $m->$method() . '/' . rtrim($url, '/'); } public function set($key, $val, $const=false) { if (!empty($this->_isConst[$key])) { BDebug::warning('Trying to reset a constant var: '.$key.' = '.$val); return $this; } $this->_vars[$key] = $val; if ($const) $this->_isConst[$key] = true; return $this; } public function get($key) { return isset($this->_vars[$key]) ? $this->_vars[$key] : null; } public function instance($class, $new=false, $args=array()) { return $class::i($new, $args); } } class BException extends Exception { public function __construct($message="", $code=0) { parent::__construct($message, $code); } } class BConfig extends BClass { protected $_config = array(); protected $_configToSave = array(); protected $_enableSaving = true; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function add(array $config, $toSave=false) { $this->_config = BUtil::arrayMerge($this->_config, $config); if ($this->_enableSaving && $toSave) { $this->_configToSave = BUtil::arrayMerge($this->_configToSave, $config); } return $this; } public function addFile($filename, $toSave=false) { $ext = strtolower(pathinfo($filename, PATHINFO_EXTENSION)); if (!BUtil::isPathAbsolute($filename)) { $configDir = $this->get('fs/config_dir'); if (!$configDir) { $configDir = BConfig::i()->get('fs/config_dir'); } $filename = $configDir.'/'.$filename; } if (!is_readable($filename)) { BDebug::error(BLocale::_('Invalid configuration file name: %s', $filename)); } switch ($ext) { case 'php': $config = include($filename); break; case 'yml': $config = BYAML::i()->load($filename); break; case 'json': $config = BUtil::fromJson(file_get_contents($filename)); break; } if (!is_array($config)) { BDebug::error(BLocale::_('Invalid configuration contents: %s', $filename)); } $this->add($config, $toSave); return $this; } public function set($path, $value, $merge=false, $toSave=false) { if (is_string($toSave) && $toSave==='_configToSave') { $root =& $this->$toSave; } else { $root =& $this->_config; } foreach (explode('/', $path) as $key) { $root =& $root[$key]; } if ($merge) { $root = (array)$root; $value = (array)$root; $root = BUtil::arrayMerge($root, $value); } else { $root = $value; } if ($this->_enableSaving && true===$toSave) { $this->set($path, $value, $merge, '_configToSave'); } return $this; } public function get($path=null, $toSave=false) { $root = $toSave ? $this->_configToSave : $this->_config; if (is_null($path)) { return $root; } foreach (explode('/', $path) as $key) { if (!isset($root[$key])) { return null; } $root = $root[$key]; } return $root; } public function writeFile($filename, $config=null, $format=null) { if (is_null($config)) { $config = $this->_configToSave; } if (is_null($format)) { $format = pathinfo($filename, PATHINFO_EXTENSION); } switch ($format) { case 'php': $contents = "<?php return ".var_export($config, 1).';'; if ($this->invalidManifestPHP($contents)) { throw new BException('Invalid tokens in configuration found'); } $contents = preg_replace('#=> \n\s+#', '=> ', $contents); break; case 'yml': $contents = BYAML::i()->dump($config); break; case 'json': $contents = BUtil::i()->toJson($config); break; } if (!BUtil::isPathAbsolute($filename)) { $configDir = $this->get('fs/config_dir'); if (!$configDir) { $configDir = BConfig::i()->get('fs/config_dir'); } $filename = $configDir . '/' . $filename; } BUtil::ensureDir(dirname($filename)); if (!file_put_contents($filename, $contents, LOCK_EX)) { BDebug::error('Error writing configuration file: '.$filename); } } public function unsetConfig() { $this->_config = array(); } public function invalidManifestPHP($contents) { $tokens = token_get_all($contents); $allowed = array(T_OPEN_TAG=>1, T_RETURN=>1, T_WHITESPACE=>1, T_COMMENT=>1, T_ARRAY=>1, T_CONSTANT_ENCAPSED_STRING=>1, T_DOUBLE_ARROW=>1, T_DNUMBER=>1, T_LNUMBER=>1, T_STRING=>1, '('=>1, ','=>1, ')'=>1, ';'=>1); $denied = array(); foreach ($tokens as $t) { if (is_string($t) && !isset($t)) { $denied[] = $t; } elseif (is_array($t) && !isset($allowed[$t[0]])) { $denied[] = token_name($t[0]).': '.$t[1] .(!empty($t[2]) ? ' ('.$t[2].')':''); } } if (count($denied)) { return $denied; } return false; } } class BClassRegistry extends BClass { static protected $_instance; protected $_classes = array(); protected $_methods = array(); protected $_methodOverrideCache = array(); protected $_decoratedClasses = array(); protected $_properties = array(); protected $_singletons = array(); public static function i($new=false, array $args=array(), $forceRefresh=false) { if (!static::$_instance) { static::$_instance = new BClassRegistry; } if (!$new && !$forceRefresh) { return static::$_instance; } $class = get_called_class(); return static::$_instance->instance($class, $args, !$new); } public function overrideClass($class, $newClass, $replaceSingleton=false) { $this->_classes[$class] = array( 'class_name' => $newClass, 'module_name' => BModuleRegistry::currentModuleName(), ); BDebug::debug('OVERRIDE CLASS: '.$class.' -> '.$newClass); if ($replaceSingleton && !empty($this->_singletons[$class]) && get_class($this->_singletons[$class])!==$newClass) { $this->_singletons[$class] = $this->instance($newClass); } return $this; } public function addMethod($class, $method, $callback, $static=false) { $arr = explode(' ', $class); if (!empty($arr[1])) { $rel = $arr[0]; $class = $arr[1]; } else { $rel = 'is'; } $this->_methods[$method][$static ? 1 : 0]['override'][$rel][$class] = array( 'module_name' => BModuleRegistry::currentModuleName(), 'callback' => $callback, ); return $this; } public function overrideMethod($class, $method, $callback, $static=false) { $this->addMethod($class, $method, $callback, $static); $this->_decoratedClasses[$class] = true; return $this; } public function augmentMethod($class, $method, $callback, $static=false) { $this->_methods[$method][$static ? 1 : 0]['augment']['is'][$class][] = array( 'module_name' => BModuleRegistry::currentModuleName(), 'callback' => $callback, ); $this->_decoratedClasses[$class] = true; return $this; } public function augmentProperty($class, $property, $op, $type, $callback) { if ($op!=='set' && $op!=='get') { BDebug::error(BLocale::_('Invalid property augmentation operator: %s', $op)); } if ($type!=='override' && $type!=='before' && $type!=='after') { BDebug::error(BLocale::_('Invalid property augmentation type: %s', $type)); } $entry = array( 'module_name' => BModuleRegistry::currentModuleName(), 'callback' => $callback, ); if ($type==='override') { $this->_properties[$class][$property][$op.'_'.$type] = $entry; } else { $this->_properties[$class][$property][$op.'_'.$type][] = $entry; } $this->_decoratedClasses[$class] = true; return $this; } public function findMethodInfo($class, $method, $static=0, $type='override') { if (!empty($this->_methods[$method][$static][$type]['is'][$class])) { return $this->_methods[$method][$static][$type]['is'][$class]; } $cacheKey = $class.'|'.$method.'|'.$static.'|'.$type; if (!empty($this->_methodOverrideCache[$cacheKey])) { return $this->_methodOverrideCache[$cacheKey]; } if (!empty($this->_methods[$method][$static][$type]['extends'])) { $parents = class_parents($class); foreach ($this->_methods[$method][$static][$type]['extends'] as $c=>$v) { if (isset($parents[$c])) { $this->_methodOverrideCache[$cacheKey] = $v; return $v; } } } if (!empty($this->_methods[$method][$static][$type]['implements'])) { $implements = class_implements($class); foreach ($this->_methods[$method][$static][$type]['implements'] as $i=>$v) { if (isset($implements[$i])) { $this->_methodOverrideCache[$cacheKey] = $v; return $v; } } } if (!empty($this->_methods[$method][$static][$type]['is']['*'])) { $v = $this->_methods[$method][$static][$type]['is']['*']; $this->_methodOverrideCache[$cacheKey] = $v; return $v; } return null; } public function isCallable($cb) { if (is_string($cb)) { $cb = explode('::', $cb); if (empty($cb[1])) { $cb = BUtil::extCallback($cb); } } elseif (!is_array($cb)) { return is_callable($cb); } if (empty($cb[1])) { return function_exists($cb[0]); } if (method_exists($cb[0], $cb[1])) { return true; } if (is_object($cb[0])) { if (!$cb[0] instanceof BClass) { return false; } return (bool)$this->findMethodInfo(get_class($cb[0]), $cb[1]); } elseif (is_string($cb[0])) { return (bool)$this->findMethodInfo($cb[0], $cb[1], 1); } else { return false; } } public function callMethod($origObject, $method, array $args=array(), $origClass=null) { $class = get_class($origObject); if (($info = $this->findMethodInfo($class, $method, 0, 'override'))) { $callback = $info['callback']; array_unshift($args, $origObject); $overridden = true; } elseif (method_exists($origObject, $method)) { $callback = array($origObject, $method); $overridden = false; } else { BDebug::error('Invalid method: '.get_class($origObject).'::'.$method); return null; } $result = call_user_func_array($callback, $args); if (($info = $this->findMethodInfo($class, $method, 0, 'augment'))) { if (!$overridden) { array_unshift($args, $origObject); } array_unshift($args, $result); foreach ($info as $augment) { $result = call_user_func_array($augment['callback'], $args); $args[0] = $result; } } return $result; } public function callStaticMethod($class, $method, array $args=array(), $origClass=null) { if (($info = $this->findMethodInfo($class, $method, 1, 'override'))) { $callback = $info['callback']; } else { if (method_exists($class, $method)) { $callback = array($class, $method); } else { throw new Exception('Invalid static method: '.$class.'::'.$method); } } $result = call_user_func_array($callback, $args); if (($info = $this->findMethodInfo($class, $method, 1, 'augment'))) { array_unshift($args, $result); foreach ($info as $augment) { $result = call_user_func_array($augment['callback'], $args); $args[0] = $result; } } return $result; } public function callSetter($origObject, $property, $value) { $class = get_class($origObject); if (!empty($this->_properties[$class][$property]['set_before'])) { foreach ($this->_properties[$class][$property]['set_before'] as $entry) { call_user_func($entry['callback'], $origObject, $property, $value); } } if (!empty($this->_properties[$class][$property]['set_override'])) { $callback = $this->_properties[$class][$property]['set_override']['callback']; call_user_func($callback, $origObject, $property, $value); } else { $origObject->$property = $value; } if (!empty($this->_properties[$class][$property]['set_after'])) { foreach ($this->_properties[$class][$property]['set_after'] as $entry) { call_user_func($entry['callback'], $origObject, $property, $value); } } } public function callGetter($origObject, $property) { $class = get_class($origObject); if (!empty($this->_properties[$class][$property]['get_override'])) { $callback = $this->_properties[$class][$property]['get_override']['callback']; $result = call_user_func($callback, $origObject, $property); } else { $result = $origObject->$property; } if (!empty($this->_properties[$class][$property]['get_after'])) { foreach ($this->_properties[$class][$property]['get_after'] as $entry) { $result = call_user_func($entry['callback'], $origObject, $property, $result); } } return $result; } public function className($class) { return !empty($this->_classes[$class]) ? $this->_classes[$class]['class_name'] : $class; } public function instance($class, array $args=array(), $singleton=false) { if ($singleton && !empty($this->_singletons[$class])) { return $this->_singletons[$class]; } $className = $this->className($class); if (!class_exists($className, true)) { BDebug::error(BLocale::_('Invalid class name: %s', $className)); } $instance = new $className($args); if (!empty($this->_decoratedClasses[$class])) { $instance = $this->instance('BClassDecorator', array($instance)); } if ($singleton) { $this->_singletons[$class] = $instance; } return $instance; } public function unsetInstance() { static::$_instance = null; } } class BClassDecorator { protected $_decoratedComponent; public function __construct($args) { $class = array_shift($args); $this->_decoratedComponent = is_string($class) ? BClassRegistry::i()->instance($class, $args) : $class; } public function __destruct() { $this->_decoratedComponent = null; } public function __call($name, array $args) { return BClassRegistry::i()->callMethod($this->_decoratedComponent, $name, $args); } public static function __callStatic($name, array $args) { return BClassRegistry::i()->callStaticMethod(get_called_class(), $name, $args); } public function __set($name, $value) { BClassRegistry::i()->callSetter($this->_decoratedComponent, $name, $value); } public function __get($name) { return BClassRegistry::i()->callGetter($this->_decoratedComponent, $name); } public function __unset($name) { unset($this->_decoratedComponent->$name); } public function __isset($name) { return isset($this->_decoratedComponent->$name); } public function __toString() { return (string)$this->_decoratedComponent; } public function __sleep() { if (method_exists($this->_decoratedComponent, '__sleep')) { return $this->_decoratedComponent->__sleep(); } return array(); } public function __wakeup() { if (method_exists($this->_decoratedComponent, '__wakeup')) { $this->_decoratedComponent->__wakeup(); } } public function __invoke() { if (is_callable($this->_decoratedComponent)) { return $this->_decoratedComponent(func_get_args()); } return null; } public function getDecoratedComponent() { return $this->_decoratedComponent; } } class BClassAutoload extends BClass { public $root_dir; public $filename_cb; public $module_name; public function __construct($params) { foreach ($params as $k=>$v) { $this->$k = $v; } spl_autoload_register(array($this, 'callback'), false); BDebug::debug('AUTOLOAD: '.print_r($this,1)); } public function callback($class) { if ($this->filename_cb) { $file = call_user_func($this->filename_cb, $class); } else { $file = str_replace(array('_', '\\'), array('/', '/'), $class).'.php'; } if ($file) { if ($file[0]!=='/' && $file[1]!==':') { $file = $this->root_dir.'/'.$file; } if (file_exists($file)) { include ($file); } } } } class BEvents extends BClass { protected $_events = array(); public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function event($eventName, $args=array()) { if (is_array($eventName)) { foreach ($eventName as $event) { $this->event($event[0], !empty($event[1]) ? $event[1] : array()); } return $this; } $eventName = strtolower($eventName); $this->_events[$eventName] = array( 'observers' => array(), 'args' => $args, ); return $this; } public function on($eventName, $callback = null, $args = array(), $alias = null) { if (is_array($eventName)) { foreach ($eventName as $obs) { $this->on($obs[0], $obs[1], !empty($obs[2]) ? $obs[2] : array()); } return $this; } if (is_null($alias) && is_string($callback)) { $alias = $callback; } $observer = array('callback' => $callback, 'args' => $args, 'alias' => $alias); if (($moduleName = BModuleRegistry::currentModuleName())) { $observer['module_name'] = $moduleName; } $eventName = strtolower($eventName); $this->_events[$eventName]['observers'][] = $observer; BDebug::debug('SUBSCRIBE '.$eventName, 1); return $this; } public function once($eventName, $callback=null, $args=array(), $alias = null) { if (is_array($eventName)) { foreach ($eventName as $obs) { $this->once($obs[0], $obs[1], !empty($obs[2]) ? $obs[2] : array()); } return $this; } $this->on($eventName, $callback, $args, $alias); $lastId = sizeof($this->_events[$eventName]['observers']); $this->on($eventName, function() use ($eventName, $lastId) { BEvents::i() ->off($eventName, $lastId-1) ->off($eventName, $lastId) ; }); return $this; } public function off($eventName, $alias = null) { $eventName = strtolower($eventName); if (true === $alias) { unset($this->_events[$eventName]); return $this; } if (is_numeric($alias)) { unset($this->_events[$eventName]['observers'][$alias]); return $this; } if (!empty($this->_events[$eventName]['observers'])) { foreach ($this->_events[$eventName]['observers'] as $i=>$observer) { if (!empty($observer['alias']) && $observer['alias'] === $alias) { unset($this->_events[$eventName]['observers'][$i]); } } } return $this; } public function fire($eventName, $args=array()) { $eventName = strtolower($eventName); $profileStart = BDebug::debug('FIRE '.$eventName.(empty($this->_events[$eventName])?' (NO SUBSCRIBERS)':''), 1); $result = array(); if (empty($this->_events[$eventName])) { return $result; } $observers =& $this->_events[$eventName]['observers']; do { $dirty = false; foreach ($observers as $i=>$observer) { if (!empty($observer['args']['position']) && empty($observer['ordered'])) { unset($observers[$i]); $observer['ordered'] = true; $observers = BUtil::arrayInsert($observers, $observer, $observer['position']); $dirty = true; break; } } } while ($dirty); foreach ($observers as $i=>$observer) { if (!empty($this->_events[$eventName]['args'])) { $args = array_merge($this->_events[$eventName]['args'], $args); } if (!empty($observer['args'])) { $args = array_merge($observer['args'], $args); } if (!empty($observer['module_name'])) { BModuleRegistry::i()->pushModule($observer['module_name']); } $cb = $observer['callback']; if (is_object($cb) && !$cb instanceof Closure) { if (method_exists($cb, 'set')) { $cb->set($args); } $result[] = (string)$cb; continue; } if (is_string($cb)) { foreach (array('.', '->') as $sep) { $r = explode($sep, $cb); if (sizeof($r)==2) { if (!class_exists($r[0])) { echo "<pre>"; debug_print_backtrace(); echo "</pre>"; } $cb = array($r[0]::i(), $r[1]); $observer['callback'] = $cb; $observers[$i]['callback'] = $cb; break; } } } if (is_callable($cb)) { BDebug::debug('ON '.$eventName, 1); $result[] = call_user_func($cb, $args); } else { BDebug::warning('Invalid callback: '.var_export($cb, 1), 1); } if (!empty($observer['module_name'])) { BModuleRegistry::i()->popModule(); } } BDebug::profile($profileStart); return $result; } public function fireRegex($eventRegex, $args) { $results = array(); foreach ($this->_events as $eventName => $event) { if (preg_match($eventRegex, $eventName)) { $results += (array)$this->fire($eventName, $args); } } return $results; } public function debug() { echo "<pre>"; print_r($this->_events); echo "</pre>"; } } class BPubSub extends BEvents {} class BSession extends BClass { public $data = null; protected $_sessionId; protected $_phpSessionOpen = false; protected $_dirty = false; protected $_availableHandlers = array(); protected $_defaultSessionCookieName = 'buckyball'; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function addHandler($name, $class) { $this->_availableHandlers[$name] = $class; } public function getHandlers() { $handlers = array_keys($this->_availableHandlers); return array_combine($handlers, $handlers); } public function open($id=null, $autoClose=false) { if (!is_null($this->data)) { return $this; } $config = BConfig::i()->get('cookie'); if (!empty($config['session_disable'])) { return $this; } $ttl = !empty($config['timeout']) ? $config['timeout'] : 3600; $path = !empty($config['path']) ? $config['path'] : BConfig::i()->get('web/base_href'); if (empty($path)) $path = BRequest::i()->webRoot(); $domain = !empty($config['domain']) ? $config['domain'] : BRequest::i()->httpHost(false); if (!empty($config['session_handler']) && !empty($this->_availableHandlers[$config['session_handler']])) { $class = $this->_availableHandlers[$config['session_handler']]; $class::i()->register($ttl); } session_name(!empty($config['name']) ? $config['name'] : $this->_defaultSessionCookieName); if (($dir = BConfig::i()->get('fs/storage_dir'))) { $dir .= '/session'; BUtil::ensureDir($dir); session_save_path($dir); } if (!empty($id) || ($id = BRequest::i()->get('SID'))) { session_id($id); } if (headers_sent()) { BDebug::warning("Headers already sent, can't start session"); } else { session_set_cookie_params($ttl, $path, $domain); session_start(); setcookie(session_name(), session_id(), time()+$ttl, $path, $domain); } $this->_phpSessionOpen = true; $this->_sessionId = session_id(); if (!empty($config['session_check_ip'])) { $ip = BRequest::i()->ip(); if (empty($_SESSION['_ip'])) { $_SESSION['_ip'] = $ip; } elseif ($_SESSION['_ip']!==$ip) { session_destroy(); session_start(); } } $namespace = !empty($config['session_namespace']) ? $config['session_namespace'] : 'default'; if (empty($_SESSION[$namespace])) { $_SESSION[$namespace] = array(); } if ($autoClose) { $this->data = $_SESSION[$namespace]; } else { $this->data =& $_SESSION[$namespace]; } if (empty($this->data['_language'])) { $lang = BRequest::language(); if (!empty($lang)) { $this->data['_language'] = $lang; } } $this->data['_locale'] = BConfig::i()->get('locale'); if (!empty($this->data['_locale'])) { if (is_array($this->data['_locale'])) { foreach ($this->data['_locale'] as $c=>$l) { setlocale($c, $l); } } elseif (is_string($this->data['_locale'])) { setlocale(LC_ALL, $this->data['_locale']); } } else { setLocale(LC_ALL, 'en_US.UTF-8'); } if (!empty($this->data['_timezone'])) { date_default_timezone_set($this->data['_timezone']); } if ($autoClose) { session_write_close(); $this->_phpSessionOpen = false; } BDebug::debug(__METHOD__.': '.spl_object_hash($this)); return $this; } public function dirty($flag=null) { if (is_null($flag)) { return $this->_dirty; } BDebug::debug('SESSION.DIRTY '.($flag?'TRUE':'FALSE'), 2); $this->_dirty = $flag; return $this; } public function isDirty() { return $this->_dirty; } public function setDirty($flag=true) { BDebug::debug('SESSION.DIRTY '.($flag?'TRUE':'FALSE'), 2); $this->_dirty = $flag; return $this; } public function data($key=null, $value=BNULL) { if (is_null($key)) { return $this->data; } if (is_array($key)) { foreach ($key as $k=>$v) { $this->data($k, $v); } return $this; } if (BNULL===$value) { return isset($this->data[$key]) ? $this->data[$key] : null; } if (!isset($this->data[$key]) || $this->data[$key]!==$value) { $this->dirty(true); } $this->data[$key] = $value; return $this; } public function get($key) { return isset($this->data[$key]) ? $this->data[$key] : null; } public function set($key, $value) { if (!isset($this->data[$key]) || $this->data[$key]!==$value) { $this->setDirty(); } $this->data[$key] = $value; return $this; } public function pop($key) { $data = $this->get($key); $this->set($key, null); return $data; } public function &dataToUpdate() { $this->setDirty(); return $this->data; } public function close() { if (!$this->_dirty || !empty($_SESSION)) { return; } BDebug::debug(__METHOD__.': '.spl_object_hash($this)); if (!$this->_phpSessionOpen) { if (headers_sent()) { BDebug::warning("Headers already sent, can't start session"); } else { session_start(); } $namespace = BConfig::i()->get('cookie/session_namespace'); if (!$namespace) $namespace = 'default'; $_SESSION[$namespace] = $this->data; } BDebug::debug(__METHOD__, 1); session_write_close(); $this->_phpSessionOpen = false; return $this; } public function destroy() { session_destroy(); } public function sessionId() { return $this->_sessionId; } public function addMessage($msg, $type='info', $tag='_') { $this->setDirty(); $this->data['_messages'][$tag][] = array('msg'=>$msg, 'type'=>$type); return $this; } public function messages($tags='_') { if (empty($this->data['_messages'])) { return array(); } $tags = explode(',', $tags); $msgs = array(); foreach ($tags as $tag) { if (empty($this->data['_messages'][$tag])) { continue; } foreach ($this->data['_messages'][$tag] as $i=>$m) { $msgs[] = $m; unset($this->data['_messages'][$tag][$i]); $this->setDirty(); } } return $msgs; } public function csrfToken() { $data =& static::dataToUpdate(); if (empty($data['_csrf_token'])) { $data['_csrf_token'] = BUtil::randomString(32); } return $data['_csrf_token']; } public function __destruct() { } } class BSession_APC extends BClass { protected $_prefix; protected $_ttl = 0; protected $_lockTimeout = 10; public function __construct() { if (function_exists('apc_store')) { BSession::i()->addHandler('apc', __CLASS__); } } public function register($ttl=null) { if ($ttl) { $this->_ttl = $ttl; } session_set_save_handler( array($this, 'open'), array($this, 'close'), array($this, 'read'), array($this, 'write'), array($this, 'destroy'), array($this, 'gc') ); } public function open($savePath, $sessionName) { $this->_prefix = 'BSession/'.$sessionName; if (!apc_exists($this->_prefix.'/TS')) { apc_store($this->_prefix.'/TS', array('')); apc_store($this->_prefix.'/LOCK', array('')); } return true; } public function close() { return true; } public function read($id) { $key = $this->_prefix.'/'.$id; if (!apc_exists($key)) { return ''; } if ($this->_ttl) { $ts = apc_fetch($this->_prefix.'/TS'); if (empty($ts[$id])) { return ''; } elseif (!empty($ts[$id]) && $ts[$id] + $this->_ttl < time()) { unset($ts[$id]); apc_delete($key); apc_store($this->_prefix.'/TS', $ts); return ''; } } if ($this->_lockTimeout) { $locks = apc_fetch($this->_prefix.'/LOCK'); if (!empty($locks[$id])) { while (!empty($locks[$id]) && $locks[$id] + $this->_lockTimeout >= time()) { usleep(10000); $locks = apc_fetch($this->_prefix.'/LOCK'); } } $locks[$id] = time(); apc_store($this->_prefix.'/LOCK', $locks); } return apc_fetch($key); } public function write($id, $data) { $ts = apc_fetch($this->_prefix.'/TS'); $ts[$id] = time(); apc_store($this->_prefix.'/TS', $ts); $locks = apc_fetch($this->_prefix.'/LOCK'); unset($locks[$id]); apc_store($this->_prefix.'/LOCK', $locks); return apc_store($this->_prefix.'/'.$id, $data, $this->_ttl); } public function destroy($id) { $ts = apc_fetch($this->_prefix.'/TS'); unset($ts[$id]); apc_store($this->_prefix.'/TS', $ts); $locks = apc_fetch($this->_prefix.'/LOCK'); unset($locks[$id]); apc_store($this->_prefix.'/LOCK', $locks); return apc_delete($this->_prefix.'/'.$id); } public function gc($lifetime) { if ($this->_ttl) { $lifetime = min($lifetime, $this->_ttl); } $ts = apc_fetch($this->_prefix.'/TS'); foreach ($ts as $id=>$time) { if ($time + $lifetime < time()) { apc_delete($this->_prefix.'/'.$id); unset($ts[$id]); } } return apc_store($this->_prefix.'/TS', $ts); } } BSession_APC::i();  class BUtil extends BClass { protected static $_mcryptIV; protected static $_mcryptKey; protected static $_hashAlgo = 'bcrypt'; protected static $_hashIter = 3; protected static $_hashSep = '$'; protected static $_defaultCharPool = '23456789abdefghijklmnopqrstuvwxyzABDEFGHJKLMNOPQRSTUVWXYZ'; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public static function toJson($data) { if (is_array($data) && is_object(current($data)) && current($data) instanceof BModel) { $data = BDb::many_as_array($data); } elseif (is_object($data) && $data instanceof BData) { $data = $data->as_array(true); } return json_encode($data); } public static function fromJson($json, $asObject=false) { $obj = json_decode($json); return $asObject ? $obj : static::objectToArray($obj); } public static function jsonIndent($json) { $result = ''; $pos = 0; $strLen = strlen($json); $indentStr = '  '; $newLine = "\n"; $prevChar = ''; $outOfQuotes = true; for ($i=0; $i<=$strLen; $i++) { $char = substr($json, $i, 1); if ($char == '"' && $prevChar != '\\') { $outOfQuotes = !$outOfQuotes; } else if(($char == '}' || $char == ']') && $outOfQuotes) { $result .= $newLine; $pos --; for ($j=0; $j<$pos; $j++) { $result .= $indentStr; } } $result .= $char; if (($char == ',' || $char == '{' || $char == '[') && $outOfQuotes) { $result .= $newLine; if ($char == '{' || $char == '[') { $pos ++; } for ($j = 0; $j < $pos; $j++) { $result .= $indentStr; } } $prevChar = $char; } return $result; } public static function toJavaScript($val) { if (is_null($val)) { return 'null'; } elseif (is_bool($val)) { return $val ? 'true' : 'false'; } elseif (is_string($val)) { if (preg_match('#^\s*function\s*\(#', $val)) { return $val; } else { return "'".addslashes($val)."'"; } } elseif (is_int($val) || is_float($val)) { return $val; } elseif ($val instanceof BValue) { return $val->toPlain(); } elseif (($isObj = is_object($val)) || is_array($val)) { $out = array(); if (!empty($val) && ($isObj || array_keys($val) !== range(0, count($val)-1))) { foreach ($val as $k=>$v) { $out[] = "'".addslashes($k)."':".static::toJavaScript($v); } return '{'.join(',', $out).'}'; } else { foreach ($val as $k=>$v) { $out[] = static::toJavaScript($v); } return '['.join(',', $out).']'; } } return '"UNSUPPORTED TYPE"'; } public static function toRss($data) { $lang = !empty($data['language']) ? $data['language'] : 'en-us'; $ttl = !empty($data['ttl']) ? (int)$data['ttl'] : 40; $descr = !empty($data['description']) ? $data['description'] : $data['title']; $xml = '<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"><channel>' .'<title><![CDATA['.$data['title'].']]></title><link><![CDATA['.$data['link'].']]></link>' .'<description><![CDATA['.$descr.']]></description><language><![CDATA['.$lang.']]></language><ttl>'.$ttl.'</ttl>'; foreach ($data['items'] as $item) { if (!is_numeric($item['pubDate'])) { $item['pubDate'] = strtotime($item['pubDate']); } if (empty($item['guid'])) { $item['guid'] = $item['link']; } $xml .= '<item><title><![CDATA['.$item['title'].']]></title>' .'<description><![CDATA['.$item['description'].']]></description>' .'<pubDate>'.date('r', $item['pubDate']).'</pubDate>' .'<guid><![CDATA['.$item['guid'].']]></guid><link><![CDATA['.$item['link'].']]></link></item>'; } $xml .= '</channel></rss>'; return $xml; } public static function objectToArray($d) { if (is_object($d)) { $d = get_object_vars($d); } if (is_array($d)) { return array_map('BUtil::objectToArray', $d); } return $d; } public static function arrayToObject($d) { if (is_array($d)) { return (object) array_map('BUtil::objectToArray', $d); } return $d; } public static function sprintfn($format, $args = array()) { $args = (array)$args; $arg_nums = array_slice(array_flip(array_keys(array(0 => 0) + $args)), 1); for ($pos = 0; preg_match('/(?<=%)([a-zA-Z_]\w*)(?=\$)/', $format, $match, PREG_OFFSET_CAPTURE, $pos);) { $arg_pos = $match[0][1]; $arg_len = strlen($match[0][0]); $arg_key = $match[1][0]; if (! array_key_exists($arg_key, $arg_nums)) { user_error("sprintfn(): Missing argument '${arg_key}'", E_USER_WARNING); return false; } $format = substr_replace($format, $replace = $arg_nums[$arg_key], $arg_pos, $arg_len); $pos = $arg_pos + strlen($replace); } if (!$args) { $args = array(''); } return vsprintf($format, array_values($args)); } public static function injectVars($str, $vars) { $from = array(); $to = array(); foreach ($vars as $k=>$v) { $from[] = ':'.$k; $to[] = $v; } return str_replace($from, $to, $str); } public static function arrayMerge() { $arrays = func_get_args(); $base = array_shift($arrays); if (!is_array($base)) { $base = empty($base) ? array() : array($base); } foreach ($arrays as $append) { if (!is_array($append)) { $append = array($append); } foreach ($append as $key => $value) { if (is_numeric($key)) { if (!in_array($value, $base)) { $base[] = $value; } } elseif (!array_key_exists($key, $base)) { $base[$key] = $value; } elseif (is_array($value) && is_array($base[$key])) { $base[$key] = static::arrayMerge($base[$key], $append[$key]); } else { $base[$key] = $value; } } } return $base; } public static function arrayCompare(array $array1, array $array2) { $diff = false; foreach ($array1 as $key => $value) { if (!array_key_exists($key,$array2)) { $diff[0][$key] = $value; } elseif (is_array($value)) { if (!is_array($array2[$key])) { $diff[0][$key] = $value; $diff[1][$key] = $array2[$key]; } else { $new = static::arrayCompare($value, $array2[$key]); if ($new !== false) { if (isset($new[0])) $diff[0][$key] = $new[0]; if (isset($new[1])) $diff[1][$key] = $new[1]; } } } elseif ($array2[$key] !== $value) { $diff[0][$key] = $value; $diff[1][$key] = $array2[$key]; } } foreach ($array2 as $key => $value) { if (!array_key_exists($key,$array1)) { $diff[1][$key] = $value; } } return $diff; } static public function arrayWalk($arr, $cb, $args=array(), $ignoreExceptions=false) { $result = array(); foreach ($arr as $i=>$r) { $callback = is_string($cb) && $cb[0]==='.' ? array($r, substr($cb, 1)) : $cb; if ($ignoreExceptions) { try { $result[] = call_user_func_array($callback, $args); } catch (Exception $e) { BDebug::warning('EXCEPTION class('.get_class($r).') arrayWalk('.$i.'): '.$e->getMessage()); } } else { $result[] = call_user_func_array($callback, $args); } } return $result; } static public function arrayCleanInt($arr) { $res = array(); if (is_string($arr)) { $arr = explode(',', $arr); } if (is_array($arr)) { foreach ($arr as $k=>$v) { if (is_numeric($v)) { $res[$k] = intval($v); } } } return $res; } static public function arrayInsert($array, $items, $where) { $result = array(); $w1 = explode('==', $where, 2); $w2 = explode('.', $w1[0], 3); switch ($w2[0]) { case 'start': $result = array_merge($items, $array); break; case 'end': $result = array_merge($array, $items); break; case 'offset': $key = $w1[1]; $i = 0; foreach ($array as $k=>$v) { if ($key===$i++) { foreach ($items as $k1=>$v1) { $result[$k1] = $v1; } } $result[$k] = $v; } break; case 'key': $rel = $w2[1]; $key = $w1[1]; foreach ($array as $k=>$v) { if ($key===$k) { if ($rel==='after') { $result[$k] = $v; } foreach ($items as $k1=>$v1) { $result[$k1] = $v1; } if ($rel==='before') { $result[$k] = $v; } } else { $result[$k] = $v; } } break; case 'obj': $rel = $w2[1]; $f = $w2[2]; $key = $w1[1]; foreach ($array as $k=>$v) { if ($key===$v->$f) { if ($rel==='after') { $result[$k] = $v; } foreach ($items as $k1=>$v1) { $result[$k1] = $v1; } if ($rel==='before') { $result[$k] = $v; } } else { $result[$k] = $v; } } break; case 'arr': $rel = $w2[1]; $f = $w2[2]; $key = $w1[1]; foreach ($array as $k=>$v) { if ($key===$v[$f]) { if ($rel==='after') { $result[$k] = $v; } foreach ($items as $k1=>$v1) { $result[$k1] = $v1; } if ($rel==='before') { $result[$k] = $v; } } else { $result[$k] = $v; } } break; default: BDebug::error('Invalid where condition: '.$where); } return $result; } static public function arrayMask(array $source, $fields, $inverse=false, $setNulls=true) { if (is_string($fields)) { $fields = explode(',', $fields); array_walk($fields, 'trim'); } $result = array(); if (!$inverse) { foreach ($fields as $k) { if (isset($source[$k])) { $result[$k] = $source[$k]; } elseif ($setNulls) { $result[$k] = null; } } } else { foreach ($source as $k=>$v) { if (!in_array($k, $fields)) $result[$k] = $v; } } return $result; } static public function arrayToOptions($source, $labelField, $keyField=null, $emptyLabel=null) { $options = array(); if (!is_null($emptyLabel)) { $options = array("" => $emptyLabel); } if (empty($source)) { return array(); } $isObject = is_object(current($source)); foreach ($source as $k=>$item) { if ($isObject) { $key = is_null($keyField) ? $k : $item->$keyField; $label = $labelField[0]==='.' ? $item->{substr($labelField, 1)}() : $item->labelField; $options[$key] = $label; } else { $key = is_null($keyField) ? $k : $item[$keyField]; $options[$key] = $item[$labelField]; } } return $options; } static public function mcryptIV() { if (!static::$_mcryptIV) { static::$_mcryptIV = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_DEV_URANDOM); } return static::$_mcryptIV; } static public function mcryptKey($key=null, $configPath=null) { if (!is_null($key)) { static::$_mcryptKey = $key; } elseif (is_null(static::$_mcryptKey) && $configPath) { static::$_mcryptKey = BConfig::i()->get($configPath); } return static::$_mcryptKey; } static public function encrypt($value, $key=null, $base64=true) { if (is_null($key)) $key = static::mcryptKey(); $enc = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $value, MCRYPT_MODE_ECB, static::mcryptIV()); return $base64 ? trim(base64_encode($enc)) : $enc; } static public function decrypt($value, $key=null, $base64=true) { if (is_null($key)) $key = static::mcryptKey(); $enc = $base64 ? base64_decode($value) : $value; return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, $enc, MCRYPT_MODE_ECB, static::mcryptIV())); } public static function randomString($strLen=8, $chars=null) { if (is_null($chars)) { $chars = static::$_defaultCharPool; } $charsLen = strlen($chars)-1; $str = ''; for ($i=0; $i<$strLen; $i++) { $str .= $chars[mt_rand(0, $charsLen)]; } return $str; } public static function randomPattern($pattern) { static $chars = array('L'=>'bcdfghjkmnpqrstvwxyz', 'U'=>'BCDFGHJKLMNPQRSTVWXYZ', 'D'=>'123456789'); while (preg_match('#\{([ULD]+)([0-9]+)\}#i', $pattern, $m)) { for ($i=0, $c=''; $i<strlen($m[1]); $i++) $c .= $chars[$m[1][$i]]; $pattern = preg_replace('#'.preg_quote($m[0]).'#', BUtil::randomString($m[2], $c), $pattern, 1); } return $pattern; } public static function nextStringValue($string='', $chars=null) { if (is_null($chars)) { $chars = static::$_defaultCharPool; } $pos = strlen($string); $lastChar = substr($chars, -1); while (--$pos>=-1) { if ($pos==-1) { $string = $chars[0].$string; return $string; } elseif ($string[$pos]===$lastChar) { $string[$pos] = $chars[0]; continue; } else { $string[$pos] = $chars[strpos($chars, $string[$pos])+1]; return $string; } } return $string; } public static function hashAlgo($algo=null) { if (is_null($algo)) { return static::$_hashAlgo; } static::$_hashAlgo = $algo; } public static function hashIter($iter=null) { if (is_null($iter)) { return static::$_hashIter; } static::$iter = $iter; } public static function saltedHash($string, $salt, $algo=null) { $algo = !is_null($algo) ? $algo : static::$_hashAlgo; return hash($algo, $salt.$string); } public static function fullSaltedHash($string, $salt=null, $algo=null, $iter=null) { $algo = !is_null($algo) ? $algo : static::$_hashAlgo; if ('bcrypt'===$algo) { return Bcrypt::i()->hash($string); } $iter = !is_null($iter) ? $iter : static::$_hashIter; $s = static::$_hashSep; $hash = $s.$algo.$s.$iter; for ($i=0; $i<$iter; $i++) { $salt1 = !is_null($salt) ? $salt : static::randomString(); $hash .= $s.$salt1; $string = static::saltedHash($string, $salt1, $algo); } return $hash.$s.$string; } public static function validateSaltedHash($string, $storedHash) { if (strpos($storedHash, '$2a$')===0 || strpos($storedHash, '$2y$')===0) { return Bcrypt::i()->verify($string, $storedHash); } if (!$storedHash) { return false; } $sep = $storedHash[0]; $arr = explode($sep, $storedHash); array_shift($arr); $algo = array_shift($arr); $iter = array_shift($arr); $verifyHash = $string; for ($i=0; $i<$iter; $i++) { $salt = array_shift($arr); $verifyHash = static::saltedHash($verifyHash, $salt, $algo); } $knownHash = array_shift($arr); return $verifyHash===$knownHash; } public static function sha512base64($str) { return base64_encode(pack('H*', hash('sha512', $str))); } public static function remoteHttp($method, $url, $data=array()) { $request = is_array($data) ? http_build_query($data) : $data; $timeout = 5; $userAgent = 'Mozilla/5.0'; if ($method==='GET' && $data) { $url .= (strpos($url, '?')===false ? '?' : '&').$request; } if (function_exists('curl_init')) { $curlOpt = array( CURLOPT_USERAGENT => $userAgent, CURLOPT_URL => $url, CURLOPT_ENCODING => '', CURLOPT_RETURNTRANSFER => true, CURLOPT_AUTOREFERER => true, CURLOPT_SSL_VERIFYPEER => false, CURLOPT_SSL_VERIFYHOST => false, CURLOPT_CONNECTTIMEOUT => $timeout, CURLOPT_TIMEOUT => $timeout, CURLOPT_MAXREDIRS => 10, CURLOPT_HTTPHEADER, array('Expect:'), ); if (false) { $cookieDir = BConfig::i()->get('fs/storage_dir').'/cache'; BUtil::ensureDir($cookieDir); $cookie = tempnam($cookieDir, 'CURLCOOKIE'); $curlOpt += array( CURLOPT_COOKIEJAR => $cookie, CURLOPT_FOLLOWLOCATION => true, ); } if ($method==='POST') { $curlOpt += array( CURLOPT_POSTFIELDS => $request, CURLOPT_POST => 1, ); } elseif ($method==='PUT') { $curlOpt += array( CURLOPT_POSTFIELDS => $request, CURLOPT_PUT => 1, ); } $ch = curl_init(); curl_setopt_array($ch, $curlOpt); $content = curl_exec($ch); $response = curl_getinfo($ch); curl_close($ch); } else { $opts = array('http' => array( 'method' => $method, 'timeout' => $timeout, 'header' => "User-Agent: {$userAgent}\r\n", )); if ($method==='POST' || $method==='PUT') { $opts['http']['content'] = $request; $contentType = 'application/x-www-form-urlencoded'; foreach ($request as $k=>$v) { if (is_string($v) && $v[0]==='@') { $contentType = 'multipart/form-data'; break; } } $opts['http']['header'] .= "Content-Type: {$contentType}\r\n" ."Content-Length: ".strlen($request)."\r\n"; } $content = file_get_contents($url, false, stream_context_create($opts)); $response = array(); } return array($content, $response); } public static function post($url, $data) { list($content) = static::remoteHttp('POST', $url, $data); parse_str($content, $response); return $response; } public static function httpClient($method, $url, $data) { $method = strtoupper($method); list($content) = static::remoteHttp($method, $url, $data); parse_str($content, $response); return $response; } public static function normalizePath($path) { $path = str_replace('\\', '/', $path); if (strpos($path, '/..')!==false) { $a = explode('/', $path); $b = array(); foreach ($a as $p) { if ($p==='..') array_pop($b); else $b[] = $p; } $path = join('/', $b); } return $path; } public static function globRecursive($pattern, $flags=0) { $files = glob($pattern, $flags); if (!$files) $files = array(); $dirs = glob(dirname($pattern).'/*', GLOB_ONLYDIR|GLOB_NOSORT); if ($dirs) { foreach ($dirs as $dir) { $files = array_merge($files, self::globRecursive($dir.'/'.basename($pattern), $flags)); } } return $files; } public static function isPathAbsolute($path) { return !empty($path) && ($path[0]==='/' || $path[0]==='\\') || !empty($path[1]) && $path[1]===':'; } public static function isUrlFull($url) { return preg_match('#^(https?:)?//#', $url); } public static function ensureDir($dir) { if (is_file($dir)) { BDebug::warning($dir.' is a file, directory required'); return; } if (!is_dir($dir)) { @$res = mkdir($dir, 0777, true); if (!$res) { BDebug::warning("Can't create directory: ".$dir); } } } public static function unparseUrl($p) { $scheme = isset($p['scheme']) ? $p['scheme'] . '://' : ''; $user = isset($p['user']) ? $p['user'] : ''; $pass = isset($p['pass']) ? ':' . $p['pass'] : ''; $pass = ($user || $pass) ? $pass . '@' : ''; $host = isset($p['host']) ? $p['host'] : ''; $port = isset($p['port']) ? ':' . $p['port'] : ''; $path = isset($p['path']) ? $p['path'] : ''; $query = isset($p['query']) ? '?' . $p['query'] : ''; $fragment = isset($p['fragment']) ? '#' . $p['fragment'] : ''; return $scheme.$user.$pass.$host.$port.$path.$query.$fragment; } public static function setUrlQuery($url, $params) { if (true === $url) { $url = BRequest::currentUrl(); } $parsed = parse_url($url); $query = array(); if (!empty($parsed['query'])) { foreach (explode('&', $parsed['query']) as $q) { $a = explode('=', $q); if ($a[0]==='') { continue; } $a[0] = urldecode($a[0]); $query[$a[0]] = urldecode($a[1]); } } foreach($params as $k => $v){ if($v === ""){ if(isset($query[$k])){ unset($query[$k]); } unset($params[$k]); } } $query = array_merge($query, $params); $parsed['query'] = http_build_query($query); return static::unparseUrl($parsed); } public static function paginateSortUrl($url, $state, $field) { return static::setUrlQuery($url, array( 's'=>$field, 'sd'=>$state['s']!=$field || $state['sd']=='desc' ? 'asc' : 'desc', )); } public static function paginateSortAttr($url, $state, $field, $class='') { return 'href="'.static::paginateSortUrl($url, $state, $field) .'" class="'.$class.' '.($state['s']==$field ? $state['sd'] : '').'"'; } public static function tagHtml($tag, $attrs = array(), $content = null) { $attrsHtmlArr = array(); foreach ($attrs as $k => $v) { if ('' === $v || is_null($v) || false === $v) { continue; } if (true === $v) { $v = $k; } elseif (is_array($v)) { switch ($k) { case 'class': $v = join(' ', $v); break; case 'style': $attrHtmlArr = array(); foreach ($v as $k1 => $v1) { $attrHtmlArr[] = $k1.':'.$v1; } $v = join('; ', $attrHtmlArr); break; default: $v = join('', $v); } } $attrsHtmlArr[] = $k.'="'.htmlspecialchars($v, ENT_QUOTES, 'UTF-8').'"'; } return '<'.$tag.' '.join(' ', $attrsHtmlArr).'>'.$content.'</'.$tag.'>'; } public static function optionsHtml($options, $default = '') { if(!is_array($default)){ $default = (string)$default; } $htmlArr = array(); foreach ($options as $k => $v) { $k = (string)$k; if (is_array($v) && $k!=='' && $k[0] === '@') { $label = trim(substr($k, 1)); $htmlArr[] = BUtil::tagHtml('optgroup', array('label' => $label), static::optionsHtml($v, $default)); continue; } if (is_array($v)) { $attr = $v; $v = !empty($attr['text']) ? $attr['text'] : ''; unset($attr['text']); } else { $attr = array(); } $attr['value'] = $k; $attr['selected'] = is_array($default) && in_array($k, $default) || $default === $k; $htmlArr[] = BUtil::tagHtml('option', $attr, $v); } return join("\n", $htmlArr); } public static function previewText($text, $limit) { $text = strip_tags($text); if (strlen($text) < $limit) { return $text; } preg_match('/^(.{1,'.$limit.'})\b/', $text, $matches); return $matches[1]; } public static function isEmptyDate($date) { return preg_replace('#[0 :-]#', '', (string)$date)===''; } public static function gravatar($email, $params=array()) { if (empty($params['default'])) { $params['default'] = 'identicon'; } return BRequest::i()->scheme().'://www.gravatar.com/avatar/'.md5(strtolower($email)) .($params ? '?'.http_build_query($params) : ''); } public static function extCallback($callback) { if (is_string($callback)) { if (strpos($callback, '.')!==false) { list($class, $method) = explode('.', $callback); } elseif (strpos($callback, '->')) { list($class, $method) = explode('->', $callback); } if (!empty($class)) { $callback = array($class::i(), $method); } } return $callback; } public static function call($callback, $args=array(), $array=false) { $callback = static::extCallback($callback); if ($array) { return call_user_func_array($callback, $args); } else { return call_user_func($callback, $args); } } public static function formatDateRecursive($source, $format='m/d/Y') { foreach ($source as $i=>$val) { if (is_string($val)) { if (preg_match('#^[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]( |$)#', $val)) { $source[$i] = date($format, strtotime($val)); } } elseif (is_array($val)) { $source[$i] = static::formatDateRecursive($val, $format); } } return $source; } public static function timeAgo($ptime, $now=null, $long=false) { if (!is_numeric($ptime)) { $ptime = strtotime($ptime); } if (!$now) { $now = time(); } elseif (!is_numeric($now)) { $now = strtotime($now); } $etime = $now - $ptime; if ($etime < 1) { return $long ? 'less than 1 second' : '0s'; } $a = array( 12 * 30 * 24 * 60 * 60 => array('year', 'y'), 30 * 24 * 60 * 60 => array('month', 'mon'), 24 * 60 * 60 => array('day', 'd'), 60 * 60 => array('hour', 'h'), 60 => array('minute', 'm'), 1 => array('second', 's'), ); foreach ($a as $secs => $sa) { $d = $etime / $secs; if ($d >= 1) { $r = round($d); return $r . ($long ? ' ' . $sa[0] . ($r > 1 ? 's' : '') : $sa[1]); } } } static public function simplifyString($str, $pattern='#[^a-z0-9-]+#', $filler='-') { return trim(preg_replace($pattern, $filler, strtolower($str)), $filler); } static public function topoSort(array $array, array $args=array()) { if (empty($array)) { return array(); } $beforeVar = !empty($args['before']) ? $args['before'] : 'before'; $afterVar = !empty($args['before']) ? $args['after'] : 'after'; $isObject = is_object(current($array)); $nodes = array(); foreach ($array as $k=>$v) { $before = $isObject ? $v->$beforeVar : $v[$beforeVar]; if (is_string($before)) { $before = array_walk(explode(',', $before), 'trim'); } $after = $isObject ? $v->$afterVar : $v[$afterVar]; if (is_string($after)) { $after = array_walk(explode(',', $after), 'trim'); } $nodes[$k] = array('key' => $k, 'item' => $v, 'parents' => (array)$after, 'children' => (array)$before); } $rootNodes = array(); foreach ($nodes as $k=>$node) { if (empty($node['parents'])) { $rootNodes[] = $node; } } $sorted = array(); while ($nodes) { if (!$rootNodes) return false; $n = array_pop($rootNodes); $sorted[$n['key']] = $n['item']; for ($i = count($n['children'])-1; $i>=0; $i--) { $childNode = $nodes[$n['children'][$i]]; unset($n['children'][$i]); unset($childNode['parents'][array_search($n['name'], $childNode['parents'])]); if (!$childNode['parents']) { array_push($rootNodes, $childNode); } } unset($nodes[$n['key']]); } return $sorted; } } class BHTML extends BClass { } class BEmail extends BClass { static protected $_handlers = array(); static protected $_defaultHandler = 'default'; public function __construct() { $this->addHandler('default', array($this, 'defaultHandler')); } public function addHandler($name, $params) { if (is_callable($params)) { $params = array( 'description' => $name, 'callback' => $params, ); } static::$_handlers[$name] = $params; } public function getHandlers() { return static::$_handlers; } public function setDefaultHandler($name) { static::$_defaultHandler = $name; } public function send($data) { static $allowedHeadersRegex = '/^(to|from|cc|bcc|reply-to|return-path|content-type|x-.*)$/'; $data = array_change_key_case($data, CASE_LOWER); $body = trim($data['body']); unset($data['body']); $to = ''; $subject = ''; $headers = array(); $params = array(); $files = array(); foreach ($data as $k => $v) { if ($k == 'subject') { $subject = $v; } elseif ($k == 'to') { $to = $v; } elseif ($k == 'attach') { foreach ((array)$v as $file) { $files[] = $file; } } elseif ($k[0] === '-') { $params[$k] = $k . ' ' . $v; } elseif (preg_match($allowedHeadersRegex, $k)) { if (!empty($v) && $v!=='"" <>') { $headers[$k] = $k . ': ' . $v; } } } $origBody = $body; if ($files) { $this->_addAttachment($files, $headers, $body); } $emailData = array( 'to' => &$to, 'subject' => &$subject, 'orig_body' => &$origBody, 'body' => &$body, 'headers' => &$headers, 'params' => &$params, 'files' => &$files, 'orig_data' => $data, ); return $this->_dispatch($emailData); } protected function _dispatch($emailData) { try { $flags = BEvents::i()->fire('BEmail::send:before', array('email_data' => $emailData)); if ($flags===false) { return false; } elseif (is_array($flags)) { foreach ($flags as $f) { if ($f===false) { return false; } } } } catch (BException $e) { BDebug::warning($e->getMessage()); return false; } $callback = static::$_handlers[static::$_defaultHandler]['callback']; if (is_callable($callback)) { $result = call_user_func($callback, $emailData); } else { BDebug::warning('Default email handler is not callable'); $result = false; } $emailData['result'] = $result; BEvents::i()->fire('BEmail::send:after', array('email_data' => $emailData)); return $result; } protected function _addAttachment($files, &$mailheaders, &$body) { $body = trim($body); $semi_rand = md5(microtime()); $mime_boundary = "==Multipart_Boundary_x{$semi_rand}x"; $headers = $mailheaders; $headers[] = "MIME-Version: 1.0"; $headers[] = "Content-Type: multipart/mixed;"; $headers[] = " boundary=\"{$mime_boundary}\""; $message = "--{$mime_boundary}\n\n" . $body . "\n\n"; foreach ($files as $file) { if (is_file($file)) { $data = chunk_split(base64_encode(file_get_contents($file))); $name = basename($file); $message .= "--{$mime_boundary}\n" . "Content-Type: application/octet-stream; name=\"" . $name . "\"\n" . "Content-Description: " . $name . "\n" . "Content-Disposition: attachment;\n" . " filename=\"" . $name . "\"; size=" . filesize($files[$i]) . ";\n" . "Content-Transfer-Encoding: base64\n\n" . $data . "\n\n"; } } $message .= "--{$mime_boundary}--"; $body = $message; $mailheaders = $headers; return true; } public function defaultHandler($data) { return mail($data['to'], $data['subject'], $data['body'], join("\r\n", $data['headers']), join(' ', $data['params'])); } } class BValue { public $content; public $type; public function __construct($content, $type='string') { $this->content = $content; $this->type = $type; } public function toPlain() { return $this->content; } public function __toString() { return (string)$this->toPlain(); } } class BType extends BValue {} class BData extends BClass implements ArrayAccess { protected $_data; public function __construct($data, $recursive = false) { if (!is_array($data)) { $data = array(); } if ($recursive) { foreach ($data as $k => $v) { if (is_array($v)) { $data[$k] = new BData($v, true); } } } $this->_data = $data; } public function as_array($recursive=false) { $data = $this->_data; if ($recursive) { foreach ($data as $k => $v) { if (is_object($v) && $v instanceof BData) { $data[$k] = $v->as_array(); } } } return $data; } public function __get($name) { return isset($this->_data[$name]) ? $this->_data[$name] : null; } public function __set($name, $value) { $this->_data[$name] = $value; } public function offsetSet($offset, $value) { if (is_null($offset)) { $this->_data[] = $value; } else { $this->_data[$offset] = $value; } } public function offsetExists($offset) { return isset($this->_data[$offset]); } public function offsetUnset($offset) { unset($this->_data[$offset]); } public function offsetGet($offset) { return isset($this->_data[$offset]) ? $this->_data[$offset] : null; } public function get($name) { return isset($this->_data[$name]) ? $this->_data[$name] : null; } public function set($name, $value) { $this->_data[$name] = $value; return $this; } } class BErrorException extends Exception { public $context; public $stackPop; public function __construct($code, $message, $file, $line, $context=null, $stackPop=1) { parent::__construct($message, $code); $this->file = $file; $this->line = $line; $this->context = $context; $this->stackPop = $stackPop; } } class BDebug extends BClass { const EMERGENCY = 0, ALERT = 1, CRITICAL = 2, ERROR = 3, WARNING = 4, NOTICE = 5, INFO = 6, DEBUG = 7; static protected $_levelLabels = array( self::EMERGENCY => 'EMERGENCY', self::ALERT => 'ALERT', self::CRITICAL => 'CRITICAL', self::ERROR => 'ERROR', self::WARNING => 'WARNING', self::NOTICE => 'NOTICE', self::INFO => 'INFO', self::DEBUG => 'DEBUG', ); const MEMORY = 0, FILE = 1, SYSLOG = 2, EMAIL = 4, OUTPUT = 8, EXCEPTION = 16, STOP = 4096; const MODE_DEBUG = 'DEBUG', MODE_DEVELOPMENT = 'DEVELOPMENT', MODE_STAGING = 'STAGING', MODE_PRODUCTION = 'PRODUCTION', MODE_MIGRATION = 'MIGRATION', MODE_INSTALLATION = 'INSTALLATION', MODE_RECOVERY = 'RECOVERY', MODE_DISABLED = 'DISABLED' ; static protected $_level; static protected $_levelPreset = array( self::MODE_PRODUCTION => array( self::MEMORY => false, self::SYSLOG => false, self::FILE => self::WARNING, self::EMAIL => false, self::OUTPUT => self::CRITICAL, self::EXCEPTION => self::ERROR, self::STOP => self::CRITICAL, ), self::MODE_STAGING => array( self::MEMORY => false, self::SYSLOG => false, self::FILE => self::WARNING, self::EMAIL => false, self::OUTPUT => self::CRITICAL, self::EXCEPTION => self::ERROR, self::STOP => self::CRITICAL, ), self::MODE_DEVELOPMENT => array( self::MEMORY => self::INFO, self::SYSLOG => false, self::FILE => self::WARNING, self::EMAIL => false, self::OUTPUT => self::NOTICE, self::EXCEPTION => self::ERROR, self::STOP => self::CRITICAL, ), self::MODE_DEBUG => array( self::MEMORY => self::DEBUG, self::SYSLOG => false, self::FILE => self::WARNING, self::EMAIL => false, self::OUTPUT => self::NOTICE, self::EXCEPTION => self::ERROR, self::STOP => self::CRITICAL, ), self::MODE_RECOVERY => array( self::MEMORY => self::DEBUG, self::SYSLOG => false, self::FILE => self::WARNING, self::EMAIL => false, self::OUTPUT => self::NOTICE, self::EXCEPTION => self::ERROR, self::STOP => self::CRITICAL, ), self::MODE_MIGRATION => array( self::MEMORY => self::DEBUG, self::SYSLOG => false, self::FILE => self::WARNING, self::EMAIL => false, self::OUTPUT => self::NOTICE, self::EXCEPTION => self::ERROR, self::STOP => self::CRITICAL, ), self::MODE_INSTALLATION => array( self::MEMORY => self::DEBUG, self::SYSLOG => false, self::FILE => self::WARNING, self::EMAIL => false, self::OUTPUT => self::NOTICE, self::EXCEPTION => self::ERROR, self::STOP => self::CRITICAL, ), self::MODE_DISABLED => array( self::MEMORY => false, self::SYSLOG => false, self::FILE => false, self::EMAIL => false, self::OUTPUT => false, self::EXCEPTION => false, self::STOP => false, ), ); static protected $_modules = array(); static protected $_mode = 'PRODUCTION'; static protected $_startTime; static protected $_events = array(); static protected $_logDir = null; static protected $_logFile = array( self::EMERGENCY => 'error.log', self::ALERT => 'error.log', self::CRITICAL => 'error.log', self::ERROR => 'error.log', self::WARNING => 'debug.log', self::NOTICE => 'debug.log', self::INFO => 'debug.log', self::DEBUG => 'debug.log', ); static protected $_adminEmail = null; static protected $_phpErrorMap = array( E_ERROR => self::ERROR, E_WARNING => self::WARNING, E_NOTICE => self::NOTICE, E_USER_ERROR => self::ERROR, E_USER_WARNING => self::WARNING, E_USER_NOTICE => self::NOTICE, E_STRICT => self::NOTICE, E_RECOVERABLE_ERROR => self::ERROR, ); static protected $_verboseBacktrace = array(); static protected $_collectedErrors = array(); static protected $_errorHandlerLog = array(); public function __construct() { self::$_startTime = microtime(true); BEvents::i()->on('BResponse::output:after', 'BDebug::afterOutput'); } public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public static function registerErrorHandlers() { set_error_handler('BDebug::errorHandler'); set_exception_handler('BDebug::exceptionHandler'); register_shutdown_function('BDebug::shutdownHandler'); } public static function startErrorLogger() { static::$_errorHandlerLog = array(); set_error_handler('BDebug::errorHandlerLogger'); } public static function stopErrorLogger() { set_error_handler('BDebug::errorHandler'); return static::$_errorHandlerLog; } public static function errorHandlerLogger($code, $message, $file, $line, $context=null) { return static::$_errorHandlerLog[] = compact('code', 'message', 'file', 'line', 'context'); } public static function errorHandler($code, $message, $file, $line, $context=null) { if (!(error_reporting() & $code)) { return; } static::trigger(self::$_phpErrorMap[$code], $message, 1); } public static function exceptionHandler($e) { static::trigger(self::ERROR, $e); } public static function shutdownHandler() { $e = error_get_last(); if ($e && ($e['type']===E_ERROR || $e['type']===E_PARSE || $e['type']===E_COMPILE_ERROR || $e['type']===E_COMPILE_WARNING)) { static::trigger(self::CRITICAL, $e['file'].':'.$e['line'].': '.$e['message'], 1); } } public static function level($type, $level=null) { if (!isset(static::$_level[$type])) { throw new BException('Invalid debug level type'); } if (is_null($level)) { if (is_null(static::$_level)) { static::$_level = static::$_levelPreset[self::$_mode]; } return static::$_level[$type]; } static::$_level[$type] = $level; } public static function logDir($dir) { BUtil::ensureDir($dir); static::$_logDir = $dir; } public static function log($msg, $file='debug.log') { error_log($msg."\n", 3, static::$_logDir.'/'.$file); } public static function logException($e) { static::log(print_r($e, 1), 'exceptions.log'); } public static function adminEmail($email) { self::$_adminEmail = $email; } public static function mode($mode=null, $setLevels=true) { if (is_null($mode)) { return static::$_mode; } self::$_mode = $mode; if ($setLevels && !empty(static::$_levelPreset[$mode])) { static::$_level = static::$_levelPreset[$mode]; } } public static function backtraceOn($msg) { foreach ((array)$msg as $m) { static::$_verboseBacktrace[$m] = true; } } public static function trigger($level, $msg, $stackPop=0) { if (is_scalar($msg)) { $e = array('msg'=>$msg); } elseif (is_object($msg) && $msg instanceof Exception) { $e = array('msg'=>$msg->getMessage()); } elseif (is_array($msg)) { $e = $msg; } else { throw new Exception('Invalid message type: '.print_r($msg, 1)); } $bt = debug_backtrace(true); $e['level'] = self::$_levelLabels[$level]; if (isset($bt[$stackPop]['file'])) $e['file'] = $bt[$stackPop]['file']; if (isset($bt[$stackPop]['line'])) $e['line'] = $bt[$stackPop]['line']; $e['ts'] = BDb::now(); $e['t'] = microtime(true)-self::$_startTime; $e['d'] = null; $e['c'] = null; $e['mem'] = memory_get_usage(); if (!empty(static::$_verboseBacktrace[$e['msg']])) { foreach ($bt as $t) { $e['msg'] .= "\n".$t['file'].':'.$t['line']; } } $message = "{$e['level']}: {$e['msg']}".(isset($e['file'])?" ({$e['file']}:{$e['line']})":''); if (($moduleName = BModuleRegistry::currentModuleName())) { $e['module'] = $moduleName; } if (is_null(static::$_level) && !empty(static::$_levelPreset[self::$_mode])) { static::$_level = static::$_levelPreset[self::$_mode]; } $l = self::$_level[self::MEMORY]; if (false!==$l && (is_array($l) && in_array($level, $l) || $l>=$level)) { self::$_events[] = $e; $id = sizeof(self::$_events)-1; } $l = self::$_level[self::SYSLOG]; if (false!==$l && (is_array($l) && in_array($level, $l) || $l>=$level)) { error_log($message, 0, self::$_logDir); } if (!is_null(self::$_logDir)) { $l = self::$_level[self::FILE]; if (false!==$l && (is_array($l) && in_array($level, $l) || $l>=$level)) { $file = self::$_logDir.'/'.self::$_logFile[$level]; if (is_writable(self::$_logDir) || is_writable($file)) { error_log("{$e['ts']} {$message}\n", 3, $file); } else { } } } if (!is_null(self::$_adminEmail)) { $l = self::$_level[self::EMAIL]; if (false!==$l && (is_array($l) && in_array($level, $l) || $l>=$level)) { error_log(print_r($e, 1), 1, self::$_adminEmail); } } $l = self::$_level[self::OUTPUT]; if (false!==$l && (is_array($l) && in_array($level, $l) || $l>=$level)) { echo '<xmp style="text-align:left; border:solid 1px red; font-family:monospace;">'; echo $message."\n"; debug_print_backtrace(); echo '</xmp>'; } $l = self::$_level[self::STOP]; if (false!==$l && (is_array($l) && in_array($level, $l) || $l>=$level)) { static::dumpLog(); die; } return isset($id) ? $id : null; } public static function alert($msg, $stackPop=0) { self::i()->collectError($msg); return self::trigger(self::ALERT, $msg, $stackPop+1); } public static function critical($msg, $stackPop=0) { self::i()->collectError($msg); return self::trigger(self::CRITICAL, $msg, $stackPop+1); } public static function error($msg, $stackPop=0) { self::i()->collectError($msg); return self::trigger(self::ERROR, $msg, $stackPop+1); } public static function warning($msg, $stackPop=0) { self::i()->collectError($msg); return self::trigger(self::WARNING, $msg, $stackPop+1); } public static function notice($msg, $stackPop=0) { self::i()->collectError($msg); return self::trigger(self::NOTICE, $msg, $stackPop+1); } public static function info($msg, $stackPop=0) { self::i()->collectError($msg); return self::trigger(self::INFO, $msg, $stackPop+1); } public function collectError($msg, $type=self::ERROR) { self::$_collectedErrors[$type][] = $msg; } public function getCollectedErrors($type=self::ERROR) { if (!empty(self::$_collectedErrors[$type])) { return self::$_collectedErrors[$type]; } } public static function debug($msg, $stackPop=0) { if ('DEBUG'!==self::$_mode) return; return self::trigger(self::DEBUG, $msg, $stackPop+1); } public static function profile($id) { if ($id && !empty(self::$_events[$id])) { self::$_events[$id]['d'] = microtime(true)-self::$_startTime-self::$_events[$id]['t']; self::$_events[$id]['c']++; } } public static function is($modes) { if (is_string($modes)) $modes = explode(',', $modes); return in_array(self::$_mode, $modes); } public static function dumpLog($return=false) { if ((self::$_mode!==self::MODE_DEBUG && self::$_mode!==self::MODE_DEVELOPMENT) || BResponse::i()->contentType()!=='text/html' || BRequest::i()->xhr() ) { return; } ob_start(); ?><style>
#buckyball-debug-trigger { position:fixed; top:0; right:0; font:normal 10px Verdana; cursor:pointer; z-index:999999; background:#ffc; }
#buckyball-debug-console { position:fixed; overflow:auto; top:10px; left:10px; bottom:10px; right:10px; border:solid 2px #f00; padding:4px; text-align:left; opacity:1; background:#FFC; font:normal 10px Verdana; z-index:20000; }
#buckyball-debug-console table { border-collapse: collapse; }
#buckyball-debug-console th, #buckyball-debug-console td { font:normal 10px Verdana; border: solid 1px #ccc; padding:2px 5px;}
#buckyball-debug-console th { font-weight:bold; }
</style>
<div id="buckyball-debug-trigger" onclick="var el=document.getElementById('buckyball-debug-console');el.style.display=el.style.display?'':'none'">[DBG]</div>
<div id="buckyball-debug-console" style="display:none"><?php
 echo "DELTA: ".BDebug::i()->delta().', PEAK: '.memory_get_peak_usage(true).', EXIT: '.memory_get_usage(true); echo "<pre>"; print_r(BORM::get_query_log()); echo "</pre>"; ?><table cellspacing="0"><tr><th>Message</th><th>Rel.Time</th><th>Profile</th><th>Memory</th><th>Level</th><th>Relevant Location</th><th>Module</th></tr><?php
 foreach (self::$_events as $e) { if (empty($e['file'])) { $e['file'] = ''; $e['line'] = ''; } $profile = $e['d'] ? number_format($e['d'], 6).($e['c']>1 ? ' ('.$e['c'].')' : '') : ''; echo "<tr><td><xmp style='margin:0'>".$e['msg']."</xmp></td><td>".number_format($e['t'], 6)."</td><td>".$profile."</td><td>".number_format($e['mem'], 0)."</td><td>{$e['level']}</td><td>{$e['file']}:{$e['line']}</td><td>".(!empty($e['module'])?$e['module']:'')."</td></tr>"; } ?></table></div><?php
 $html = ob_get_clean(); if ($return) { return $html; } else { echo $html; } } public static function delta() { return microtime(true)-self::$_startTime; } public static function dump($var) { if (is_array($var) && current($var) instanceof Model) { foreach ($var as $k=>$v) { echo '<hr>'.$k.':'; static::dump($v); } } elseif ($var instanceof Model) { echo '<pre>'; print_r($var->as_array()); echo '</pre>'; } else { echo '<pre>'; print_r($var); echo '</pre>'; } } public static function afterOutput($args) { static::dumpLog(); } } class BLocale extends BClass { static protected $_domainPrefix = 'fulleron/'; static protected $_domainStack = array(); static protected $_defaultLanguage = 'en_US'; static protected $_currentLanguage; static protected $_transliterateMap = array( '&amp;' => 'and', '@' => 'at', '' => 'c', '' => 'r', '' => 'a', '' => 'a', '' => 'a', '' => 'a', '' => 'a', '' => 'ae','' => 'c', '' => 'e', '' => 'e', '' => 'e', '' => 'i', '' => 'i', '' => 'i', '' => 'i', '' => 'o', '' => 'o', '' => 'o', '' => 'o', '' => 'o', '' => 'o', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'y', '' => 'ss','' => 'a', '' => 'a', '' => 'a', '' => 'a', '' => 'a', '' => 'ae','' => 'c', '' => 'e', '' => 'e', '' => 'e', '' => 'e', '' => 'i', '' => 'i', '' => 'i', '' => 'i', '' => 'o', '' => 'o', '' => 'o', '' => 'o', '' => 'o', '' => 'o', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'y', '' => 'p', '' => 'y', '' => 'a', '' => 'a', '' => 'a', '' => 'a', '' => 'a', '' => 'a', '' => 'c', '' => 'c', '' => 'c', '' => 'c', '' => 'c', '' => 'c', '' => 'c', '' => 'c', '' => 'd', '' => 'd', '' => 'd', '' => 'd', '' => 'e', '' => 'e', '' => 'e', '' => 'e', '' => 'e', '' => 'e', '' => 'e', '' => 'e', '' => 'e', '' => 'e', '' => 'g', '' => 'g', '' => 'g', '' => 'g', '' => 'g', '' => 'g', '' => 'g', '' => 'g', '' => 'h', '' => 'h', '' => 'h', '' => 'h', '' => 'i', '' => 'i', '' => 'i', '' => 'i', '' => 'i', '' => 'i', '' => 'i', '' => 'i', '' => 'i', '' => 'i', '' => 'ij','' => 'ij','' => 'j', '' => 'j', '' => 'k', '' => 'k', '' => 'k', '' => 'l', '' => 'l', '' => 'l', '' => 'l', '' => 'l', '' => 'l', '' => 'l', '' => 'l', '' => 'l', '' => 'l', '' => 'n', '' => 'n', '' => 'n', '' => 'n', '' => 'n', '' => 'n', '' => 'n', '' => 'n', '' => 'n', '' => 'o', '' => 'o', '' => 'o', '' => 'o', '' => 'o', '' => 'o', '' => 'oe','' => 'oe','' => 'r', '' => 'r', '' => 'r', '' => 'r', '' => 'r', '' => 'r', '' => 's', '' => 's', '' => 's', '' => 's', '' => 's', '' => 's', '' => 's', '' => 's', '' => 't', '' => 't', '' => 't', '' => 't', '' => 't', '' => 't', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'w', '' => 'w', '' => 'y', '' => 'y', '' => 'y', '' => 'z', '' => 'z', '' => 'z', '' => 'z', '' => 'z', '' => 'z', '' => 'z', '' => 'e', '' => 'f', '' => 'o', '' => 'o', '' => 'u', '' => 'u', '' => 'a', '' => 'a', '' => 'i', '' => 'i', '' => 'o', '' => 'o', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'u', '' => 'a', '' => 'a', '' => 'ae','' => 'ae','' => 'o', '' => 'o', '' => 'e', '' => 'jo','' => 'e', '' => 'i', '' => 'i', '' => 'a', '' => 'b', '' => 'v', '' => 'g', '' => 'd', '' => 'e', '' => 'zh','' => 'z', '' => 'i', '' => 'j', '' => 'k', '' => 'l', '' => 'm', '' => 'n', '' => 'o', '' => 'p', '' => 'r', '' => 's', '' => 't', '' => 'u', '' => 'f', '' => 'h', '' => 'c', '' => 'ch','' => 'sh','' => 'sch', '' => '-', '' => 'y', '' => '-', '' => 'je','' => 'ju','' => 'ja', '' => 'a', '' => 'b', '' => 'v', '' => 'g', '' => 'd', '' => 'e', '' => 'zh','' => 'z', '' => 'i', '' => 'j', '' => 'k', '' => 'l', '' => 'm', '' => 'n', '' => 'o', '' => 'p', '' => 'r', '' => 's', '' => 't', '' => 'u', '' => 'f', '' => 'h', '' => 'c', '' => 'ch', '' => 'sh','' => 'sch','' => '-','' => 'y', '' => '-', '' => 'je', '' => 'ju','' => 'ja','' => 'jo','' => 'e', '' => 'i', '' => 'i', '' => 'g', '' => 'g', '' => 'a', '' => 'b', '' => 'g', '' => 'd', '' => 'h', '' => 'v', '' => 'z', '' => 'h', '' => 't', '' => 'i', '' => 'k', '' => 'k', '' => 'l', '' => 'm', '' => 'm', '' => 'n', '' => 'n', '' => 's', '' => 'e', '' => 'p', '' => 'p', '' => 'C', '' => 'c', '' => 'q', '' => 'r', '' => 'w', '' => 't', '' => 'tm', ); protected $_defaultTz = 'America/Los_Angeles'; protected $_defaultLocale = 'en_US'; protected $_tzCache = array(); protected static $_tr; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function __construct() { date_default_timezone_set($this->_defaultTz); setlocale(LC_ALL, $this->_defaultLocale); $this->_tzCache['GMT'] = new DateTimeZone('GMT'); } public static function transliterate($str, $filler='-') { return strtolower(trim(preg_replace('#[^0-9a-z]+#i', $filler, strtr($str, static::$_transliterateMap)), $filler)); } public static function setCurrentLanguage($lang) { self::$_currentLanguage = $lang; } public static function getCurrentLanguage() { if (empty(static::$_currentLanguage)) { static::$_currentLanguage = static::$_defaultLanguage; } return static::$_currentLanguage; } public static function importTranslations($data, $params=array()) { $module = !empty($params['_module']) ? $params['_module'] : BModuleRegistry::currentModuleName(); if (is_string($data)) { if (!BUtil::isPathAbsolute($data)) { $data = BApp::m($module)->root_dir.'/i18n/'.$data; } if (is_readable($data)) { $extension = !empty($params['extension']) ? $params['extension'] : 'csv'; switch ($extension) { case 'csv': $fp = fopen($data, 'r'); while (($r = fgetcsv($fp, 2084))) { static::addTranslation($r, $module); } fclose($fp); break; case 'json': $content = file_get_contents($data); $translations = BUtil::fromJson($content); foreach ($translations as $word => $tr) { static::addTranslation(array($word,$tr), $module); } break; case 'php': $translations = include $data; foreach ($translations as $word => $tr) { static::addTranslation(array($word,$tr), $module); } break; } } else { BDebug::warning('Could not load translation file: '.$data); return; } } elseif (is_array($data)) { foreach ($data as $r) { static::addTranslation($r, $module); } } } static public function collectTranslations($rootDir, $targetFile) { $files = self::getFilesFromDir($rootDir); if (empty($files)) { return true; } $keys = array(); foreach($files as $file) { $source = file_get_contents($file); $tokens = token_get_all($source); $func = 0; $class = 0; $sep = 0; foreach($tokens as $token) { if (empty($token[1])){ continue; } if ($token[1] =='BLocale') { $class = 1; continue; } if ($class && $token[1] == '::') { $class = 0; $sep = 1; continue; } if ($sep && $token[1] == '_') { $sep = 0; $func = 1; continue; } if($func) { $token[1] = trim($token[1], "'"); $keys[$token[1]] = ''; $func = 0; continue; } } } self::$_tr = ''; self::addTranslationsFile($targetFile); $translations = self::getTranslations(); foreach ($keys as $key => $v) { if(isset($translations[$key])) { unset($keys[$key]); } } $newtranslations = array(); if ($translations) { foreach($translations as $trkey => $tr){ list(,$newtranslations[$trkey]) = each($tr); } } $newtranslations = array_merge($newtranslations, $keys); $ext = strtolower(pathinfo($targetFile, PATHINFO_EXTENSION)); switch ($ext) { case 'php': self::saveToPHP($targetFile, $newtranslations); break; case 'csv': self::saveToCSV($targetFile, $newtranslations); break; case 'json': self::saveToJSON($targetFile, $newtranslations); break; default: throw new Exception("Undefined format of translation targetFile. Possible formats are: json/csv/php"); } } static protected function saveToPHP($targetFile, $array) { $code = ''; foreach($array as $k => $v) { if (!empty($code)) { $code .= ','."\n"; } $code .= "'{$k}' => '".addslashes($v)."'"; } $code = "<?php return array({$code});"; file_put_contents($targetFile, $code); } static protected function saveToJSON($targetFile, $array) { $json = json_encode($array); file_put_contents($targetFile, $json); } static protected function saveToCSV($targetFile, $array) { $handle = fopen($targetFile, "w"); foreach ($array as $k => $v) { $k = trim($k, '"'); fputcsv($handle, array($k, $v)); } fclose($handle); } static public function getFilesFromDir($dir) { $files = array(); if (false !== ($handle = opendir($dir))) { while (false !== ($file = readdir($handle))) { if ($file != "." && $file != "..") { if(is_dir($dir.'/'.$file)) { $dir2 = $dir.'/'.$file; $files = array_merge($files, self::getFilesFromDir($dir2)); } else { $files[] = $dir.'/'.$file; } } } closedir($handle); } return $files; } static public function addTranslationsFile($file) { $ext = strtolower(pathinfo($file, PATHINFO_EXTENSION)); if (empty($ext)) { return; } $params['extension'] = $ext; self::importTranslations($file, $params); } protected static function addTranslation($r, $module=null) { if (empty($r[1])) { BDebug::debug('No translation specified for '.$r[0]); return; } static::$_tr[ $r[0] ][ !empty($module) ? $module : '_' ] = $r[1]; } public static function cacheSave() { } public static function cacheLoad() { } public static function _($string, $params=array(), $module=null) { if (empty(static::$_tr[$string])) { $tr = $string; } else { $arr = static::$_tr[$string]; if (!empty($module) && !empty($arr[$module])) { $tr = $arr[$module]; } elseif (!empty($arr['_'])) { $tr = $arr['_']; } else { reset($arr); $tr = current($arr); } } return BUtil::sprintfn($tr, $params); } public function serverTz() { return date('e'); } public function tzOffset($tz=null) { if (is_null($tz)) { return date('O') * 36; } if (empty($this->_tzCache[$tz])) { $this->_tzCache[$tz] = new DateTimeZone($tz); } return $this->_tzCache[$tz]->getOffset($this->_tzCache['GMT']); } public function datetimeLocalToDb($value) { if (is_array($value)) { return array_map(array($this, __METHOD__), $value); } if (!$value) return $value; return gmstrftime('%F %T', strtotime($value)); } public function parseRequestDates($request, $fields=null) { if (is_string($fields)) $fields = explode(',', $fields); $isObject = is_object($request); if ($isObject) $result = clone $request; foreach ($request as $k=>$v) { if (is_null($fields) || in_array($k, $fields)) { $r = $this->datetimeLocalToDb($v); } else { $r = $v; } if ($isObject) $result->$k = $r; else $result[$k] = $r; } return $result; } public function datetimeDbToLocal($value, $full=false) { return strftime($full ? '%c' : '%x', strtotime($value)); } static public function getTranslations() { return self::$_tr; } static protected $_currency; static public function setCurrency($currency) { static::$_currency = $currency; } static public function currency($value, $currency = null) { if (!$currency) { $currency = static::$_currency; } return sprintf('%s%s', $currency, number_format($value, 2)); } } class BFtpClient extends BClass { protected $_ftpDirMode = 0775; protected $_ftpFileMode = 0664; protected $_ftpHost = ''; protected $_ftpPort = 21; protected $_ftpUsername = ''; protected $_ftpPassword = ''; public function __construct($config) { if (!empty($config['hostname'])) { $this->_ftpHost = $config['hostname']; } if (!empty($config['port'])) { $this->_ftpPort = $config['port']; } if (!empty($config['username'])) { $this->_ftpUsername = $config['username']; } if (!empty($config['password'])) { $this->_ftpPassword = $config['password']; } } public function ftpUpload($from, $to) { if (!extension_loaded('ftp')) { new BException('FTP PHP extension is not installed'); } if (!($conn = ftp_connect($this->_ftpHost, $this->_ftpPort))) { throw new BException('Could not connect to FTP host'); } if (!@ftp_login($conn, $this->_ftpUsername, $this->_ftpPassword)) { ftp_close($conn); throw new BException('Could not login to FTP host'); } if (!ftp_chdir($conn, $to)) { ftp_close($conn); throw new BException('Could not navigate to '. $to); } $errors = $this->ftpUploadDir($conn, $from.'/'); ftp_close($conn); return $errors; } public function ftpUploadDir($conn, $source, $ftpPath='') { $errors = array(); $dir = opendir($source); while ($file = readdir($dir)) { if ($file=='.' || $file=="..") { continue; } if (!is_dir($source.$file)) { if (@ftp_put($conn, $file, $source.$file, FTP_BINARY)) { } else { $errors[] = ftp_pwd($conn).'/'.$file; } continue; } if (@ftp_chdir($conn, $file)) { } elseif (@ftp_mkdir($conn, $file)) { ftp_chmod($conn, $this->_ftpDirMode, $file); ftp_chdir($conn, $file); } else { $errors[] = ftp_pwd($conn).'/'.$file.'/'; continue; } $errors += $this->ftpUploadDir($conn, $source.$file.'/', $ftpPath.$file.'/'); ftp_chdir($conn, '..'); } return $errors; } } class BLoginThrottle extends BClass { protected $_all; protected $_area; protected $_username; protected $_rec; protected $_config; protected $_blockedIPs = array(); protected $_cachePrefix = 'BLoginThrottle/'; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function __construct() { $c = BConfig::i()->get('modules/BLoginThrottle'); if (empty($c['sleep_sec'])) $c['sleep_sec'] = 2; if (empty($c['brute_attempts_max'])) $c['brute_attempts_max'] = 3; if (empty($c['reset_time'])) $c['reset_time'] = 10; $this->_config = $c; } public function config($config) { $this->_config = BUtil::arrayMerge($this->_config, $config); } public function init($area, $username) { $now = time(); $c = $this->_config; $this->_area = $area; $this->_username = $username; $this->_rec = $this->_load(); if ($this->_rec) { if ($this->_rec['status'] === 'FAILED') { if (empty($this->_rec['brute_attempts_cnt'])) { $this->_rec['brute_attempts_cnt'] = 1; } else { $this->_rec['brute_attempts_cnt']++; } $this->_save(); $this->_fire('init:brute'); if ($this->_rec['brute_attempts_cnt'] == $c['brute_attempts_max']) { $this->_fire('init:brute_max'); } return false; } } return true; } public function success() { $this->_fire('success'); $this->_reset(); return true; } public function failure() { $username = $this->_username; $now = time(); $c = $this->_config; $this->_fire('fail:before'); if (empty($this->_rec['attempt_cnt'])) { $this->_rec['attempt_cnt'] = 1; } else { $this->_rec['attempt_cnt']++; } $this->_rec['last_attempt'] = $now; $this->_rec['status'] = 'FAILED'; $this->_save(); $this->_fire('fail:wait'); $this->_gc(); sleep($c['sleep_sec']); $this->_rec['status'] = ''; $this->_save(); $this->_fire('fail:after'); return true; } protected function _fire($event) { BEvents::i()->fire('BLoginThrottle::'.$event, array( 'area' => $this->_area, 'username' => $this->_username, 'rec' => $this->_rec, 'config' => $this->_config, )); } protected function _load() { $key = $this->_area.'/'.$this->_username; return BCache::i()->load($this->_cachePrefix.$key); } protected function _save() { $key = $this->_area.'/'.$this->_username; return BCache::i()->save($this->_cachePrefix.$key, $this->_rec, $this->_config['reset_time']); } protected function _reset() { $key = $this->_area.'/'.$this->_username; return BCache::i()->delete($key); } protected function _gc() { return true; } } class BYAML extends BCLass { static protected $_peclYaml = null; static protected $_peclSyck = null; static public function bootstrap() { } static public function load($filename, $cache=true) { $filename1 = realpath($filename); if (!$filename1) { BDebug::debug('BCache load: file does not exist: '.$filename); return false; } $filename = $filename1; $filemtime = filemtime($filename); if ($cache) { $cacheData = BCache::i()->load('BYAML--'.$filename); if (!empty($cacheData) && !empty($cacheData['v']) && $cacheData['v'] === $filemtime) { return $cacheData['d']; } } $yamlData = file_get_contents($filename); $yamlData = str_replace("\t", '    ', $yamlData); $arrayData = static::parse($yamlData); if ($cache) { BCache::i()->save('BYAML--'.$filename, array('v'=>$filemtime, 'd'=>$arrayData), false); } return $arrayData; } static public function init() { if (is_null(static::$_peclYaml)) { static::$_peclYaml = function_exists('yaml_parse'); if (!static::$_peclYaml) { static::$_peclSyck = function_exists('syck_load'); } if (!static::$_peclYaml && !static::$_peclSyck) { require_once(__DIR__.'/lib/spyc.php'); } } return true; } static public function parse($yamlData) { static::init(); if (static::$_peclYaml) { return yaml_parse($yamlData); } elseif (static::$_peclSyck) { return syck_load($yamlData); } if (class_exists('Spyc', false)) { return Spyc::YAMLLoadString($yamlData); } else { return Symfony\Component\Yaml\Yaml::parse($yamlData); } } static public function dump($arrayData) { static::init(); if (static::$_peclYaml) { return yaml_emit($arrayData); } elseif (static::$_peclSyck) { return syck_dump($arrayData); } if (class_exists('Spyc', false)) { return Spyc::YAMLDump($arrayData); } else { return Symfony\Component\Yaml\Yaml::dump($arrayData); } } } class Bcrypt extends BClass { public function __construct() { if (CRYPT_BLOWFISH != 1) { throw new Exception("bcrypt not supported in this installation. See http://php.net/crypt"); } } public function hash($input) { if (function_exists('password_hash')) { return password_hash($input); } $hash = crypt($input, $this->getSalt()); if (strlen($hash) > 13) { return $hash; } return false; } public function verify($input, $existingHash) { if (function_exists('password_verify')) { return password_verify($input, $existingHash); } $hash = crypt($input, $existingHash); return $hash === $existingHash; } private function getSalt() { $mode = version_compare(phpversion(), '5.3.7', '>=') ? '2y' : '2a'; $bytes = $this->getRandomBytes(16); $salt = '$' . $mode . '$12$'; $salt .= $this->encodeBytes($bytes); return $salt; } private $randomState; private function getRandomBytes($count) { $bytes = ''; if (function_exists('openssl_random_pseudo_bytes') && (strtoupper(substr(PHP_OS, 0, 3)) !== 'WIN')) { $bytes = openssl_random_pseudo_bytes($count); } if ($bytes === '' && is_readable('/dev/urandom') && ($hRand = @fopen('/dev/urandom', 'rb')) !== FALSE) { $bytes = fread($hRand, $count); fclose($hRand); } if (strlen($bytes) < $count) { $bytes = ''; if ($this->randomState === null) { $this->randomState = microtime(); if (function_exists('getmypid')) { $this->randomState .= getmypid(); } } for ($i = 0; $i < $count; $i += 16) { $this->randomState = md5(microtime() . $this->randomState); $bytes .= md5($this->randomState, true); } $bytes = substr($bytes, 0, $count); } return $bytes; } private function encodeBytes($input) { $itoa64 = './ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; $output = ''; $i = 0; do { $c1 = ord($input[$i++]); $output .= $itoa64[$c1 >> 2]; $c1 = ($c1 & 0x03) << 4; if ($i >= 16) { $output .= $itoa64[$c1]; break; } $c2 = ord($input[$i++]); $c1 |= $c2 >> 4; $output .= $itoa64[$c1]; $c1 = ($c2 & 0x0f) << 2; $c2 = ord($input[$i++]); $c1 |= $c2 >> 6; $output .= $itoa64[$c1]; $output .= $itoa64[$c2 & 0x3f]; } while (1); return $output; } } if( !function_exists( 'xmlentities' ) ) { function xmlentities( $string ) { $not_in_list = "A-Z0-9a-z\s_-"; return preg_replace_callback( "/[^{$not_in_list}]/" , 'get_xml_entity_at_index_0' , $string ); } function get_xml_entity_at_index_0( $CHAR ) { if( !is_string( $CHAR[0] ) || ( strlen( $CHAR[0] ) > 1 ) ) { die( "function: 'get_xml_entity_at_index_0' requires data type: 'char' (single character). '{$CHAR[0]}' does not match this type." ); } switch( $CHAR[0] ) { case "'": case '"': case '&': case '<': case '>': return htmlspecialchars( $CHAR[0], ENT_QUOTES ); break; default: return numeric_entity_4_char($CHAR[0]); break; } } function numeric_entity_4_char( $char ) { return "&#".str_pad(ord($char), 3, '0', STR_PAD_LEFT).";"; } }  class ORM { const WHERE_FRAGMENT = 0; const WHERE_VALUES = 1; protected static $_config = array( 'connection_string' => 'sqlite::memory:', 'id_column' => 'id', 'id_column_overrides' => array(), 'error_mode' => PDO::ERRMODE_EXCEPTION, 'username' => null, 'password' => null, 'driver_options' => null, 'identifier_quote_character' => null, 'logging' => false, 'caching' => false, ); protected static $_db; protected static $_last_query; protected static $_query_log = array(); protected static $_query_cache = array(); protected $_table_name; protected $_table_alias = null; protected $_values = array(); protected $_result_columns = array('*'); protected $_using_default_result_columns = true; protected $_join_sources = array(); protected $_distinct = false; protected $_is_raw_query = false; protected $_raw_query = ''; protected $_raw_parameters = array(); protected $_where_conditions = array(); protected $_limit = null; protected $_offset = null; protected $_order_by = array(); protected $_group_by = array(); protected $_data = array(); protected $_dirty_fields = array(); protected $_is_new = false; protected $_instance_id_column = null; public static function configure($key, $value=null) { if (is_null($value)) { $value = $key; $key = 'connection_string'; } static::$_config[$key] = $value; } public static function for_table($table_name) { static::_setup_db(); return new static($table_name); } protected static function _setup_db() { if (!is_object(static::$_db)) { $connection_string = static::$_config['connection_string']; $username = static::$_config['username']; $password = static::$_config['password']; $driver_options = static::$_config['driver_options']; $db = new PDO($connection_string, $username, $password, $driver_options); $db->setAttribute(PDO::ATTR_ERRMODE, static::$_config['error_mode']); static::set_db($db); } } public static function set_db($db) { static::$_db = $db; static::_setup_identifier_quote_character(); } public static function _setup_identifier_quote_character() { if (is_null(static::$_config['identifier_quote_character'])) { static::$_config['identifier_quote_character'] = static::_detect_identifier_quote_character(); } } protected static function _detect_identifier_quote_character() { switch(static::$_db->getAttribute(PDO::ATTR_DRIVER_NAME)) { case 'pgsql': case 'sqlsrv': case 'dblib': case 'mssql': case 'sybase': return '"'; case 'mysql': case 'sqlite': case 'sqlite2': default: return '`'; } } public static function get_db() { static::_setup_db(); return static::$_db; } protected static function _log_query($query, $parameters) { if (!static::$_config['logging']) { return false; } if (count($parameters) > 0) { $parameters = array_map(array(static::$_db, 'quote'), $parameters); $query = str_replace("?", "%s", $query); $bound_query = vsprintf($query, $parameters); } else { $bound_query = $query; } static::$_last_query = $bound_query; static::$_query_log[] = $bound_query; return true; } public static function get_last_query() { return static::$_last_query; } public static function get_query_log() { return static::$_query_log; } protected function __construct($table_name, $data=array()) { $this->_table_name = $table_name; $this->_data = $data; } public function create($data=null) { $this->_is_new = true; if (!is_null($data)) { return $this->hydrate($data)->force_all_dirty(); } return $this; } public function use_id_column($id_column) { $this->_instance_id_column = $id_column; return $this; } protected function _create_instance_from_row($row) { $instance = static::for_table($this->_table_name); $instance->use_id_column($this->_instance_id_column); $instance->hydrate($row); return $instance; } public function find_one($id=null) { if (!is_null($id)) { $this->where_id_is($id); } $this->limit(1); $rows = $this->_run(); if (empty($rows)) { return false; } return $this->_create_instance_from_row($rows[0]); } public function find_many() { $rows = $this->_run(); return array_map(array($this, '_create_instance_from_row'), $rows); } public function count() { $this->select_expr('COUNT(*)', 'count'); $result = $this->find_one(); return ($result !== false && isset($result->count)) ? (int) $result->count : 0; } public function hydrate($data=array()) { $this->_data = $data; return $this; } public function force_all_dirty() { $this->_dirty_fields = $this->_data; return $this; } public function raw_query($query, $parameters) { $this->_is_raw_query = true; $this->_raw_query = $query; $this->_raw_parameters = $parameters; return $this; } public function table_alias($alias) { $this->_table_alias = $alias; return $this; } protected function _add_result_column($expr, $alias=null) { if (!is_null($alias)) { $expr .= " AS " . $this->_quote_identifier($alias); } if ($this->_using_default_result_columns) { $this->_result_columns = array($expr); $this->_using_default_result_columns = false; } else { $this->_result_columns[] = $expr; } return $this; } public function select($column, $alias=null) { $column = $this->_quote_identifier($column); return $this->_add_result_column($column, $alias); } public function select_expr($expr, $alias=null) { return $this->_add_result_column($expr, $alias); } public function distinct() { $this->_distinct = true; return $this; } protected function _add_join_source($join_operator, $table, $constraint, $table_alias=null) { $join_operator = trim("{$join_operator} JOIN"); $table = $this->_quote_identifier($table); if (!is_null($table_alias)) { $table_alias = $this->_quote_identifier($table_alias); $table .= " {$table_alias}"; } if (is_array($constraint)) { list($first_column, $operator, $second_column) = $constraint; $first_column = $this->_quote_identifier($first_column); $second_column = $this->_quote_identifier($second_column); $constraint = "{$first_column} {$operator} {$second_column}"; } $this->_join_sources[] = "{$join_operator} {$table} ON {$constraint}"; return $this; } public function join($table, $constraint, $table_alias=null) { return $this->_add_join_source("", $table, $constraint, $table_alias); } public function inner_join($table, $constraint, $table_alias=null) { return $this->_add_join_source("INNER", $table, $constraint, $table_alias); } public function left_outer_join($table, $constraint, $table_alias=null) { return $this->_add_join_source("LEFT OUTER", $table, $constraint, $table_alias); } public function right_outer_join($table, $constraint, $table_alias=null) { return $this->_add_join_source("RIGHT OUTER", $table, $constraint, $table_alias); } public function full_outer_join($table, $constraint, $table_alias=null) { return $this->_add_join_source("FULL OUTER", $table, $constraint, $table_alias); } protected function _add_where($fragment, $values=array()) { if (!is_array($values)) { $values = array($values); } $this->_where_conditions[] = array( static::WHERE_FRAGMENT => $fragment, static::WHERE_VALUES => $values, ); return $this; } protected function _add_simple_where($column_name, $separator, $value) { $column_name = $this->_quote_identifier($column_name); return $this->_add_where("{$column_name} {$separator} ?", $value); } protected function _create_placeholders($number_of_placeholders) { return join(", ", array_fill(0, $number_of_placeholders, "?")); } public function where($column_name, $value) { return $this->where_equal($column_name, $value); } public function where_equal($column_name, $value) { return $this->_add_simple_where($column_name, '=', $value); } public function where_not_equal($column_name, $value) { return $this->_add_simple_where($column_name, '!=', $value); } public function where_id_is($id) { return $this->where($this->_get_id_column_name(), $id); } public function where_like($column_name, $value) { return $this->_add_simple_where($column_name, 'LIKE', $value); } public function where_not_like($column_name, $value) { return $this->_add_simple_where($column_name, 'NOT LIKE', $value); } public function where_gt($column_name, $value) { return $this->_add_simple_where($column_name, '>', $value); } public function where_lt($column_name, $value) { return $this->_add_simple_where($column_name, '<', $value); } public function where_gte($column_name, $value) { return $this->_add_simple_where($column_name, '>=', $value); } public function where_lte($column_name, $value) { return $this->_add_simple_where($column_name, '<=', $value); } public function where_in($column_name, $values) { $column_name = $this->_quote_identifier($column_name); $placeholders = $this->_create_placeholders(count($values)); return $this->_add_where("{$column_name} IN ({$placeholders})", $values); } public function where_not_in($column_name, $values) { $column_name = $this->_quote_identifier($column_name); $placeholders = $this->_create_placeholders(count($values)); return $this->_add_where("{$column_name} NOT IN ({$placeholders})", $values); } public function where_null($column_name) { $column_name = $this->_quote_identifier($column_name); return $this->_add_where("{$column_name} IS NULL"); } public function where_not_null($column_name) { $column_name = $this->_quote_identifier($column_name); return $this->_add_where("{$column_name} IS NOT NULL"); } public function where_raw($clause, $parameters=array()) { return $this->_add_where($clause, $parameters); } public function limit($limit) { $this->_limit = $limit; return $this; } public function offset($offset) { $this->_offset = $offset; return $this; } protected function _add_order_by($column_name, $ordering) { $column_name = $this->_quote_identifier($column_name); $this->_order_by[] = "{$column_name} {$ordering}"; return $this; } public function order_by_desc($column_name) { return $this->_add_order_by($column_name, 'DESC'); } public function order_by_asc($column_name) { return $this->_add_order_by($column_name, 'ASC'); } public function group_by($column_name) { $column_name = $this->_quote_identifier($column_name); $this->_group_by[] = $column_name; return $this; } protected function _build_select() { if ($this->_is_raw_query) { $this->_values = $this->_raw_parameters; return $this->_raw_query; } return $this->_join_if_not_empty(" ", array( $this->_build_select_start(), $this->_build_join(), $this->_build_where(), $this->_build_group_by(), $this->_build_order_by(), $this->_build_limit(), $this->_build_offset(), )); } protected function _build_select_start() { $result_columns = join(', ', $this->_result_columns); if ($this->_distinct) { $result_columns = 'DISTINCT ' . $result_columns; } $fragment = "SELECT {$result_columns} FROM " . $this->_quote_identifier($this->_table_name); if (!is_null($this->_table_alias)) { $fragment .= " " . $this->_quote_identifier($this->_table_alias); } return $fragment; } protected function _build_join() { if (count($this->_join_sources) === 0) { return ''; } return join(" ", $this->_join_sources); } protected function _build_where() { if (count($this->_where_conditions) === 0) { return ''; } $where_conditions = array(); foreach ($this->_where_conditions as $condition) { $where_conditions[] = $condition[static::WHERE_FRAGMENT]; $this->_values = array_merge($this->_values, $condition[static::WHERE_VALUES]); } return "WHERE " . join(" AND ", $where_conditions); } protected function _build_group_by() { if (count($this->_group_by) === 0) { return ''; } return "GROUP BY " . join(", ", $this->_group_by); } protected function _build_order_by() { if (count($this->_order_by) === 0) { return ''; } return "ORDER BY " . join(", ", $this->_order_by); } protected function _build_limit() { if (!is_null($this->_limit)) { return "LIMIT " . $this->_limit; } return ''; } protected function _build_offset() { if (!is_null($this->_offset)) { return "OFFSET " . $this->_offset; } return ''; } protected function _join_if_not_empty($glue, $pieces) { $filtered_pieces = array(); foreach ($pieces as $piece) { if (is_string($piece)) { $piece = trim($piece); } if (!empty($piece)) { $filtered_pieces[] = $piece; } } return join($glue, $filtered_pieces); } protected function _quote_identifier($identifier) { $parts = explode('.', $identifier); $parts = array_map(array($this, '_quote_identifier_part'), $parts); return join('.', $parts); } protected function _quote_identifier_part($part) { if ($part === '*') { return $part; } $quote_character = static::$_config['identifier_quote_character']; return $quote_character . $part . $quote_character; } protected static function _create_cache_key($query, $parameters) { $parameter_string = join(',', $parameters); $key = $query . ':' . $parameter_string; return sha1($key); } protected static function _check_query_cache($cache_key) { if (isset(static::$_query_cache[$cache_key])) { return static::$_query_cache[$cache_key]; } return false; } public static function clear_cache() { static::$_query_cache = array(); } protected static function _cache_query_result($cache_key, $value) { static::$_query_cache[$cache_key] = $value; } protected function _run() { $query = $this->_build_select(); $caching_enabled = static::$_config['caching']; if ($caching_enabled) { $cache_key = static::_create_cache_key($query, $this->_values); $cached_result = static::_check_query_cache($cache_key); if ($cached_result !== false) { return $cached_result; } } static::_log_query($query, $this->_values); $statement = static::$_db->prepare($query); try { $statement->execute($this->_values); } catch (Exception $e) { echo $query; print_r($e); exit; } $rows = array(); while ($row = $statement->fetch(PDO::FETCH_ASSOC)) { $rows[] = $row; } if ($caching_enabled) { static::_cache_query_result($cache_key, $rows); } return $rows; } public function as_array() { if (func_num_args() === 0) { return $this->_data; } $args = func_get_args(); return array_intersect_key($this->_data, array_flip($args)); } public function get($key) { return isset($this->_data[$key]) ? $this->_data[$key] : null; } protected function _get_id_column_name() { if (!is_null($this->_instance_id_column)) { return $this->_instance_id_column; } if (isset(static::$_config['id_column_overrides'][$this->_table_name])) { return static::$_config['id_column_overrides'][$this->_table_name]; } else { return static::$_config['id_column']; } } public function id() { return $this->get($this->_get_id_column_name()); } public function set($key, $value) { $this->_data[$key] = $value; $this->_dirty_fields[$key] = $value; } public function is_dirty($key) { return isset($this->_dirty_fields[$key]); } public function save() { $query = array(); $values = array_values($this->_dirty_fields); if (!$this->_is_new) { if (count($values) == 0) { return true; } $query = $this->_build_update(); $values[] = $this->id(); } else { $query = $this->_build_insert(); } static::_log_query($query, $values); $statement = static::$_db->prepare($query); $success = $statement->execute($values); if ($this->_is_new) { $this->_is_new = false; if (is_null($this->id())) { $this->_data[$this->_get_id_column_name()] = self::$_db->lastInsertId(); } } $this->_dirty_fields = array(); return $success; } protected function _build_update() { $query = array(); $query[] = "UPDATE {$this->_quote_identifier($this->_table_name)} SET"; $field_list = array(); foreach ($this->_dirty_fields as $key => $value) { $field_list[] = "{$this->_quote_identifier($key)} = ?"; } $query[] = join(", ", $field_list); $query[] = "WHERE"; $query[] = $this->_quote_identifier($this->_get_id_column_name()); $query[] = "= ?"; return join(" ", $query); } protected function _build_insert() { $query[] = "INSERT INTO"; $query[] = $this->_quote_identifier($this->_table_name); $field_list = array_map(array($this, '_quote_identifier'), array_keys($this->_dirty_fields)); $query[] = "(" . join(", ", $field_list) . ")"; $query[] = "VALUES"; $placeholders = $this->_create_placeholders(count($this->_dirty_fields)); $query[] = "({$placeholders})"; return join(" ", $query); } public function delete() { $query = join(" ", array( "DELETE FROM", $this->_quote_identifier($this->_table_name), "WHERE", $this->_quote_identifier($this->_get_id_column_name()), "= ?", )); $params = array($this->id()); static::_log_query($query, $params); $statement = static::$_db->prepare($query); return $statement->execute($params); } public function __get($key) { return $this->get($key); } public function __set($key, $value) { $this->set($key, $value); } public function __isset($key) { return isset($this->_data[$key]); } }  class ORMWrapper extends ORM { protected $_class_name; public function set_class_name($class_name) { $this->_class_name = $class_name; } public function filter() { $args = func_get_args(); $filter_function = array_shift($args); array_unshift($args, $this); if (method_exists($this->_class_name, $filter_function)) { return call_user_func_array(array($this->_class_name, $filter_function), $args); } } public static function for_table($table_name) { static::_setup_db(); return new static($table_name); } protected function _create_model_instance($orm) { if ($orm === false) { return false; } $model = new $this->_class_name(); $model->set_orm($orm); return $model; } public function find_one($id=null) { return $this->_create_model_instance(parent::find_one($id)); } public function find_many() { return array_map(array($this, '_create_model_instance'), parent::find_many()); } public function create($data=null) { return $this->_create_model_instance(parent::create($data)); } } class Model { const DEFAULT_ID_COLUMN = 'id'; const DEFAULT_FOREIGN_KEY_SUFFIX = '_id'; public $orm; protected static function _get_static_property($class_name, $property, $default=null) { if (!class_exists($class_name) || !property_exists($class_name, $property)) { return $default; } $properties = get_class_vars($class_name); return $properties[$property]; } protected static function _get_table_name($class_name) { $specified_table_name = static::_get_static_property($class_name, '_table'); if (is_null($specified_table_name)) { return static::_class_name_to_table_name($class_name); } return $specified_table_name; } protected static function _class_name_to_table_name($class_name) { return strtolower(preg_replace('/(?<=[a-z])([A-Z])/', '_$1', $class_name)); } protected static function _get_id_column_name($class_name) { return static::_get_static_property($class_name, '_id_column', static::DEFAULT_ID_COLUMN); } protected static function _build_foreign_key_name($specified_foreign_key_name, $table_name) { if (!is_null($specified_foreign_key_name)) { return $specified_foreign_key_name; } return $table_name . static::DEFAULT_FOREIGN_KEY_SUFFIX; } public static function factory($class_name) { $table_name = static::_get_table_name($class_name); $wrapper = ORMWrapper::for_table($table_name); $wrapper->set_class_name($class_name); $wrapper->use_id_column(static::_get_id_column_name($class_name)); return $wrapper; } protected function _has_one_or_many($associated_class_name, $foreign_key_name=null) { $base_table_name = static::_get_table_name(get_class($this)); $foreign_key_name = static::_build_foreign_key_name($foreign_key_name, $base_table_name); return static::factory($associated_class_name)->where($foreign_key_name, $this->id()); } protected function has_one($associated_class_name, $foreign_key_name=null) { return $this->_has_one_or_many($associated_class_name, $foreign_key_name); } protected function has_many($associated_class_name, $foreign_key_name=null) { return $this->_has_one_or_many($associated_class_name, $foreign_key_name); } protected function belongs_to($associated_class_name, $foreign_key_name=null) { $associated_table_name = static::_get_table_name($associated_class_name); $foreign_key_name = static::_build_foreign_key_name($foreign_key_name, $associated_table_name); $associated_object_id = $this->$foreign_key_name; return static::factory($associated_class_name)->where_id_is($associated_object_id); } protected function has_many_through($associated_class_name, $join_class_name=null, $key_to_base_table=null, $key_to_associated_table=null) { $base_class_name = get_class($this); if (is_null($join_class_name)) { $class_names = array($base_class_name, $associated_class_name); sort($class_names, SORT_STRING); $join_class_name = join("", $class_names); } $base_table_name = static::_get_table_name($base_class_name); $associated_table_name = static::_get_table_name($associated_class_name); $join_table_name = static::_get_table_name($join_class_name); $base_table_id_column = static::_get_id_column_name($base_class_name); $associated_table_id_column = static::_get_id_column_name($associated_class_name); $key_to_base_table = static::_build_foreign_key_name($key_to_base_table, $base_table_name); $key_to_associated_table = static::_build_foreign_key_name($key_to_associated_table, $associated_table_name); return static::factory($associated_class_name) ->select("{$associated_table_name}.*") ->join($join_table_name, array("{$associated_table_name}.{$associated_table_id_column}", '=', "{$join_table_name}.{$key_to_associated_table}")) ->where("{$join_table_name}.{$key_to_base_table}", $this->id()); } public function set_orm($orm) { $this->orm = $orm; } public function __get($property) { if (!is_object($this->orm)) { echo "<pre>"; debug_print_backtrace(); echo "</pre>"; } return $this->orm->get($property); } public function __set($property, $value) { $this->orm->set($property, $value); } public function __isset($property) { return $this->orm->__isset($property); } public function get($property) { if (!$this->orm) { debug_print_backtrace(); return null; } return $this->orm->get($property); } public function set($property, $value) { if (!$this->orm) { debug_print_backtrace(); } $this->orm->set($property, $value); } public function is_dirty($property) { return $this->orm->is_dirty($property); } public function as_array() { $args = func_get_args(); return call_user_func_array(array($this->orm, 'as_array'), $args); } public function save() { return $this->orm->save(); } public function delete() { return $this->orm->delete(); } public function id() { return $this->orm->id(); } public function hydrate($data) { $this->orm->hydrate($data)->force_all_dirty(); } }  class BDb { protected static $_namedConnections = array(); protected static $_namedConnectionConfig = array(); protected static $_defaultConnectionName = 'DEFAULT'; protected static $_currentConnectionName; protected static $_config = array('table_prefix'=>''); protected static $_tables = array(); public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public static function connect($name=null) { if (!$name && static::$_currentConnectionName) { return BORM::get_db(); } if (is_null($name)) { $name = static::$_defaultConnectionName; } if ($name===static::$_currentConnectionName) { return BORM::get_db(); } if (!empty(static::$_namedConnections[$name])) { BDebug::debug('DB.SWITCH '.$name); static::$_currentConnectionName = $name; static::$_config = static::$_namedConnectionConfig[$name]; BORM::set_db(static::$_namedConnections[$name], static::$_config); return BORM::get_db(); } $config = BConfig::i()->get($name===static::$_defaultConnectionName ? 'db' : 'db/named/'.$name); if (!$config) { throw new BException(BLocale::_('Invalid or missing DB configuration: %s', $name)); } if (!empty($config['use'])) { static::connect($config['use']); return BORM::get_db(); } if (!empty($config['dsn'])) { $dsn = $config['dsn']; if (empty($config['dbname']) && preg_match('#dbname=(.*?)(;|$)#', $dsn, $m)) { $config['dbname'] = $m[1]; } } else { if (empty($config['dbname'])) { throw new BException(BLocale::_("dbname configuration value is required for '%s'", $name)); } $engine = !empty($config['engine']) ? $config['engine'] : 'mysql'; $host = !empty($config['host']) ? $config['host'] : '127.0.0.1'; switch ($engine) { case "mysql": $dsn = "mysql:host={$host};dbname={$config['dbname']};charset=UTF8"; break; default: throw new BException(BLocale::_('Invalid DB engine: %s', $engine)); } } $profile = BDebug::debug('DB.CONNECT '.$name); static::$_currentConnectionName = $name; BORM::configure($dsn); BORM::configure('username', !empty($config['username']) ? $config['username'] : 'root'); BORM::configure('password', !empty($config['password']) ? $config['password'] : ''); BORM::configure('logging', !empty($config['logging'])); BORM::set_db(null); BORM::setup_db(); static::$_namedConnections[$name] = BORM::get_db(); static::$_config = static::$_namedConnectionConfig[$name] = array( 'dbname' => !empty($config['dbname']) ? $config['dbname'] : null, 'table_prefix' => !empty($config['table_prefix']) ? $config['table_prefix'] : '', ); $db = BORM::get_db(); BDebug::profile($profile); return $db; } public static function now() { return gmstrftime('%Y-%m-%d %H:%M:%S'); } public static function run($sql, $params=null, $options=array()) { BDb::connect(); $queries = preg_split("/;+(?=([^'|^\\\']*['|\\\'][^'|^\\\']*['|\\\'])*[^'|^\\\']*[^'|^\\\']$)/", $sql); $results = array(); foreach ($queries as $i=>$query){ if (strlen(trim($query)) > 0) { try { BDebug::debug('DB.RUN: '.$query); if (!empty($options['echo'])) { echo '<hr><pre>'.$query.'<pre>'; } if (is_null($params)) { $results[] = BORM::get_db()->exec($query); } else { $results[] = BORM::get_db()->prepare($query)->execute($params); } } catch (Exception $e) { echo "<hr>{$e->getMessage()}: <pre>{$query}</pre>"; if (empty($options['try'])) { throw $e; } } } } return $results; } public static function transaction($connectionName=null) { if (!is_null($connectionName)) { BDb::connect($connectionName); } BORM::get_db()->beginTransaction(); } public static function commit($connectionName=null) { if (!is_null($connectionName)) { BDb::connect($connectionName); } BORM::get_db()->commit(); } public static function rollback($connectionName=null) { if (!is_null($connectionName)) { BDb::connect($connectionName); } BORM::get_db()->rollback(); } public static function t($tableName) { $a = explode('.', $tableName); $p = static::$_config['table_prefix']; return !empty($a[1]) ? $a[0].'.'.$p.$a[1] : $p.$a[0]; } public static function many_as_array($rows, $method='as_array', $fields=null, $maskInverse=false) { $res = array(); foreach ((array)$rows as $i=>$r) { if (!$r instanceof BModel) { echo "Rows are not models: <pre>"; print_r($r); debug_print_backtrace(); exit; } $row = $r->$method(); if (!is_null($fields)) $row = BUtil::arrayMask($row, $fields, $maskInverse); $res[$i] = $row; } return $res; } public static function where($conds, $or=false) { if (is_string($conds)) { return array($conds, array()); } if (!is_array($conds)) { throw new BException("Invalid where parameter"); } $where = array(); $params = array(); foreach ($conds as $f=>$v) { if (is_int($f)) { if (is_string($v)) { $where[] = '('.$v.')'; continue; } if (is_array($v)) { $sql = array_shift($v); if ('AND'===$sql || 'OR'===$sql || 'NOT'===$sql) { $f = $sql; } else { if (isset($v[0]) && is_array($v[0])) { $v = $v[0]; $sql = str_replace('(?)', '('.str_pad('', sizeof($v)*2-1, '?,').')', $sql); } $where[] = '('.$sql.')'; $params = array_merge($params, $v); continue; } } else { throw new BException('Invalid token: '.print_r($v,1)); } } if ('AND'===$f) { list($w, $p) = static::where($v); $where[] = '('.$w.')'; $params = array_merge($params, $p); } elseif ('OR'===$f) { list($w, $p) = static::where($v, true); $where[] = '('.$w.')'; $params = array_merge($params, $p); } elseif ('NOT'===$f) { list($w, $p) = static::where($v); $where[] = 'NOT ('.$w.')'; $params = array_merge($params, $p); } elseif (is_array($v)) { $where[] = "({$f} IN (".str_pad('', sizeof($v)*2-1, '?,')."))"; $params = array_merge($params, $v); } elseif (is_null($v)) { $where[] = "({$f} IS NULL)"; } else { $where[] = "({$f}=?)"; $params[] = $v; } } return array(join($or ? " OR " : " AND ", $where), $params); } public static function dbName() { if (!static::$_config) { throw new BException('No connection selected'); } return !empty(static::$_config['dbname']) ? static::$_config['dbname'] : null; } public static function ddlStart() { BDb::run(<<<EOT
/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
EOT
); } public static function ddlFinish() { BDb::run(<<<EOT
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
EOT
); } public static function ddlClearCache($fullTableName=null) { if ($fullTableName) { if (!static::dbName()) { static::connect(static::$_defaultConnectionName); } $a = explode('.', $fullTableName); $dbName = empty($a[1]) ? static::dbName() : $a[0]; $tableName = empty($a[1]) ? $fullTableName : $a[1]; static::$_tables[$dbName][$tableName] = null; } else { static::$_tables = array(); } } public static function ddlTableExists($fullTableName) { if (!static::dbName()) { static::connect(static::$_defaultConnectionName); } $a = explode('.', $fullTableName); $dbName = empty($a[1]) ? static::dbName() : $a[0]; $tableName = empty($a[1]) ? $fullTableName : $a[1]; if (!isset(static::$_tables[$dbName])) { $tables = BORM::i()->raw_query("SHOW TABLES FROM `{$dbName}`", array())->find_many(); $field = "Tables_in_{$dbName}"; foreach ($tables as $t) { static::$_tables[$dbName][$t->$field] = array(); } } elseif (!isset(static::$_tables[$dbName][$tableName])) { $table = BORM::i()->raw_query("SHOW TABLES FROM `{$dbName}` LIKE ?", array($tableName))->find_one(); if ($table) { static::$_tables[$dbName][$tableName] = array(); } } return isset(static::$_tables[$dbName][$tableName]); } public static function ddlFieldInfo($fullTableName, $fieldName=null) { self::checkTable($fullTableName); $a = explode('.', $fullTableName); $dbName = empty($a[1]) ? static::dbName() : $a[0]; $tableName = empty($a[1]) ? $fullTableName : $a[1]; if (!isset(static::$_tables[$dbName][$tableName]['fields'])) { static::$_tables[$dbName][$tableName]['fields'] = BORM::i() ->raw_query("SHOW FIELDS FROM `{$dbName}`.`{$tableName}`", array())->find_many_assoc('Field'); } $res = static::$_tables[$dbName][$tableName]['fields']; return is_null($fieldName) ? $res : (isset($res[$fieldName]) ? $res[$fieldName] : null); } protected static function checkTable($fullTableName) { if (!static::ddlTableExists($fullTableName)) { throw new BException(BLocale::_('Invalid table name: %s', $fullTableName)); } } public static function ddlIndexInfo($fullTableName, $indexName=null) { if (!static::ddlTableExists($fullTableName)) { throw new BException(BLocale::_('Invalid table name: %s', $fullTableName)); } $a = explode('.', $fullTableName); $dbName = empty($a[1]) ? static::dbName() : $a[0]; $tableName = empty($a[1]) ? $fullTableName : $a[1]; if (!isset(static::$_tables[$dbName][$tableName]['indexes'])) { static::$_tables[$dbName][$tableName]['indexes'] = BORM::i() ->raw_query("SHOW KEYS FROM `{$dbName}`.`{$tableName}`", array())->find_many_assoc('Key_name'); } $res = static::$_tables[$dbName][$tableName]['indexes']; return is_null($indexName) ? $res : (isset($res[$indexName]) ? $res[$indexName] : null); } public static function ddlForeignKeyInfo($fullTableName, $fkName=null) { if (!static::ddlTableExists($fullTableName)) { throw new BException(BLocale::_('Invalid table name: %s', $fullTableName)); } $a = explode('.', $fullTableName); $dbName = empty($a[1]) ? static::dbName() : $a[0]; $tableName = empty($a[1]) ? $fullTableName : $a[1]; if (!isset(static::$_tables[$dbName][$tableName]['fks'])) { static::$_tables[$dbName][$tableName]['fks'] = BORM::i() ->raw_query("SELECT * FROM information_schema.TABLE_CONSTRAINTS
                    WHERE TABLE_SCHEMA='{$dbName}' AND TABLE_NAME='{$tableName}'
                        AND CONSTRAINT_TYPE='FOREIGN KEY'", array())->find_many_assoc('CONSTRAINT_NAME'); } $res = static::$_tables[$dbName][$tableName]['fks']; return is_null($fkName) ? $res : (isset($res[$fkName]) ? $res[$fkName] : null); } public static function ddlTableDef($fullTableName, $def) { $fields = !empty($def['COLUMNS']) ? $def['COLUMNS'] : null; $primary = !empty($def['PRIMARY']) ? $def['PRIMARY'] : null; $indexes = !empty($def['KEYS']) ? $def['KEYS'] : null; $fks = !empty($def['CONSTRAINTS']) ? $def['CONSTRAINTS'] : null; $options = !empty($def['OPTIONS']) ? $def['OPTIONS'] : null; if (!static::ddlTableExists($fullTableName)) { if (!$fields) { throw new BException('Missing fields definition for new table'); } $fieldsArr = array(); foreach ($fields as $f=>$def) { $fieldsArr[] = $f.' '.$def; } $fields = null; if ($primary) { $fieldsArr[] = "PRIMARY KEY ".$primary; $primary = null; } $engine = !empty($options['engine']) ? $options['engine'] : 'InnoDB'; $charset = !empty($options['charset']) ? $options['charset'] : 'utf8'; $collate = !empty($options['collate']) ? $options['collate'] : 'utf8_general_ci'; BORM::i()->raw_query("CREATE TABLE {$fullTableName} (".join(', ', $fieldsArr).")
                ENGINE={$engine} DEFAULT CHARSET={$charset} COLLATE={$collate}", array())->execute(); } static::ddlTableColumns($fullTableName, $fields, $indexes, $fks, $options); static::ddlClearCache(); } public static function ddlTable($fullTableName, $fields, $options=null) { if (static::ddlTableExists($fullTableName)) { static::ddlTableColumns($fullTableName, $fields, null, null, $options); } else { $fieldsArr = array(); foreach ($fields as $f=>$def) { $fieldsArr[] = $f.' '.$def; } if (!empty($options['primary'])) { $fieldsArr[] = "PRIMARY KEY ".$options['primary']; } $engine = !empty($options['engine']) ? $options['engine'] : 'InnoDB'; $charset = !empty($options['charset']) ? $options['charset'] : 'utf8'; $collate = !empty($options['collate']) ? $options['collate'] : 'utf8_general_ci'; BORM::i()->raw_query("CREATE TABLE {$fullTableName} (".join(', ', $fieldsArr).")
                ENGINE={$engine} DEFAULT CHARSET={$charset} COLLATE={$collate}", array())->execute(); static::ddlClearCache(); } return true; } public static function ddlTableColumns($fullTableName, $fields, $indexes=null, $fks=null) { $tableFields = static::ddlFieldInfo($fullTableName, null); $alterArr = array(); if ($fields) { foreach ($fields as $f=>$def) { if ($def==='DROP') { if (!empty($tableFields[$f])) { $alterArr[] = "DROP `{$f}`"; } } elseif (empty($tableFields[$f])) { $alterArr[] = "ADD `{$f}` {$def}"; } else { if (strpos($def, 'RENAME')===0) { $a = explode(' ', $def, 3); $colName = $a[1]; $def = $a[2]; } else { $colName = $f; } $alterArr[] = "CHANGE `{$f}` `{$colName}` {$def}"; } } } if ($indexes) { $tableIndexes = static::ddlIndexInfo($fullTableName); foreach ($indexes as $idx=>$def) { if ($def==='DROP') { if (!empty($tableIndexes[$idx])) { $alterArr[] = "DROP KEY `{$idx}`"; } } else { if (!empty($tableIndexes[$idx])) { $alterArr[] = "DROP KEY `{$idx}`"; } if (strpos($def, 'PRIMARY')===0) { $alterArr[] = "DROP PRIMARY KEY"; $def = substr($def, 7); $alterArr[] = "ADD PRIMARY KEY `{$idx}` {$def}"; } elseif (strpos($def, 'UNIQUE')===0) { $def = substr($def, 6); $alterArr[] = "ADD UNIQUE KEY `{$idx}` {$def}"; } else { $alterArr[] = "ADD KEY `{$idx}` {$def}"; } } } } if ($fks) { $tableFKs = static::ddlForeignKeyInfo($fullTableName); $dropArr = array(); foreach ($fks as $idx=>$def) { if ($def==='DROP') { if (!empty($tableFKs[$idx])) { $dropArr[] = "DROP FOREIGN KEY `{$idx}`"; } } else { if (!empty($tableFKs[$idx])) { $dropArr[] = "DROP FOREIGN KEY `{$idx}`"; } $alterArr[] = "ADD CONSTRAINT `{$idx}` {$def}"; } } if (!empty($dropArr)) { BORM::i()->raw_query("ALTER TABLE {$fullTableName} ".join(", ", $dropArr), array())->execute(); static::ddlClearCache(); } } $result = null; if ($alterArr) { $result = BORM::i()->raw_query("ALTER TABLE {$fullTableName} ".join(", ", $alterArr), array())->execute(); static::ddlClearCache(); } return $result; } public static function ddlAddColumns($table, $columns = array()) { if (empty($columns)) { BDebug::log(__METHOD__ . ": columns array is empty."); return null; } $pass = array(); $tableFields = array_keys(static::ddlFieldInfo($table)); foreach ($columns as $field => $def) { if( in_array($field, $tableFields)) { continue; } $pass[$field] = $def; } return static::ddlTableColumns($table, $pass); } public static function cleanForTable($table, $data) { $isObject = is_object($data); $result = array(); foreach ($data as $k=>$v) { if (BDb::ddlFieldInfo($table, $k)) { $result[$k] = $isObject ? $data->get($k) : $data[$k]; } } return $result; } } class BPDO extends PDO { protected static $_savepointTransactions = array("pgsql", "mysql"); protected $_transLevel = 0; protected function _nestable() { return in_array($this->getAttribute(PDO::ATTR_DRIVER_NAME), static::$_savepointTransactions); } public function beginTransaction() { if (!$this->_nestable() || $this->_transLevel == 0) { parent::beginTransaction(); } else { $this->exec("SAVEPOINT LEVEL{$this->_transLevel}"); } $this->_transLevel++; } public function commit() { $this->_transLevel--; if (!$this->_nestable() || $this->_transLevel == 0) { parent::commit(); } else { $this->exec("RELEASE SAVEPOINT LEVEL{$this->_transLevel}"); } } public function rollBack() { $this->_transLevel--; if (!$this->_nestable() || $this->_transLevel == 0) { parent::rollBack(); } else { $this->exec("ROLLBACK TO SAVEPOINT LEVEL{$this->_transLevel}"); } } } class BORM extends ORMWrapper { protected static $_instance; protected static $_last_profile; protected $_class_name = 'BModel'; protected $_readConnectionName; protected $_writeConnectionName; protected $_readDbName; protected $_writeDbName; protected $_old_values = array(); public static function i($new=false) { if ($new) { return new static(''); } if (!static::$_instance) { static::$_instance = new static(''); } return static::$_instance; } protected function _quote_identifier($identifier) { if ($identifier[0]=='(') { return $identifier; } return parent::_quote_identifier($identifier); } public static function get_config($key) { return !empty(static::$_config[$key]) ? static::$_config[$key] : null; } public static function setup_db() { static::_setup_db(); } protected static function _setup_db() { if (!is_object(static::$_db)) { $connection_string = static::$_config['connection_string']; $username = static::$_config['username']; $password = static::$_config['password']; $driver_options = static::$_config['driver_options']; if (empty($driver_options[PDO::MYSQL_ATTR_INIT_COMMAND])) { $driver_options[PDO::MYSQL_ATTR_INIT_COMMAND] = "SET NAMES utf8"; } try { $db = new BPDO($connection_string, $username, $password, $driver_options); } catch (PDOException $e) { if (BDebug::is('DEBUG')) { throw $e; } else { throw new PDOException('Could not connect to database'); } } $db->setAttribute(PDO::ATTR_ERRMODE, static::$_config['error_mode']); static::set_db($db); } } public static function set_db($db, $config=null) { if (!is_null($config)) { static::$_config = array_merge(static::$_config, $config); } static::$_db = $db; if (!is_null($db)) { static::_setup_identifier_quote_character(); } } public function set_rw_db_names($read, $write) { $this->_readDbName = $read; $this->_writeDbName = $write; return $this; } protected static function _log_query($query, $parameters) { $result = parent::_log_query($query, $parameters); static::$_last_profile = BDebug::debug('DB.RUN: '.(static::$_last_query ? static::$_last_query : 'LOGGING NOT ENABLED')); return $result; } protected function _run() { BDb::connect($this->_readConnectionName); $result = parent::_run(); BDebug::profile(static::$_last_profile); static::$_last_profile = null; return $result; } public function table_alias($alias=null) { if (is_null($alias)) { return $this->_table_alias; } $this->_table_alias = $alias; return $this; } public function select($column, $alias=null) { if (is_array($column)) { foreach ($column as $k=>$v) { $col = (!is_null($alias) ? $alias.'.' : '').$v; if (is_int($k)) { $this->select($col); } else { $this->select($col, $k); } } return $this; } return parent::select($column, $alias); } protected $_use_index = array(); public function use_index($index, $type='USE', $table='_') { $this->_use_index[$table] = compact('index', 'type'); return $this; } protected function _build_select_start() { $fragment = parent::_build_select_start(); if (!empty($this->_use_index['_'])) { $idx = $this->_use_index['_']; $fragment .= ' '.$idx['type'].' INDEX ('.$idx['index'].') '; } return $fragment; } protected function _add_result_column($expr, $alias=null) { if (!is_null($alias)) { $expr .= " AS " . $this->_quote_identifier($alias); } if (in_array($expr, $this->_result_columns)) { return $this; } if ($this->_using_default_result_columns) { $this->_result_columns = array($expr); $this->_using_default_result_columns = false; } else { $this->_result_columns[] = $expr; } return $this; } public function clear_columns() { $this->_result_columns = array(); return $this; } public function as_sql() { return $this->_build_select(); } public function execute() { BDb::connect($this->_readConnectionName); $query = $this->_build_select(); static::_log_query($query, $this->_values); $statement = static::$_db->prepare($query); try { $statement->execute($this->_values); } catch (Exception $e) { echo $query; print_r($e); exit; } return $statement; } public function row_to_model($row) { return $this->_create_model_instance($this->_create_instance_from_row($row)); } public function iterate($callback, $type='callback') { $statement = $this->execute(); while ($row = $statement->fetch(PDO::FETCH_ASSOC)) { $model = $this->row_to_model($row); switch ($type) { case 'callback': call_user_func($callback, $model); break; case 'method': $model->$callback(); break; } } return $this; } public function where($column_name, $value=null) { if (is_array($column_name)) { return $this->where_complex($column_name, !!$value); } return parent::where($column_name, $value); } public function where_complex($conds, $or=false) { list($where, $params) = BDb::where($conds, $or); if (!$where) { return $this; } return $this->where_raw($where, $params); } public function find_one($id=null) { $class = $this->_class_name; if ($class::origClass()) { $class = $class::origClass(); } BEvents::i()->fire($class.'::find_one:orm', array('orm'=>$this, 'class'=>$class, 'id'=>$id)); $result = parent::find_one($id); BEvents::i()->fire($class.'::find_one:after', array('result'=>&$result, 'class'=>$class, 'id'=>$id)); return $result; } public function find_many() { $class = $this->_class_name; if ($class::origClass()) { $class = $class::origClass(); } BEvents::i()->fire($class.'::find_many:orm', array('orm'=>$this, 'class'=>$class)); $result = parent::find_many(); BEvents::i()->fire($class.'::find_many:after', array('result'=>&$result, 'class'=>$class)); return $result; } public function find_many_assoc($key=null, $labelColumn=null, $options=array()) { $objects = $this->find_many(); $array = array(); if (empty($key)) { $key = $this->_get_id_column_name(); } foreach ($objects as $r) { $value = is_null($labelColumn) ? $r : (is_array($labelColumn) ? BUtil::arrayMask($r, $labelColumn) : $r->get($labelColumn)); if (!is_array($key)) { $v = $r->get($key); if (!empty($options['key_lower'])) $v = strtolower($v); if (!empty($options['key_trim'])) $v = trim($v); $array[$v] = $value; } else { $v1 = $r->get($key[0]); if (!empty($options['key_lower'])) $v1 = strtolower($v1); if (!empty($options['key_trim'])) $v1 = trim($v1); $v2 = $r->get($key[1]); if (!empty($options['key_lower'])) $v2 = strtolower($v2); if (!empty($options['key_trim'])) $v1 = trim($v2); $array[$v1][$v2] = $value; } } return $array; } public function is_dirty($key=null) { return is_null($key) ? !empty($this->_dirty_fields) : isset($this->_dirty_fields[$key]); } public function set($key, $value) { if (!is_scalar($key)) { throw new BException('Key not scalar'); } if (!array_key_exists($key, $this->_data) || is_null($this->_data[$key]) && !is_null($value) || !is_null($this->_data[$key]) && is_null($value) || is_scalar($this->_data[$key]) && is_scalar($value) && ((string)$this->_data[$key] !== (string)$value) ) { if (!array_key_exists($key, $this->_old_values)) { $this->_old_values[$key] = array_key_exists($key, $this->_data) ? $this->_data[$key] : BNULL; } $this->_dirty_fields[$key] = $value; } $this->_data[$key] = $value; } protected static $_classTableMap = array(); public function _add_join_source($join_operator, $table, $constraint, $table_alias=null) { if (!isset(self::$_classTableMap[$table])) { if (class_exists($table) && is_subclass_of($table, 'BModel')) { $class = BClassRegistry::i()->className($table); self::$_classTableMap[$table] = $class::table(); } else { self::$_classTableMap[$table] = false; } } if (self::$_classTableMap[$table]) { $table = self::$_classTableMap[$table]; } return parent::_add_join_source($join_operator, $table, $constraint, $table_alias); } public function save() { BDb::connect($this->_writeConnectionName); $this->_dirty_fields = BDb::cleanForTable($this->_table_name, $this->_dirty_fields); if (true) { $result = parent::save(); } else { echo $this->_class_name.'['.$this->id.']: '; print_r($this->_data); echo 'FROM: '; print_r($this->_old_values); echo 'TO: '; print_r($this->_dirty_fields); echo "\n\n"; $result = true; } return $result; } public function dirty_fields() { return $this->_dirty_fields; } public function old_values($property='') { if ($property && isset($this->_old_values[$property])) { return $this->_old_values[$property]; } return $this->_old_values; } public function delete() { BDb::connect($this->_writeConnectionName); return parent::delete(); } public function order_by_expr($expression) { $this->_order_by[] = "{$expression}"; return $this; } public function raw_query($query, $parameters=array()) { if (preg_match('#^\s*(SELECT|SHOW)#i', $query)) { BDb::connect($this->_readConnectionName); } else { BDb::connect($this->_writeConnectionName); } return parent::raw_query($query, $parameters); } protected static function _get_table_name($class_name) { return BDb::t(parent::_get_table_name($class_name)); } public function paginate($r=null, $d=array()) { if (is_null($r)) { $r = BRequest::i()->request(); } $d = (array)$d; if (!empty($r['sc']) && empty($r['s']) && empty($r['sd'])) { list($r['s'], $r['sd']) = preg_split('#[| ]#', trim($r['sc'])); } if (!empty($r['s']) && !empty($d['s']) && is_array($d['s'])) { if (!in_array($r['s'], $d['s'])) $r['s'] = null; $d['s'] = null; } if (!empty($r['sd']) && $r['sd']!='asc' && $r['sd']!='desc') { $r['sd'] = null; } $s = array( 'p' => !empty($r['p']) && is_numeric($r['p']) ? $r['p'] : (isset($d['p']) ? $d['p'] : 1), 'ps' => !empty($r['ps']) && is_numeric($r['ps']) ? $r['ps'] : (isset($d['ps']) ? $d['ps'] : 100), 's' => !empty($r['s']) ? $r['s'] : (isset($d['s']) ? $d['s'] : ''), 'sd' => !empty($r['sd']) ? $r['sd'] : (isset($d['sd']) ? $d['sd'] : 'asc'), 'rs' => !empty($r['rs']) ? $r['rs'] : null, 'rc' => !empty($r['rc']) ? $r['rc'] : null, 'q' => !empty($r['q']) ? $r['q'] : null, 'c' => !empty($d['c']) ? $d['c'] : null, ); $s['sc'] = $s['s'].' '.$s['sd']; if (empty($s['c'])){ $cntOrm = clone $this; $s['c'] = $cntOrm->count(); unset($cntOrm); } $s['mp'] = ceil($s['c']/$s['ps']); if (($s['p']-1)*$s['ps']>$s['c']) $s['p'] = $s['mp']; if ($s['s']) $this->{'order_by_'.$s['sd']}($s['s']); $s['rs'] = max(0, isset($s['rs']) ? $s['rs'] : ($s['p']-1)*$s['ps']); if(empty($d['donotlimit'])){ $this->offset($s['rs'])->limit(!empty($s['rc']) ? $s['rc'] : $s['ps']); } $rows = $this->find_many(); $s['rc'] = $rows ? sizeof($rows) : 0; if (!empty($d['as_array'])) { $rows = BDb::many_as_array($rows, is_string($d['as_array']) ? $d['as_array'] : 'as_array'); } if (!empty($d['format'])) { switch ($d['format']) { case 1: return $rows; case 2: $s['rows'] = $rows; return $s; } } return array('state'=>$s, 'rows'=>$rows); } public function jqGridData($r=null, $d=array()) { if (is_null($r)) { $r = BRequest::i()->request(); } if (!empty($r['rows'])) { $data = $this->paginate(array( 'p' => !empty($r['page']) ? $r['page'] : null, 'ps' => !empty($r['rows']) ? $r['rows'] : null, 's' => !empty($r['sidx']) ? $r['sidx'] : null, 'sd' => !empty($r['sord']) ? $r['sord'] : null, ), $d); } else { $data = $this->paginate($r, $d); } $res = $data['state']; $res['rows'] = $data['rows']; if (empty($d['as_array'])) { $res['rows'] = BDb::many_as_array($res['rows']); } return $res; } public function __destruct() { unset($this->_data); } } class BModel extends Model { static protected $_origClass; protected static $_connectionName = 'DEFAULT'; protected static $_readConnectionName = null; protected static $_writeConnectionName = null; protected static $_tableNames = array(); protected static $_cacheAuto = false; protected static $_cacheFlags = array(); protected static $_cache = array(); protected static $_instanceCache = array(); protected $_newRecord; public static function origClass() { return static::$_origClass; } public static function readDb() { return BDb::connect(static::$_readConnectionName ? static::$_readConnectionName : static::$_connectionName); } public static function writeDb() { return BDb::connect(static::$_writeConnectionName ? static::$_writeConnectionName : static::$_connectionName); } public static function factory($class_name=null) { if (is_null($class_name)) { $class_name = get_called_class(); } $class_name = BClassRegistry::i()->className($class_name); static::readDb(); $table_name = static::_get_table_name($class_name); $orm = BORM::for_table($table_name); $orm->set_class_name($class_name); $orm->use_id_column(static::_get_id_column_name($class_name)); $orm->set_rw_db_names( static::$_readConnectionName ? static::$_readConnectionName : static::$_connectionName, static::$_writeConnectionName ? static::$_writeConnectionName : static::$_connectionName ); $orm->table_alias('_main'); return $orm; } public static function orm($alias=null) { $orm = static::factory(); if ($alias) { $orm->table_alias($alias); } static::_findOrm($orm); return $orm; } protected static function _findOrm($orm) { } public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(get_called_class(), $args, !$new); } public function set($key, $value=null, $flag=false) { if (is_array($key)) { foreach ($key as $k=>$v) { parent::set($k, $v); } } else { if (true===$flag) { $oldValue = $this->get($key); if (is_array($oldValue)) { $oldValue[] = $value; $value = $oldValue; } else { $value += $oldValue; } } if (is_scalar($key) && (!is_null($flag) || is_null($this->get($key)))) { parent::set($key, $value); } } return $this; } public function add($key, $increment=1) { return $this->set($key, $increment, true); } public static function create($data=null) { $record = static::factory()->create($data); $record->onAfterCreate(); return $record; } public function onAfterCreate() { BEvents::i()->fire($this->_origClass().'::onAfterCreate', array('model' => $this)); return $this; } protected function _origClass() { return static::$_origClass ? static::$_origClass : get_class($this); } protected static function _loadORM($orm) { } public static function load($id, $field=null, $cache=false) { $class = static::$_origClass ? static::$_origClass : get_called_class(); if (is_null($field)) { $field = static::_get_id_column_name($class); } if (is_array($id)) { ksort($id); $field = join(',', array_keys($id)); $keyValue = join(',', array_values($id)); } else { $keyValue = $id; } if (!empty(static::$_cacheFlags[$field]['key_lower'])) { $keyValue = strtolower($keyValue); } if (!empty(static::$_cache[$class][$field][$keyValue])) { return static::$_cache[$class][$field][$keyValue]; } $orm = static::factory(); static::_loadORM($orm); BEvents::i()->fire($class.'::load:orm', array('orm'=>$orm, 'class'=>$class, 'called_class'=>get_called_class())); if (is_array($id)) { $orm->where_complex($id); } else { if (strpos($field, '.')===false && ($alias = $orm->table_alias())) { $field = $alias.'.'.$field; } $orm->where($field, $id); } $model = $orm->find_one(); if ($model) { $model->onAfterLoad(); if ($cache || static::$_cacheAuto===true || is_array(static::$_cacheAuto) && in_array($field, static::$_cacheAuto) ) { $model->cacheStore(); } } return $model; } public function onAfterLoad() { BEvents::i()->fire($this->_origClass().'::onAfterLoad', array('model'=>$this)); return $this; } public function mapAfterLoad($arr) { foreach ($arr as $r) { $r->onAfterLoad(); } return $this; } public function cacheClear() { static::$_cache[$this->_origClass()] = array(); return $this; } public function cachePreload($where=null, $field=null, $sort=null) { $orm = static::factory(); $class = $this->_origClass(); if (is_null($field)) { $field = static::_get_id_column_name($class); } $cache =& static::$_cache[$class]; if ($where) $orm->where_complex($where); if ($sort) $orm->order_by_asc($sort); $options = !empty(static::$_cacheFlags[$field]) ? static::$_cacheFlags[$field] : array(); $cache[$field] = $orm->find_many_assoc($field, null, $options); return $this; } public function cachePreloadFrom($collection, $fk='id', $lk='id') { if (!$collection) return $this; $class = $this->_origClass(); $keyValues = array(); $keyLower = !empty(static::$_cacheFlags[$lk]['key_lower']); foreach ($collection as $r) { $key = null; if (is_object($r)) { $keyValue = $r->get($fk); } elseif (is_array($r)) { $keyValue = isset($r[$fk]) ? $r[$fk] : null; } elseif (is_scalar($r)) { $keyValue = $r; } if (empty($keyValue)) continue; if ($keyLower) $keyValue = strtolower($keyValue); if (!empty(static::$_cache[$class][$lk][$keyValue])) continue; $keyValues[$keyValue] = 1; } $field = (strpos($lk, '.')===false ? '_main.' : '').$lk; if ($keyValues) $this->cachePreload(array($field=>array_keys($keyValues)), $lk); return $this; } public function cacheCopy($toKey, $fromKey='id') { $cache =& static::$_cache[$this->_origClass()]; $lower = !empty(static::$_cacheFlags[$toKey]['key_lower']); foreach ($cache[$fromKey] as $r) { $keyValue = $r->get($toKey); if ($lower) $keyValue = strtolower($keyValue); $cache[$toKey][$keyValue] = $r; } return $this; } public function cacheSaveDirty($field='id') { $class = $this->_origClass(); if (!empty(static::$_cache[$class][$field])) { foreach (static::$_cache[$class][$field] as $c) { if ($c->is_dirty()) { $c->save(); } } } return $this; } public function cacheFetch($field='id', $keyValue=null) { $class = $this->_origClass(); if (empty(static::$_cache[$class])) return null; $cache = static::$_cache[$class]; if (empty($cache[$field])) return null; if (is_null($keyValue)) return $cache[$field]; if (!empty(static::$_cacheFlags[$field]['key_lower'])) $keyValue = strtolower($keyValue); return !empty($cache[$field][$keyValue]) ? $cache[$field][$keyValue] : null; } public function cacheStore($field='id', $collection=null) { $cache =& static::$_cache[$this->_origClass()]; if ($collection) { foreach ($collection as $r) { $r->cacheStore($field); } return $this; } if (is_array($field)) { foreach ($field as $k) { $this->cacheStore($k); } return $this; } if (strpos($field, ',')) { $keyValueArr = array(); foreach (explode(',', $field) as $k) { $keyValueArr[] = $this->get($k); } $keyValue = join(',', $keyValueArr); } else { $keyValue = $this->get($field); } if (!empty(static::$_cacheFlags[$field]['key_lower'])) $keyValue = strtolower($keyValue); $cache[$field][$keyValue] = $this; return $this; } public function onBeforeSave() { BEvents::i()->fire($this->origClass().'::onBeforeSave', array('model'=>$this)); return true; } public function dirty_fields() { return $this->orm->dirty_fields(); } public function is_dirty($property=null) { return $this->orm->is_dirty($property); } public function old_values($property='') { return $this->orm->old_values($property); } public function save($callBeforeAfter=true) { if ($callBeforeAfter) { try { if (!$this->onBeforeSave()) { return $this; } } catch (BModelException $e) { return $this; } } $this->_newRecord = !$this->get(static::_get_id_column_name(get_called_class())); parent::save(); if ($callBeforeAfter) { $this->onAfterSave(); } if (static::$_cacheAuto) { $this->cacheStore(); } return $this; } public function onAfterSave() { BEvents::i()->fire($this->_origClass().'::onAfterSave', array('model'=>$this)); return $this; } public function isNewRecord() { return $this->_newRecord; } public function onBeforeDelete() { BEvents::i()->fire($this->_origClass().'::onBeforeDelete', array('model'=>$this)); return true; } public function delete() { try { if (!$this->onBeforeDelete()) { return $this; } } catch(BModelException $e) { return $this; } if (($cache =& static::$_cache[$this->_origClass()])) { foreach ($cache as $k=>$c) { $keyValue = $this->get($k); if (!empty(static::$_cacheFlags[$k]['key_lower'])) $keyValue = strtolower($keyValue); unset($cache[$k][$keyValue]); } } parent::delete(); $this->onAfterDelete(); return $this; } public function onAfterDelete() { BEvents::i()->fire($this->_origClass().'::onAfterDelete', array('model'=>$this)); return $this; } public static function run_sql($sql, $params=array()) { return static::writeDb()->prepare($sql)->execute((array)$params); } public static function table() { $class = BClassRegistry::i()->className(get_called_class()); if (empty(static::$_tableNames[$class])) { static::$_tableNames[$class] = static::_get_table_name($class); } return static::$_tableNames[$class]; } public static function overrideTable($table) { static::$_table = $table; $class = get_called_class(); BDebug::debug('OVERRIDE TABLE: '.$class.' -> '.$table); static::$_tableNames[$class] = null; $class = BClassRegistry::i()->className($class); static::$_tableNames[$class] = null; } public static function update_many(array $data, $where, $p=array()) { $update = array(); $params = array(); foreach ($data as $k=>$v) { $update[] = "`{$k}`=?"; $params[] = $v; } if (is_array($where)) { list($where, $p) = BDb::where($where); } $sql = "UPDATE ".static::table()." SET ".join(', ', $update) ." WHERE {$where}"; BDebug::debug('SQL: '.$sql); return static::run_sql($sql, array_merge($params, $p)); } public static function delete_many($where, $params=array()) { if (is_array($where)) { list($where, $params) = BDb::where($where); } $sql = "DELETE FROM ".static::table()." WHERE {$where}"; BDebug::debug('SQL: '.$sql); return static::run_sql($sql, $params); } public function as_array(array $objHashes=array()) { $objHash = spl_object_hash($this); if (!empty($objHashes[$objHash])) { return "*** RECURSION: ".get_class($this); } $objHashes[$objHash] = 1; $data = parent::as_array(); foreach ($data as $k=>$v) { if ($v instanceof Model) { $data[$k] = $v->as_array(); } elseif (is_array($v) && current($v) instanceof Model) { foreach ($v as $k1=>$v1) { $data[$k][$k1] = $v1->as_array($objHashes); } } } return $data; } public function instanceCache($key, $value=null) { $thisHash = spl_object_hash($this); if (null===$value) { return isset(static::$_instanceCache[$thisHash][$key]) ? static::$_instanceCache[$thisHash][$key] : null; } static::$_instanceCache[$thisHash][$key] = $value; return $this; } public function saveInstanceCache($key, $value) { $thisHash = spl_object_hash($this); static::$_instanceCache[$thisHash][$key] = $value; return $this; } public function loadInstanceCache($key) { $thisHash = spl_object_hash($this); return isset(static::$_instanceCache[$thisHash][$key]) ? static::$_instanceCache[$thisHash][$key] : null; } public function relatedModel($modelClass, $idValue, $autoCreate=false, $cacheKey=null, $foreignIdField='id') { $cacheKey = $cacheKey ? $cacheKey : $modelClass; $model = $this->loadInstanceCache($cacheKey); if (is_null($model)) { if (is_array($idValue)) { $model = $modelClass::i()->factory()->where_complex($idValue)->find_one(); if ($model) $model->afterLoad(); } else { $model = $modelClass::i()->load($idValue); } if ($autoCreate && !$model) { if (is_array($idValue)) { $model = $modelClass::i()->create($idValue); } else { $model = $modelClass::i()->create(array($foreignIdField=>$idValue)); } } $this->saveInstanceCache($cacheKey, $model); } return $model; } public function relatedCollection($modelClass, $where) { } public function childById($var, $id, $idField='id') { $collection = $this->get($var); if (!$collection){ $collection = $this->{$var}; if (!$collection) return null; } foreach ($collection as $k=>$v) { if ($v->get($idField)==$id) return $v; } return null; } public function __destruct() { if ($this->orm) { $class = $this->_origClass(); if (!empty(static::$_cache[$class])) { foreach (static::$_cache[$class] as $key=>$cache) { $keyValue = $this->get($key); if (!empty($cache[$keyValue])) { unset(static::$_cache[$class][$keyValue]); } } } unset(static::$_instanceCache[spl_object_hash($this)]); } } public function fieldOptions($field=null, $key=null) { if (is_null($field)) { return static::$_fieldOptions; } if (!isset(static::$_fieldOptions[$field])) { BDebug::warning('Invalid field options type: '.$field); return null; } $options = static::$_fieldOptions[$field]; if (!is_null($key)) { if (!isset($options[$key])) { BDebug::debug('Invalid field options key: '.$field.'.'.$key); return null; } return $options[$key]; } return $options; } public function __call($name, $args) { return BClassRegistry::i()->callMethod($this, $name, $args, static::$_origClass); } public static function __callStatic($name, $args) { return BClassRegistry::i()->callStaticMethod(get_called_class(), $name, $args, static::$_origClass); } } class BCollection extends BData { protected $_orm; public function setOrm($orm) { $this->_orm = $orm; return $this; } public function load($assoc = false) { $method = $assoc ? 'find_many_assoc' : 'find_many'; $this->_data = $this->_orm->$method(); return $this; } public function modelsAsArray() { return BDb::many_as_array($this->_data); } } class BModelUser extends BModel { protected static $_sessionUser; protected static $_sessionUserNamespace = 'user'; public static function sessionUserId() { $userId = BSession::i()->data(static::$_sessionUserNamespace.'_id'); return $userId ? $userId : false; } public static function sessionUser($reset=false) { if (!static::isLoggedIn()) { return false; } $session = BSession::i(); if ($reset || !static::$_sessionUser) { static::$_sessionUser = static::load(static::sessionUserId()); } return static::$_sessionUser; } public static function isLoggedIn() { return static::sessionUserId() ? true : false; } public function setPassword($password) { $this->password_hash = BUtil::fullSaltedHash($password); return $this; } public function validatePassword($password) { return BUtil::validateSaltedHash($password, $this->password_hash); } public function onBeforeSave() { if (!parent::onBeforeSave()) return false; if (!$this->create_at) $this->create_at = BDb::now(); $this->update_at = BDb::now(); if ($this->password) { $this->password_hash = BUtil::fullSaltedHash($this->password); } return true; } static public function authenticate($username, $password) { $user = static::orm()->where(array('OR'=>array('username'=>$username, 'email'=>$username)))->find_one(); if (!$user || !$user->validatePassword($password)) { return false; } return $user; } public function login() { $this->set('last_login', BDb::now())->save(); BSession::i()->data(array( static::$_sessionUserNamespace.'_id' => $this->id, static::$_sessionUserNamespace => serialize($this->as_array()), )); static::$_sessionUser = $this; if ($this->locale) { setlocale(LC_ALL, $this->locale); } if ($this->timezone) { date_default_timezone_set($this->timezone); } BEvents::i()->fire(__METHOD__.':after', array('user'=>$this)); return $this; } public function authorize($role, $args=null) { if (is_null($args)) { return true; } return $this; } public static function logout() { BSession::i()->data(static::$_sessionUserNamespace.'_id', false); static::$_sessionUser = null; BEvents::i()->fire(__METHOD__.':after', array('user' => $this)); } public function recoverPassword($emailView='email/user-password-recover') { $this->set(array('password_nonce'=>BUtil::randomString(20)))->save(); if (($view = BLayout::i()->view($emailView))) { $view->set('user', $this)->email(); } return $this; } public function resetPassword($password, $emailView='email/user-password-reset') { $this->set(array('password_nonce'=>null))->setPassword($password)->save()->login(); if (($view = BLayout::i()->view($emailView))) { $view->set('user', $this)->email(); } return $this; } public static function signup($r) { $r = (array)$r; if (empty($r['email']) || empty($r['password']) || empty($r['password_confirm']) || $r['password']!=$r['password_confirm'] ) { throw new Exception('Incomplete or invalid form data.'); } $r = BUtil::arrayMask($r, 'email,password'); $user = static::create($r)->save(); if (($view = BLayout::i()->view('email/user-new-user'))) { $view->set('user', $user)->email(); } if (($view = BLayout::i()->view('email/admin-new-user'))) { $view->set('user', $user)->email(); } return $user; } } class BModelException extends BException { }  class BCache extends BClass { protected $_backends = array(); protected $_backendStatus = array(); protected $_defaultBackend; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function __construct() { foreach (array('File','Shmop','Apc','Memcache','Db') as $type) { $this->addBackend($type, 'BCache_Backend_'.$type); } } public function addBackend($type, $backend) { $type = strtolower($type); if (is_string($backend)) { if (!class_exists($backend)) { throw new BException('Invalid cache backend class name: '.$backend.' ('.$type.')'); } $backend = $backend::i(); } if (!is_object($backend)) { throw new BException('Invalid backend for type: '.$type); } if (!$backend instanceof BCache_Backend_Interface) { throw new BException('Invalid cache backend class interface: '.$type); } $this->_backends[$type] = $backend; return $this; } public function getBackend($type=null) { if (is_null($type)) { if (empty($this->_defaultBackend)) { $minRank = 1000; $fastest = null; foreach ($this->_backends as $t => $backend) { $info = $backend->info(); if (empty($info['available'])) { continue; } if ($info['rank'] < $minRank) { $minRank = $info['rank']; $fastest = $t; } } $this->_defaultBackend = $fastest; } $type = $this->_defaultBackend; } $type = strtolower($type); $backend = $this->_backends[$type]; if (empty($this->_backendStatus[$type])) { $info = $backend->info(); if (empty($info['available'])) { throw new BException('Cache backend is not available: '.$type); } $config = (array)BConfig::i()->get('cache/'.$type); $backend->init($config); $this->_backendsStatus[$type] = true; } return $this->_backends[$type]; } public function load($key) { return $this->getBackend()->load($key); } public function loadMany($pattern) { return $this->getBackend()->loadMany($pattern); } public function save($key, $data, $ttl=null) { return $this->getBackend()->save($key, $data, $ttl); } public function delete($key) { return $this->getBackend()->delete($key); } public function gc() { return $this->getBackend()->gc(); } } interface BCache_Backend_Interface { public function info(); public function init($config = array()); public function load($key); public function save($key, $data, $ttl = null); public function delete($key); public function loadMany($pattern); public function deleteMany($pattern); public function gc(); } class BCache_Backend_File extends BClass implements BCache_Backend_Interface { protected $_config = array(); public function info() { return array('available' => true, 'rank' => 70); } public function init($config = array()) { if (empty($config['dir'])) { $config['dir'] = BConfig::i()->get('fs/cache_dir'); } if (!is_writable($config['dir'])) { $config['dir'] = sys_get_temp_dir().'/fulleron/'.md5(__DIR__).'/cache'; } if (empty($config['default_ttl'])) { $config['default_ttl'] = 3600; } $this->_config = $config; return true; } protected function _filename($key) { $md5 = md5($key); return $this->_config['dir'].'/'.substr($md5, 0, 2).'/'.BUtil::simplifyString($key).'.'.substr($md5, 0, 10).'.dat'; } public function load($key) { $filename = $this->_filename($key); if (!file_exists($filename)) { return null; } $fp = fopen($filename, 'r'); $meta = @unserialize(fgets($fp, 1024)); if (!$meta || $meta['ttl'] !== false && $meta['ts'] + $meta['ttl'] < time()) { fclose($fp); @unlink($filename); return null; } for ($data = ''; $chunk = fread($fp, 4096); $data .= $chunk); fclose($fp); return $data; } public function save($key, $data, $ttl = null) { $filename = $this->_filename($key); $dir = dirname($filename); BUtil::ensureDir($dir); $meta = array( 'ts' => time(), 'ttl' => !is_null($ttl) ? $ttl : $this->_config['default_ttl'], 'key' => $key, ); file_put_contents($filename, serialize($meta)."\n".serialize($data)); return true; } public function delete($key) { $filename = $this->_filename($key); if (!file_exists($filename)) { return false; } @unlink($filename); return true; } public function loadMany($pattern) { $files = glob($this->_config['dir'].'/*/*'.BUtil::simplifyString($pattern).'*'); if (!$files) { return array(); } $result = array(); foreach ($files as $filename) { $fp = fopen($filename, 'r'); $meta = unserialize(fgets($fp, 1024)); if (!$meta || $meta['ttl'] !== false && $meta['ts'] + $meta['ttl'] < time()) { fclose($fp); @unlink($filename); continue; } if (strpos($meta['key'], $pattern)!==false) { for ($data = ''; $chunk = fread($fp, 4096); $data .= $chunk); $result[$meta['key']] = $data; } fclose($fp); } return $result; } public function deleteMany($pattern) { if ($pattern===true || $pattern===false) { $files = glob($this->_config['dir'].'/*/*'); } else { $files = glob($this->_config['dir'].'/*/*'.BUtil::simplifyString($pattern).'*'); } if (!$files) { return false; } $result = array(); foreach ($files as $filename) { if ($pattern===true) { @unlink($filename); continue; } $fp = fopen($filename, 'r'); $meta = unserialize(fgets($fp, 1024)); fclose($fp); if (!$meta || $meta['ttl'] !== false && $meta['ts'] + $meta['ttl'] < time() || $pattern===false || strpos($meta['key'], $pattern)!==false ) { @unlink($filename); } } return true; } public function gc() { $this->deleteMany(false); return true; } } class BCache_Backend_Apc extends BClass implements BCache_Backend_Interface { protected $_config; public function info() { return array('available' => function_exists('apc_fetch'), 'rank' => 10); } public function init($config = array()) { if (empty($config['prefix'])) { $config['prefix'] = substr(md5(__DIR__), 0, 16).'/'; } if (empty($config['default_ttl'])) { $config['default_ttl'] = 3600; } $this->_config = $config; return true; } public function load($key) { $fullKey = $this->_config['prefix'].$key; return apc_fetch($fullKey); } public function save($key, $data, $ttl = null) { $ttl = !is_null($ttl) ? $ttl : $this->_config['default_ttl']; $cacheKey = $this->_config['prefix'].$key; return apc_store($cacheKey, $data, (int)$ttl); } public function delete($key) { return apc_delete($this->_config['prefix'].$key); } public function loadMany($pattern) { $items = new APCIterator('user'); $prefix = $this->_config['prefix']; $result = array(); foreach ($items as $item) { $key = $item['key']; if (strpos($key, $prefix)!==0) { continue; } if ($pattern===true || strpos($key, $pattern)!==false) { $result[$key] = apc_fetch($key); } } return $result; } public function deleteMany($pattern) { if ($pattern===false) { return false; } $items = new APCIterator('user'); $prefix = $this->_config['prefix']; foreach ($items as $item) { $key = $item['key']; if (strpos($key, $prefix)!==0) { continue; } if ($pattern===true || strpos($key, $pattern)!==false) { apc_delete($key); } } return true; } public function gc() { return true; } } class BCache_Backend_Memcache extends BClass implements BCache_Backend_Interface { protected $_config; protected $_conn; public function info() { return array('available' => class_exists('Memcache', false), 'rank' => 10); } public function init($config = array()) { if (empty($config['prefix'])) { $config['prefix'] = substr(md5(__DIR__), 0, 16).'/'; } if (empty($config['host'])) { $config['host'] = 'localhost'; } if (empty($config['port'])) { $config['port'] = 11211; } $this->_config = $config; $this->_flags = !empty($config['compress']) ? MEMCACHE_COMPRESSED : 0; $this->_conn = new Memcache; return $this->_conn->pconnect($config['host'], $config['port']); } public function load($key) { return $this->_conn->get($this->_config['prefix'].$key); } public function save($key, $data, $ttl = null) { $flag = !empty($this->_config['compress']) ? MEMCACHE_COMPRESSED : 0; $ttl1 = is_null($ttl) ? 0 : time()+$ttl; return $this->_conn->set($this->_config['prefix'].$key, $data, $flag, $ttl1); } public function delete($key) { return $this->_conn->delete($this->_config['prefix'].$key); } public function loadMany($pattern) { return false; } public function deleteMany($pattern) { return false; } public function gc() { return false; } } class BCache_Backend_Db extends BClass implements BCache_Backend_Interface { public function info() { $avail = (boolean)BConfig::i()->get('db/dbname'); return array('available' => $avail, 'rank' => 90); } public function init($config = array()) { $this->migrate(); } public function load($key) { $cache = BCache_Backend_Db_Model_Cache::i()->load($key, 'cache_key'); if (!$cache) { return null; } if ($cache->get('expires_at')<time()) { $cache->delete(); return null; } return unserialize($cache->get('cache_value')); } public function save($key, $data, $ttl = null) { $hlp = BCache_Backend_Db_Model_Cache::i(); $cache = $hlp->load($key, 'cache_key'); if (!$cache) { $cache = $hlp->create(array('cache_key' => $key)); } $cache->set(array( 'expires_at' => is_null($ttl) ? null : time()+$ttl, 'cache_value' => serialize($data), ))->save(); return true; } public function delete($key) { BCache_Backend_Db_Model_Cache::i()->delete_many(array('cache_key' => $key)); return true; } public function loadMany($pattern) { return false; } public function deleteMany($pattern) { return false; } public function gc() { BCache_Backend_Db_Model_Cache::i()->delete_many('expires_at<'.time()); return true; } public function migrate() { $t = BCache_Backend_Db_Model_Cache::table(); if (!BDb::ddlTableExists($t)) { BDb::ddlTableDef($t, array( 'COLUMNS' => array( 'id' => 'int unsigned not null auto_increment', 'cache_key' => 'varchar(255) not null', 'cache_value' => 'mediumtext not null', 'expires_at' => 'int unsigned null', ), 'PRIMARY' => '(id)', 'KEYS' => array( 'UNQ_cache_key' => '(cache_key)', 'IDX_expires_at' => '(expires_at)', ), 'OPTIONS' => array( 'engine' => 'MyISAM', ), )); } } } class BCache_Backend_Db_Model_Cache extends BModel { static protected $_table = 'buckyball_cache'; static protected $_origClass = __CLASS__; } class BCache_Backend_Shmop extends BClass implements BCache_Backend_Interface { public function info() { return array('available' => false, 'rank' => 10); } public function init($config = array()) { } public function load($key) { } public function save($key, $data, $ttl = null) { } public function delete($key) { } public function loadMany($pattern) { } public function deleteMany($pattern) { } public function gc() { } }  class BModuleRegistry extends BClass { protected $_area; protected static $_modules = array(); protected static $_currentModuleName = null; protected static $_currentModuleStack = array(); public function __construct() { } public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public static function getAllModules() { return static::$_modules; } public static function isLoaded($modName) { return !empty(static::$_modules[$modName]) && static::$_modules[$modName]->run_status===BModule::LOADED; } public function module($modName, $params=null) { if (is_null($params)) { return isset(static::$_modules[$modName]) ? static::$_modules[$modName] : null; } return $this->addModule($modName, $params); } public function addModule($modName, $params) { if (is_callable($params)) { $params = array('bootstrap'=>array('callback'=>$params)); } else { $params = (array)$params; } if (!empty(static::$_modules[$modName])) { BDebug::debug('MODULE UPDATE: '.static::$_modules[$modName]->name); static::$_modules[$modName]->update($params); } else { $params['name'] = $modName; static::$_modules[$modName] = BModule::i(true, $params); } return $this; } protected function _getManifestCacheFilename() { $area = BApp::i()->get('area'); return BConfig::i()->get('fs/cache_dir').'/manifests'.($area ? '_'.$area : '').'.data'; } public function saveManifestCache() { $t = BDebug::debug('SAVE MANIFESTS'); $cacheFile = $this->_getManifestCacheFilename(); $data = array(); foreach (static::$_modules as $modName => $mod) { $data[$modName] = (array)$mod; } file_put_contents($cacheFile, serialize($data)); BDebug::profile($t); return true; } public function loadManifestCache() { $cacheFile = $this->_getManifestCacheFilename(); if (is_readable($cacheFile)) { $data = unserialize(file_get_contents($cacheFile)); foreach ($data as $modName => $params) { $this->addModule($modName, $params); } return true; } else { return false; } } public function scan($source) { if (!preg_match('/\.(json|yml|php)$/', $source)) { $source .= '/manifest.{json,yml,php}'; } $manifests = glob($source, GLOB_BRACE); BDebug::debug('MODULE.SCAN '.$source.': '.print_r($manifests, 1)); if (!$manifests) { return $this; } foreach ($manifests as $file) { $info = pathinfo($file); switch ($info['extension']) { case 'php': $manifest = include($file); break; case 'yml': $manifest = BYAML::i()->load($file); break; case 'json': $json = file_get_contents($file); $manifest = BUtil::fromJson($json); break; default: BDebug::error(BLocale::_("Unknown manifest file format: %s", $file)); } if (empty($manifest['modules']) && empty($manifest['include'])) { BDebug::error(BLocale::_("Invalid or empty manifest file: %s", $file)); } if (!empty($manifest['modules'])) { foreach ($manifest['modules'] as $modName=>$params) { $params['manifest_file'] = $file; $this->addModule($modName, $params); } } if (!empty($manifest['include'])) { $dir = dirname($file); foreach ($manifest['include'] as $include) { $this->scan($dir.'/'.$include); } } } return $this; } public function checkRequires() { $requestRunLevels = (array)BConfig::i()->get('module_run_levels/request'); foreach ($requestRunLevels as $modName=>$runLevel) { if (!empty(static::$_modules[$modName])) { static::$_modules[$modName]->run_level = $runLevel; } elseif ($runLevel===BModule::REQUIRED) { BDebug::warning('Module is required but not found: '.$modName); } } foreach (static::$_modules as $modName=>$mod) { if ($mod->run_level === BModule::REQUIRED) { $mod->run_status = BModule::PENDING; } if (!empty($mod->require['module'])) { foreach ($mod->require['module'] as &$req) { $reqMod = !empty(static::$_modules[$req['name']]) ? static::$_modules[$req['name']] : false; if (!$reqMod) { $mod->errors[] = array('type'=>'missing', 'mod'=>$req['name']); continue; } elseif ($reqMod->run_level===BModule::DISABLED) { $mod->errors[] = array('type'=>'disabled', 'mod'=>$req['name']); continue; } elseif (!empty($req['version'])) { $reqVer = $req['version']; if (!empty($reqVer['from']) && version_compare($reqMod->version, $reqVer['from'], '<') || !empty($reqVer['to']) && version_compare($reqMod->version, $reqVer['to'], '>') || !empty($reqVer['exclude']) && in_array($reqVer->version, (array)$reqVer['exclude']) ) { $mod->errors[] = array('type'=>'version', 'mod'=>$req['name']); continue; } } if (!in_array($req['name'], $mod->parents)) { $mod->parents[] = $req['name']; } if (!in_array($modName, $reqMod->children)) { $reqMod->children[] = $modName; } if ($mod->run_status===BModule::PENDING) { $reqMod->run_status = BModule::PENDING; } } unset($req); } if (!$mod->errors && $mod->run_level === BModule::REQUESTED) { $mod->run_status = BModule::PENDING; } } foreach (static::$_modules as $modName=>$mod) { if (!is_object($mod)) { var_dump($mod); exit; } if ($mod->errors && !$mod->errors_propagated) { $this->propagateDependErrors($mod); } elseif ($mod->run_status===BModule::PENDING) { $this->propagateDepends($mod); } } return $this; } public function propagateDependErrors($mod) { $mod->run_status = BModule::ERROR; $mod->errors_propagated = true; foreach ($mod->children as $childName) { if (empty(static::$_modules[$childName])) { continue; } $child = static::$_modules[$childName]; if ($child->run_level===BModule::REQUIRED && $child->run_status!==BModule::ERROR) { $this->propagateDependErrors($child); } } return $this; } public function propagateDepends($mod) { foreach ($mod->parents as $parentName) { if (empty(static::$_modules[$parentName])) { continue; } $parent = static::$_modules[$parentName]; if ($parent->run_status===BModule::PENDING) { continue; } $parent->run_status = BModule::PENDING; $this->propagateDepends($parent); } return $this; } public function detectCircularReferences($mod, $depPathArr = array()) { $circ = array(); if ($mod->parents) { foreach ($mod->parents as $p) { if (isset($depPathArr[$p])) { $found = false; $circPath = array(); foreach ($depPathArr as $k => $_) { if ($p === $k) { $found = true; } if ($found) { $circPath[] = $k; } } $circPath[] = $p; $circ[] = $circPath; } else { $depPathArr1 = $depPathArr; $depPathArr1[$p] = 1; $circ += $this->detectCircularReferences(static::$_modules[$p], $depPathArr1); } } } return $circ; } public function sortDepends() { $modules = static::$_modules; $circRefsArr = array(); foreach ($modules as $modName => $mod) { $circRefs = $this->detectCircularReferences($mod); if ($circRefs) { foreach ($circRefs as $circ) { $circRefsArr[join(' -> ', $circ)] = 1; $s = sizeof($circ); $mod1name = $circ[$s-1]; $mod2name = $circ[$s-2]; $mod1 = $modules[$mod1name]; $mod2 = $modules[$mod2name]; foreach ($mod1->parents as $i => $p) { if ($p === $mod2name) { unset($mod1->parents[$i]); } } foreach ($mod2->children as $i => $c) { if ($c === $mod1name) { unset($mod2->children[$i]); } } } } } foreach ($circRefsArr as $circRef => $_) { BDebug::warning('Circular reference detected: ' . $circRef); } foreach ($modules as $modName=>$mod) { $mod->children_copy = $mod->children; if ($mod->load_after) { foreach ($mod->load_after as $n) { if (empty($modules[$n])) { BDebug::notice('Invalid module name specified: '.$n); continue; } $mod->parents[] = $n; $modules[$n]->children[] = $mod->name; } } } $rootModules = array(); foreach ($modules as $modName=>$mod) { if (empty($mod->parents)) { $rootModules[] = $mod; } } $sorted = array(); while ($modules) { if (!$rootModules) { BDebug::warning('Circular reference detected, aborting module sorting'); return false; } $n = array_pop($rootModules); $sorted[$n->name] = $n; for ($i = count($n->children)-1; $i>=0; $i--) { $childModule = $modules[$n->children[$i]]; unset($n->children[$i]); unset($childModule->parents[array_search($n->name, $childModule->parents)]); if (!$childModule->parents) array_push($rootModules, $childModule); } unset($modules[$n->name]); } static::$_modules = $sorted; return $this; } public function processRequires() { $this->checkRequires(); $this->sortDepends(); return $this; } public function processDefaultConfig() { foreach (static::$_modules as $mod) { $mod->processDefaultConfig(); } return $this; } public function bootstrap() { foreach (static::$_modules as $mod) { $this->pushModule($mod->name); $mod->beforeBootstrap(); $this->popModule(); } foreach (static::$_modules as $mod) { $this->pushModule($mod->name); $mod->bootstrap(); $this->popModule(); } BEvents::i()->fire('BModuleRegistry::bootstrap:after'); return $this; } public function currentModule($name=null) { if (is_null($name)) { $name = static::currentModuleName(); return $name ? $this->module($name) : false; } static::$_currentModuleName = $name; return $this; } public function setCurrentModule($name) { static::$_currentModuleName = $name; return $this; } public function pushModule($name) { array_push(self::$_currentModuleStack, $name); return $this; } public function popModule() { array_pop(self::$_currentModuleStack); return $this; } static public function currentModuleName() { if (!empty(self::$_currentModuleStack)) { return self::$_currentModuleStack[sizeof(self::$_currentModuleStack)-1]; } return static::$_currentModuleName; } public function debug() { return static::$_modules; } } class BModule extends BClass { static protected $_env = array(); static protected $_defaultRunLevel = 'ONDEMAND'; static protected $_manifestCache = array(); public $name; public $run_level; public $run_status; public $before_bootstrap; public $bootstrap; public $version; public $db_connection_name; public $root_dir; public $view_root_dir; public $url_prefix; public $base_src; public $base_href; public $manifest_file; public $require = array(); public $parents = array(); public $children = array(); public $children_copy = array(); public $update; public $errors = array(); public $errors_propagated; public $description; public $migrate; public $load_after; public $auto_use; public $views; public $layout; public $routing; public $observe; public $provides; public $area; public $override; public $default_config; public $autoload; const DISABLED = 'DISABLED', ONDEMAND = 'ONDEMAND', REQUESTED = 'REQUESTED', REQUIRED = 'REQUIRED', IDLE = 'IDLE', PENDING = 'PENDING', LOADED = 'LOADED', ERROR = 'ERROR' ; protected static $_fieldOptions = array( 'run_level' => array( self::DISABLED => 'DISABLED', self::ONDEMAND => 'ONDEMAND', self::REQUESTED => 'REQUESTED', self::REQUIRED => 'REQUIRED', ), 'run_status' => array( self::IDLE => 'IDLE', self::PENDING => 'PENDING', self::LOADED => 'LOADED', self::ERROR => 'ERROR' ), ); public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public static function defaultRunLevel($runLevel) { static::$_defaultRunLevel = $runLevel; } public function __construct(array $args) { $args['area'] = BApp::i()->get('area'); $this->set($args); $args = $this->_processAreas($args); $m = $this->_getManifestData(); if (!empty($this->bootstrap) && empty($this->bootstrap['file'])) { $this->bootstrap['file'] = null; } if (empty($this->root_dir)) { $this->root_dir = $m['root_dir']; } if (!BUtil::isPathAbsolute($this->root_dir)) { if($m['root_dir'] != $this->root_dir) $this->root_dir = BUtil::normalizePath($m['root_dir'].'/'.$this->root_dir); else{ $this->root_dir = BUtil::normalizePath($this->root_dir); } } $this->run_level = static::$_defaultRunLevel; if (!isset($this->run_status)) { $this->run_status = BModule::IDLE; } $this->_normalizeManifestRequireFormat(); } protected function _normalizeManifestRequireFormat() { foreach ($this->require as $reqType => $req) { if (is_string($req)) { if (is_numeric($reqType)) { $this->require['module'] = array(array('name' => $req)); unset($this->require[$reqType]); } else { $this->require[$reqType] = array(array('name' => $req)); } } else if (is_array($req)) { foreach ($this->require[$reqType] as $reqMod => &$reqVer) { if (is_numeric($reqMod)) { $reqVer = array('name' => $reqVer); } elseif (is_string($reqVer) || is_float($reqVer)) { $from = ''; $to = ''; $reqVerAr = explode(";", (string)$reqVer); if (!empty($reqVerAr[0])) { $from = $reqVerAr[0]; } if (!empty($reqVerAr[1])) { $to = $reqVerAr[1]; } if (!empty($from)) { $reqVer = array('name' => $reqMod, 'version' => array('from' => $from, 'to' => $to)); } else { $reqVer = array('name' => $reqMod); } } } } } } protected function _processAreas() { if ($this->area && !empty($this->areas[$this->area])) { $areaParams = $this->areas[$this->area]; $areaParams['update'] = true; $this->update($areaParams); } return; } public function update(array $params) { if (empty($params['update'])) { $rootDir = $this->root_dir; $file = $this->bootstrap['file']; throw new BException(BLocale::_('Module is already registered: %s (%s)', array($modName, $rootDir.'/'.$file))); } unset($params['update']); foreach ($params as $k=>$v) { if (is_array($this->$k)) { $this->$k = array_merge_recursive((array)$this->$k, (array)$v); } else { $this->$k = $v; switch ($k) { case 'url_prefix': $this->base_href = BApp::baseUrl().($v ? '/'.$v : ''); break; } } } return $this; } protected function _getManifestData() { if (empty($this->manifest_file)) { $bt = debug_backtrace(); foreach ($bt as $i=>$t) { if (!empty($t['function']) && ($t['function']==='module' || $t['function']==='addModule')) { $t1 = $t; break; } } if (!empty($t1)) { $this->manifest_file = $t1['file']; } } $file = $this->manifest_file; if (empty(static::$_manifestCache[$file])) { static::$_manifestCache[$file] = array('root_dir' => str_replace('\\', '/', dirname($file))); } return static::$_manifestCache[$file]; } protected static function _initEnvData() { if (!empty(static::$_env)) { return; } $r = BRequest::i(); $c = BConfig::i(); static::$_env['doc_root'] = $r->docRoot(); static::$_env['web_root'] = $r->webRoot(); if (($rootDir = $c->get('fs/root_dir'))) { static::$_env['root_dir'] = str_replace('\\', '/', $rootDir); } else { static::$_env['root_dir'] = str_replace('\\', '/', $r->scriptDir()); } if (($baseSrc = $c->get('web/base_src'))) { static::$_env['base_src'] = $baseSrc; } else { static::$_env['base_src'] = static::$_env['web_root']; } if (($baseHref = $c->get('web/base_href'))) { static::$_env['base_href'] = $baseHref; } else { static::$_env['base_href'] = static::$_env['web_root']; } foreach (static::$_manifestCache as &$m) { $m['base_src'] = rtrim(static::$_env['base_src'], '/').str_replace(static::$_env['root_dir'], '', $m['root_dir']); } unset($m); } protected function _prepareModuleEnvData() { static::_initEnvData(); $m = static::$_manifestCache[$this->manifest_file]; if (empty($this->url_prefix)) { $this->url_prefix = ''; } if (empty($this->view_root_dir)) { $this->view_root_dir = $this->root_dir; } if (empty($this->base_src)) { $url = $m['base_src']; $url .= str_replace($m['root_dir'], '', $this->root_dir); $this->base_src = BUtil::normalizePath(rtrim($url, '/')); } if (empty($this->base_href)) { $this->base_href = static::$_env['base_href']; if (!empty($this->url_prefix)) { $this->base_href .= '/'.$this->url_prefix; } } } protected function _processAutoUse() { if (empty($this->auto_use)) { return; } $auto = array_flip((array)$this->auto_use); $area = BApp::i()->get('area'); $areaDir = str_replace('FCom_', '', $area); if (isset($auto['all']) || isset($auto['bootstrap'])) { if (method_exists($this->name.'_'.$areaDir, 'bootstrap')) { $this->bootstrap = array('callback' => $this->name.'_'.$areaDir.'::bootstrap'); } elseif (method_exists($this->name.'_Main', 'bootstrap')) { $this->bootstrap = array('callback' => $this->name.'_Main::bootstrap'); } elseif (method_exists($this->name, 'bootstrap')) { $this->bootstrap = array('callback' => $this->name.'::bootstrap'); } } if (isset($auto['all']) || isset($auto['views'])) { if (is_dir($this->root_dir.'/views')) { BLayout::i()->addAllViews($this->root_dir.'/views'); } if (is_dir($this->root_dir.'/'.$areaDir.'/views')) { BLayout::i()->addAllViews($this->root_dir.'/'.$areaDir.'/views'); } } if (isset($auto['all']) || isset($auto['layout'])) { if (file_exists($this->root_dir.'/layout.yml')) { BLayout::i()->loadLayoutAfterTheme($this->root_dir.'/layout.yml'); } if (file_exists($this->root_dir.'/'.$areaDir.'/layout.yml')) { BLayout::i()->loadLayoutAfterTheme($this->root_dir.'/'.$areaDir.'/layout.yml'); } } } protected function _processAutoload() { if (!empty($this->autoload)) { foreach ((array)$this->autoload as $al) { if (is_string($al)) { $al = array('root_dir'=>$al); } $this->autoload($al['root_dir'], !empty($al['callback']) ? $al['callback'] : null); } } } protected function _processProvides() { if (!empty($this->provides['themes'])) { foreach ($this->provides['themes'] as $name=>$params) { $params['module_name'] = $this->name; BLayout::i()->addTheme($name, $params); } } } protected function _processRouting() { if (empty($this->routing)) { return; } $hlp = BRouting::i(); foreach ($this->routing as $r) { $method = strtolower($r[0]); if (!isset($r[1]) || !isset($r[2])) { var_dump($this); exit; } $route = $r[1]; $callback = $r[2]; $args = isset($r[3]) ? $r[3] : array(); $name = isset($r[4]) ? $r[4] : null; $multiple = isset($r[5]) ? $r[5] : true; $hlp->$method($route, $callback, $args, $name, $multiple); } } protected function _processViews() { if (empty($this->views)) { return; } $hlp = BLayout::i(); foreach ($this->views as $v) { $viewName = strtolower($v[0]); $params = $v[1]; $hlp->addView($viewName, $params); } } protected function _processObserve() { if (empty($this->observe)) { return; } $hlp = BEvents::i(); foreach ($this->observe as $o) { $event = $o[0]; $callback = $o[1]; $args = !empty($o[2]) ? $o[2] : array(); $hlp->on($event, $callback, $args); } } protected function _processOverrides() { if (!empty($this->override['class'])) { $hlp = BClassRegistry::i(); foreach ($this->override['class'] as $o) { $hlp->overrideClass($o[0], $o[1]); } } } protected function _processTranslations() { $language = BSession::i()->data('_language'); if (!empty($language) && !empty($this->translations[$language])) { if (!is_array($this->translations[$language])) { $this->translations[$language] = array($this->translations[$language]); } foreach($this->translations[$language] as $file) { BLocale::addTranslationsFile($file); } } } public function autoload($rootDir='', $callback=null) { if (!$rootDir) { $rootDir = $this->root_dir; } elseif (!BUtil::isPathAbsolute($rootDir)) { $rootDir = $this->root_dir.'/'.$rootDir; } BClassAutoload::i(true, array( 'module_name' => $this->name, 'root_dir' => rtrim($rootDir, '/'), 'filename_cb' => $callback, )); return $this; } public function baseSrc($full=true) { $src = $this->base_src; if ($full) { $r = BRequest::i(); $scheme = $r->scheme(); if ($scheme=='http') { $scheme = ''; } else { $scheme .= ':'; } $src = $scheme.'//'.$r->httpHost().$src; } return $src; } public function baseHref($full=true) { $href = $this->base_href; if ($full) { $r = BRequest::i(); $scheme = $r->scheme(); if ($scheme=='http') { $scheme = ''; } else { $scheme .= ':'; } $href = $scheme.'://'.$r->httpHost().$href; } return $href; } public function baseDir() { $dir = $this->root_dir; return $dir; } public function runLevel($level=null, $updateConfig=false) { if (is_null($level)) { return $this->run_level; } return $this->setRunLevel($level, $updateConfig); } public function setRunLevel($level, $updateConfig=false) { $this->run_level = $level; if ($updateConfig) { BConfig::i()->set('module_run_levels/request/'.$this->name, $level); } return $this; } public function runStatus($status=null) { if (BNULL===$status) { return $this->run_status; } $this->run_status = $status; return $this; } public function setRunStatus($status) { $this->run_status = $status; return $this; } public function _($string, $args=array()) { $tr = dgettext($this->name, $string); if ($args) { $tr = BUtil::sprintfn($tr, $args); } return $tr; } public function set($key, $value=null) { if (is_array($key)) { foreach ($key as $k=>$v) { $this->$k = $v; } return $this; } $this->$key = $value; return $this; } public function processDefaultConfig() { if (!empty($this->default_config)) { BConfig::i()->add($this->default_config); } $this->_processProvides(); return $this; } public function beforeBootstrap() { if ($this->run_status !== BModule::PENDING) { return $this; } $this->_prepareModuleEnvData(); $this->_processOverrides(); if (empty($this->before_bootstrap)) { return $this; } $bb = $this->before_bootstrap; if (!is_array($bb)) { $bb = array('callback' => $bb); } if (!empty($bb['file'])) { $includeFile = BUtil::normalizePath($this->root_dir.'/'.$bb['file']); BDebug::debug('MODULE.BEFORE.BOOTSTRAP '.$includeFile); require_once ($includeFile); } if (!empty($bb['callback'])) { $start = BDebug::debug(BLocale::_('Start BEFORE bootstrap for %s', array($this->name))); call_user_func($bb['callback']); BDebug::profile($start); BDebug::debug(BLocale::_('End BEFORE bootstrap for %s', array($this->name))); } return $this; } public function bootstrap($force=false) { if ($this->run_status!==BModule::PENDING) { if ($force) { $this->_prepareModuleEnvData(); } else { return $this; } } $this->_processAutoload(); $this->_processTranslations(); $this->_processViews(); $this->_processAutoUse(); $this->_processRouting(); $this->_processObserve(); BEvents::i()->fire('BModule::bootstrap:before', array('module'=>$this)); if (!empty($this->bootstrap)) { if (!empty($this->bootstrap['file'])) { $includeFile = BUtil::normalizePath($this->root_dir.'/'.$this->bootstrap['file']); BDebug::debug('MODULE.BOOTSTRAP '.$includeFile); require_once ($includeFile); } if (!empty($this->bootstrap['callback'])) { $start = BDebug::debug(BLocale::_('Start bootstrap for %s', array($this->name))); call_user_func($this->bootstrap['callback']); BDebug::profile($start); BDebug::debug(BLocale::_('End bootstrap for %s', array($this->name))); } } $this->run_status = BModule::LOADED; return $this; } } class BMigrate extends BClass { protected static $_migratingModule; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public static function getMigrationData() { $migration = array(); foreach (BModuleRegistry::getAllModules() as $modName=>$mod) { if (empty($mod->migrate) && class_exists($mod->name.'_Migrate')) { $mod->migrate = $mod->name.'_Migrate'; } if ($mod->version && $mod->migrate) { $connName = $mod->db_connection_name ? $mod->db_connection_name : 'DEFAULT'; $migration[$connName][$modName] = array( 'code_version' => $mod->version, 'script' => $mod->migrate, 'run_status' => $mod->run_status, 'module_name' => $modName, 'connection_name' => $connName, ); } } return $migration; } public static function migrateModules($limitModules=false) { $modReg = BModuleRegistry::i(); $migration = static::getMigrationData(); if (!$migration) { return; } if (is_string($limitModules)) { $limitModules = explode(',', $limitModules); } foreach ($migration as $connectionName=>&$modules) { if ($limitModules) { foreach ($modules as $modName=>$mod) { if ((true===$limitModules && $mod['run_status']==='LOADED') || (is_array($limitModules) && in_array($modName, $limitModules)) ) { continue; } unset($modules[$modName]); } } BDb::connect($connectionName); BDbModule::i()->init(); $dbModules = BDbModule::i()->orm()->find_many(); foreach ($dbModules as $m) { if ($m->last_status==='INSTALLING') { $m->delete(); continue; } $modules[$m->module_name]['schema_version'] = $m->schema_version; } foreach ($modules as $modName=>$mod) { if (empty($mod['code_version'])) { continue; } if (!empty($mod['schema_version']) && $mod['schema_version'] === $mod['code_version']) { continue; } if (empty($mod['script'])) { BDebug::warning('No migration script found: '.$modName); continue; } $modReg->currentModule($modName); $script = $mod['script']; if (is_array($script)) { if (!empty($script['file'])) { $filename = BApp::m($modName)->root_dir.'/'.$script['file']; if (!file_exists($filename)) { BDebug::warning('Migration file not exists: '.$filename); continue; } require_once $filename; } $script = $script['callback']; } $module = $modReg->module($modName); static::$_migratingModule =& $mod; BDb::ddlClearCache(); BDebug::debug('DB.MIGRATE '.$script); if (is_callable($script)) { $result = call_user_func($script); } elseif (is_file($module->root_dir.'/'.$script)) { $result = include_once($module->root_dir.'/'.$script); } elseif (is_dir($module->root_dir.'/'.$script)) { } elseif (class_exists($script, true)) { if (method_exists($script, 'run')) { $script::i()->run(); } else { static::_runClassMethods($script); } } } } unset($modules); $modReg->currentModule(null); static::$_migratingModule = null; } protected static function _runClassMethods($class) { $methods = get_class_methods($class); $installs = array(); $upgrades = array(); foreach ($methods as $method) { if (preg_match('/^install__([0-9_]+)$/', $method, $m)) { $installs[] = array( 'method' => $method, 'to' => str_replace('_', '.', $m[1]) ); } elseif (preg_match('/^upgrade__([0-9_]+)__([0-9_]+)$/', $method, $m)) { $upgrades[] = array( 'method' => $method, 'from' => str_replace('_', '.', $m[1]), 'to' => str_replace('_', '.', $m[2]), ); } } usort($installs, function($a, $b) { return version_compare($a['to'], $b['to']); }); usort($upgrades, function($a, $b) { return version_compare($a['from'], $b['from']); }); end($installs); $install = current($installs); $instance = $class::i(); static::install($install['to'], array($instance, $install['method'])); foreach ($upgrades as $upgrade) { static::upgrade($upgrade['from'], $upgrade['to'], array($instance, $upgrade['method'])); } } public static function install($version, $callback) { $mod =& static::$_migratingModule; if (empty($mod['code_version'])) { return false; } if (!empty($mod['schema_version'])) { return true; } BDebug::debug(__METHOD__.': '.var_export($mod, 1)); $module = BDbModule::i()->create(array( 'module_name' => $mod['module_name'], 'schema_version' => $version, 'last_upgrade' => BDb::now(), 'last_status' => 'INSTALLING', ))->save(); try { if (is_callable($callback)) { $result = call_user_func($callback); } elseif (is_file($callback)) { $result = include $callback; } elseif (is_string($callback)) { BDb::run($callback); $result = null; } if (false===$result) { $module->delete(); return false; } $module->set(array('last_status'=>'INSTALLED'))->save(); $mod['schema_version'] = $version; } catch (Exception $e) { $module->delete(); throw $e; } return true; } public static function upgrade($fromVersion, $toVersion, $callback) { $mod =& static::$_migratingModule; if (empty($mod['code_version'])) { return false; } if (empty($mod['schema_version'])) { throw new BException(BLocale::_("Can't upgrade, module schema doesn't exist yet: %s", BModuleRegistry::currentModuleName())); } $schemaVersion = $mod['schema_version']; if (!BModuleRegistry::i()->isLoaded($mod['module_name'])) { return true; } if (version_compare($mod['code_version'], $toVersion, '<')) { return true; } if (version_compare($schemaVersion, $fromVersion, '>')) { return true; } $module = BDbModule::i()->load($mod['module_name'], 'module_name')->set(array( 'last_upgrade' => BDb::now(), 'last_status'=>'UPGRADING', ))->save(); try { if (is_callable($callback)) { $result = call_user_func($callback); } elseif (is_file($callback)) { $result = include $callback; } elseif (is_string($callback)) { BDb::run($callback); $result = null; } if (false===$result) { return false; } $mod['schema_version'] = $toVersion; $module->set(array( 'schema_version' => $toVersion, 'last_status' => 'UPGRADED', ))->save(); } catch (Exception $e) { $module->set(array('last_status'=>'ERROR'))->save(); throw $e; } return true; } public static function runUninstallScript($modName=null) { if (is_null($modName)) { $modName = BModuleRegistry::currentModuleName(); } $mod =& static::$_migratingModule; if (empty($mod['code_version'])) { return false; } if (empty($mod['schema_version'])) { return true; } $callback = $mod->uninstall_callback; if (is_callable($callback)) { call_user_func($callback); } elseif (is_file($callback)) { include $callback; } elseif (is_string($callback)) { BDb::run($callback); } BDbModule::i()->load($mod['module_name'], 'module_name')->delete(); return true; } } class BDbModule extends BModel { protected static $_table = 'buckyball_module'; public static function init() { $table = static::table(); if (!BDb::ddlTableExists($table)) { BDb::run("
CREATE TABLE {$table} (
id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
module_name VARCHAR(100) NOT NULL,
schema_version VARCHAR(20),
data_version varchar(20),
last_upgrade DATETIME,
last_status varchar(20),
UNIQUE (module_name)
) ENGINE=INNODB;
            "); } } }  class BRequest extends BClass { protected $_params = array(); public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function __construct() { $this->stripMagicQuotes(); if (!empty($_SERVER['ORIG_SCRIPT_NAME'])) { $_SERVER['ORIG_SCRIPT_NAME'] = str_replace('/index.php/index.php', '/index.php', $_SERVER['ORIG_SCRIPT_NAME']); } if (!empty($_SERVER['ORIG_SCRIPT_FILENAME'])) { $_SERVER['ORIG_SCRIPT_FILENAME'] = str_replace('/index.php/index.php', '/index.php', $_SERVER['ORIG_SCRIPT_FILENAME']); } } public static function ip() { return !empty($_SERVER['REMOTE_ADDR']) ? $_SERVER['REMOTE_ADDR'] : null; } public static function serverIp() { return !empty($_SERVER['SERVER_ADDR']) ? $_SERVER['SERVER_ADDR'] : null; } public static function serverName() { return !empty($_SERVER['SERVER_NAME']) ? $_SERVER['SERVER_NAME'] : null; } public static function httpHost($includePort = true) { if (empty($_SERVER['HTTP_HOST'])) { return null; } if ($includePort) { return $_SERVER['HTTP_HOST']; } $a = explode(':', $_SERVER['HTTP_HOST']); return $a[0]; } public static function httpPort() { return !empty($_SERVER['HTTP_PORT']) ? $_SERVER['HTTP_PORT'] : null; } public static function httpOrigin() { return !empty($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : null; } public static function https() { return !empty($_SERVER['HTTPS']); } public static function serverProtocol() { $protocol = "HTTP/1.0"; if(isset($_SERVER['SERVER_PROTOCOL']) && stripos($_SERVER['SERVER_PROTOCOL'],"HTTP") >= 0){ $protocol = $_SERVER['SERVER_PROTOCOL']; } return $protocol; } public static function scheme() { return static::https() ? 'https' : 'http'; } static public function language() { $langs = array(); if (isset($_SERVER['HTTP_ACCEPT_LANGUAGE'])) { preg_match_all('/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.[0-9]+))?/i', $_SERVER['HTTP_ACCEPT_LANGUAGE'], $lang_parse); if (count($lang_parse[1])) { $langs = array_combine($lang_parse[1], $lang_parse[4]); foreach ($langs as $lang => $val) { if ($val === '') $langs[$lang] = 1; } arsort($langs, SORT_NUMERIC); } } if (empty($langs)) { return false; } list($toplang) = each($langs); return substr($toplang, 0, 2); } public static function xhr() { return !empty($_SERVER['HTTP_X_REQUESTED_WITH']) && $_SERVER['HTTP_X_REQUESTED_WITH']=='XMLHttpRequest'; } public static function method() { return !empty($_SERVER['REQUEST_METHOD']) ? $_SERVER['REQUEST_METHOD'] : 'GET'; } public static function docRoot() { return !empty($_SERVER['DOCUMENT_ROOT']) ? str_replace('\\', '/', $_SERVER['DOCUMENT_ROOT']) : null; } public static function scriptName() { return !empty($_SERVER['SCRIPT_NAME']) ? str_replace('\\', '/', $_SERVER['SCRIPT_NAME']) : (!empty($_SERVER['ORIG_SCRIPT_NAME']) ? str_replace('\\', '/', $_SERVER['ORIG_SCRIPT_NAME']) : null); } public static function scriptFilename() { return !empty($_SERVER['SCRIPT_FILENAME']) ? str_replace('\\', '/', $_SERVER['SCRIPT_FILENAME']) : (!empty($_SERVER['ORIG_SCRIPT_FILENAME']) ? str_replace('\\', '/', $_SERVER['ORIG_SCRIPT_FILENAME']) : null); } public static function scriptDir() { return ($script = static::scriptFilename()) ? dirname($script) : null; } public static function webRoot($parentDepth=null) { $scriptName = static::scriptName(); if (empty($scriptName)) { return null; } $root = rtrim(str_replace(array('//', '\\'), array('/', '/'), dirname($scriptName)), '/'); if ($parentDepth) { $arr = explode('/', rtrim($root, '/')); $len = sizeof($arr)-$parentDepth; $root = $len>1 ? join('/', array_slice($arr, 0, $len)) : '/'; } return $root ? $root : '/'; } public static function baseUrl($forceSecure=null, $includeQuery=false) { if (is_null($forceSecure)) { $scheme = static::https() ? 'https:' : ''; } else { $scheme = $forceSecure ? 'https:' : ''; } $url = $scheme.'//'.static::serverName().static::webRoot(); if ($includeQuery && ($query = static::rawGet())) { $url .= '?'.$query; } return $url; } public static function path($offset, $length=null) { $pathInfo = !empty($_SERVER['PATH_INFO']) ? $_SERVER['PATH_INFO'] : (!empty($_SERVER['ORIG_PATH_INFO']) ? $_SERVER['ORIG_PATH_INFO'] : null); if (empty($pathInfo)) { return null; } $path = explode('/', ltrim($pathInfo, '/')); if (is_null($length)) { return isset($path[$offset]) ? $path[$offset] : null; } return join('/', array_slice($path, $offset, true===$length ? null : $length)); } public static function rawPath() { return !empty($_SERVER['PATH_INFO']) ? $_SERVER['PATH_INFO'] : (!empty($_SERVER['ORIG_PATH_INFO']) ? $_SERVER['ORIG_PATH_INFO'] : '/'); } public static function pathTranslated() { return !empty($_SERVER['PATH_TRANSLATED']) ? $_SERVER['PATH_TRANSLATED'] : (!empty($_SERVER['ORIG_PATH_TRANSLATED']) ? $_SERVER['ORIG_PATH_TRANSLATED'] : '/'); } public static function get($key=null) { return is_null($key) ? $_GET : (isset($_GET[$key]) ? $_GET[$key] : null); } public static function headers($key=null) { $key = strtoupper($key); return is_null($key) ? $_SERVER : (isset($_SERVER[$key]) ? $_SERVER[$key] : null); } public static function rawGet() { return !empty($_SERVER['QUERY_STRING']) ? $_SERVER['QUERY_STRING'] : ''; } public static function post($key=null) { return is_null($key) ? $_POST : (isset($_POST[$key]) ? $_POST[$key] : null); } public static function rawPost() { $post = file_get_contents('php://input'); return $post; } public static function json($asObject=false) { return BUtil::fromJson(static::rawPost(), $asObject); } public static function request($key=null) { return is_null($key) ? $_REQUEST : (isset($_REQUEST[$key]) ? $_REQUEST[$key] : null); } public static function cookie($name, $value=null, $lifespan=null, $path=null, $domain=null) { if (is_null($value)) { return isset($_COOKIE[$name]) ? $_COOKIE[$name] : null; } if (false===$value) { return static::cookie($name, '', -1000); } $config = BConfig::i()->get('cookie'); $lifespan = !is_null($lifespan) ? $lifespan : $config['timeout']; $path = !is_null($path) ? $path : (!empty($config['path']) ? $config['path'] : static::webRoot()); $domain = !is_null($domain) ? $domain : (!empty($config['domain']) ? $config['domain'] : static::httpHost(false)); setcookie($name, $value, time()+$lifespan, $path, $domain); } public static function referrer($default=null) { return !empty($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : $default; } public static function receiveFiles($source, $targetDir, $typesRegex=null) { if (is_string($source)) { if (!empty($_FILES[$source])) { $source = $_FILES[$source]; } else { throw new BException('Missing enctype="multipart/form-data"?'); } } if (empty($source)) { return; } $result = array(); if (is_array($source['error'])) { foreach ($source['error'] as $key=>$error) { if ($error==UPLOAD_ERR_OK) { $tmpName = $source['tmp_name'][$key]; $name = $source['name'][$key]; $type = $source['type'][$key]; if (!is_null($typesRegex) && !preg_match('#'.$typesRegex.'#i', $type)) { $result[$key] = array('error'=>'invalid_type', 'tp'=>1, 'type'=>$type, 'name'=>$name); continue; } BUtil::ensureDir($targetDir); move_uploaded_file($tmpName, $targetDir.'/'.$name); $result[$key] = array('name'=>$name, 'tp'=>2, 'type'=>$type, 'target'=>$targetDir.'/'.$name); } else { $result[$key] = array('error'=>$error, 'tp'=>3); } } } else { $error = $source['error']; if ($error==UPLOAD_ERR_OK) { $tmpName = $source['tmp_name']; $name = $source['name']; $type = $source['type']; if (!is_null($typesRegex) && !preg_match('#'.$typesRegex.'#i', $type)) { $result = array('error'=>'invalid_type', 'tp'=>4, 'type'=>$type, 'pattern'=>$typesRegex, 'source'=>$source, 'name'=>$name); } else { BUtil::ensureDir($targetDir); move_uploaded_file($tmpName, $targetDir.'/'.$name); $result = array('name'=>$name, 'type'=>$type, 'target'=>$targetDir.'/'.$name); } } else { $result = array('error'=>$error, 'tp'=>5); } } return $result; } public static function csrf() { $c = BConfig::i(); $m = $c->get('web/csrf_http_methods'); $httpMethods = $m ? (is_string($m) ? explode(',', $m) : $m) : array('POST','PUT','DELETE'); if (is_array($httpMethods) && !in_array(static::method(), $httpMethods)) { return false; } $whitelist = $c->get('web/csrf_path_whitelist'); if ($whitelist) { $path = static::rawPath(); foreach ((array)$whitelist as $pattern) { if (preg_match($pattern, $path)) { return false; } } } $m = $c->get('web/csrf_check_method'); $method = $m ? $m : 'referrer'; switch ($method) { case 'referrer': if (!($ref = static::referrer())) { return true; } $p = parse_url($ref); $p['path'] = preg_replace('#/+#', '/', $p['path']); $webRoot = static::webRoot(); if ($p['host']!==static::httpHost(false) || $webRoot && strpos($p['path'], $webRoot)!==0) { return true; } return false; case 'token': if (!empty($_SERVER['HTTP_X_CSRF_TOKEN'])) { $receivedToken = $_SERVER['HTTP_X_CSRF_TOKEN']; } elseif (!empty($_POST['X-CSRF-TOKEN'])) { $receivedToken = $_POST['X-CSRF-TOKEN']; } return empty($receivedToken) || $receivedToken !== BSession::i()->csrfToken(); default: throw new BException('Invalid CSRF check method: '.$method); } } public static function verifyOriginHostIp($method='OR', $host=null) { $ip = static::ip(); if (!$host) { $host = static::httpHost(false); } $origin = static::httpOrigin(); $hostIPs = gethostbynamel($host); $hostMatches = $host && $method!='ORIGIN' ? in_array($ip, (array)$hostIPs) : false; $originIPs = gethostbynamel($origin); $originMatches = $origin && $method!='HOST' ? in_array($ip, (array)$originIPs) : false; switch ($method) { case 'HOST': return $hostMatches; case 'ORIGIN': return $originMatches; case 'AND': return $hostMatches && $originMatches; case 'OR': return $hostMatches || $originMatches; } return false; } public static function currentUrl() { $webroot = rtrim(static::webRoot(), '/'); $scheme = static::scheme(); $port = static::httpPort(); $url = $scheme.'://'.static::httpHost(); if (!BConfig::i()->get('web/hide_script_name')) { $url = rtrim($url, '/') . '/' . ltrim(str_replace('//', '/', static::scriptName()), '/'); } else { $url = rtrim($url, '/') . '/' . ltrim(str_replace('//', '/', $webroot), '/');; } $url .= static::rawPath().(($q = static::rawGet()) ? '?'.$q : ''); return $url; } public function initParams(array $params) { $this->_params = $params; return $this; } public function param($key=null, $fallbackToGet=false) { if (is_null($key)) { return $this->_params; } elseif (isset($this->_params[$key]) && ''!==$this->_params[$key]) { return $this->_params[$key]; } elseif ($fallbackToGet && !empty($_GET[$key])) { return $_GET[$key]; } else { return null; } } public function params($key=null, $fallbackToGet=false) { return $this->param($key, $fallbackToGet); } public static function sanitize($data, $config, $trim=true) { $data = (array)$data; if ($trim) { $data = array_intersect_key($data, $config); } foreach ($data as $k=>&$v) { $filter = is_array($config[$k]) ? $config[$k][0] : $config[$k]; $v = static::sanitizeOne($v, $filter); } unset($v); foreach ($config as $k=>$c) { if (!isset($data[$k])) { $data[$k] = is_array($c) && isset($c[1]) ? $c[1] : null; } } return $data; } public static function sanitizeOne($v, $filter) { if (is_array($v)) { foreach ($v as $k=>&$v1) { $v1 = static::sanitizeOne($v1, $filter); } unset($v1); return $v; } if (!is_array($filter)) { $filter = explode('|', $filter); } foreach ($filter as $f) { if (strpos($f, ':')) { list($f, $p) = explode(':', $f, 2); } else { $p = null; } switch ($f) { case 'int': $v = (int)$v; break; case 'positive': $v = $v>0 ? $v : null; break; case 'float': $v = (float)$v; break; case 'trim': $v = trim($v); break; case 'nohtml': $v = htmlentities($v, ENT_QUOTES); break; case 'plain': $v = htmlentities($v, ENT_NOQUOTES); break; case 'upper': $v = strtoupper($v); break; case 'lower': $v = strtolower($v); break; case 'ucwords': $v = ucwords($v); break; case 'ucfirst': $v = ucfirst($v); break; case 'urle': $v = urlencode($v); break; case 'urld': $v = urldecode($v); break; case 'alnum': $p = !empty($p)?$p:'_'; $v = preg_replace('#[^a-z0-9'.$p.']#i', '', $v); break; case 'regex': case 'regexp': $v = preg_replace($p, '', $v); break; case 'date': $v = date('Y-m-d', strtotime($v)); break; case 'datetime': $v = date('Y-m-d H:i:s', strtotime($v)); break; case 'gmdate': $v = gmdate('Y-m-d', strtotime($v)); break; case 'gmdatetime': $v = gmdate('Y-m-d H:i:s', strtotime($v)); break; } } return $v; } public static function stripMagicQuotes() { static $alreadyRan = false; if (get_magic_quotes_gpc() && !$alreadyRan) { $process = array(&$_GET, &$_POST, &$_COOKIE, &$_REQUEST); while (list($key, $val) = each($process)) { foreach ($val as $k => $v) { unset($process[$key][$k]); if (is_array($v)) { $process[$key][stripslashes($k)] = $v; $process[] = &$process[$key][stripslashes($k)]; } else { $process[$key][stripslashes($k)] = stripslashes($v); } } } unset($process); $alreadyRan = true; } } public static function modRewriteEnabled() { if (function_exists('apache_get_modules')) { $modules = apache_get_modules(); $modRewrite = in_array('mod_rewrite', $modules); } else { $modRewrite = strtolower(getenv('HTTP_MOD_REWRITE'))=='on' ? true : false; } return $modRewrite; } } class BResponse extends BClass { protected static $_httpStatuses = array( 100 => 'Continue', 101 => 'Switching Protocols', 200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authorative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content', 300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 307 => 'Temporary Redirect', 400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Time-out', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Large', 415 => 'Unsupported Media Type', 416 => 'Requested Range Not Satisfiable', 417 => 'Expectation Failed', 500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Time-out', 505 => 'HTTP Version Not Supported', ); protected $_contentType = 'text/html'; protected $_charset = 'UTF-8'; protected $_contentPrefix; protected $_contentSuffix; protected $_content; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public static function q($str) { if (is_null($str)) { return ''; } if (!is_scalar($str)) { var_dump($str); return ' ** ERROR ** '; } return htmlspecialchars($str); } public function cookie($name, $value=null, $lifespan=null, $path=null, $domain=null) { BRequest::cookie($name, $value, $lifespan, $path, $domain); return $this; } public function set($content) { $this->_content = $content; return $this; } public function add($content) { $this->_content = (array)$this->_content+(array)$content; return $this; } public function contentType($type=BNULL) { if (BNULL===$type) { return $this->_contentType; } $this->_contentType = $type; return $this; } public function setContentType($type) { $this->_contentType = $type; return $this; } public function getContentType() { return $this->_contentType; } public function contentPrefix($string=BNULL) { if (BNULL===$string) { return $this->_contentPrefix; } $this->_contentPrefix = $string; return $this; } public function setContentPrefix($string) { $this->_contentPrefix = $string; return $this; } public function getContentPrefix() { return $this->_contentPrefix; } public function contentSuffix($string=BNULL) { if (BNULL===$string) { return $this->_contentSuffix; } $this->_contentSuffix = $string; return $this; } public function setContentSuffix($string) { $this->_contentSuffix = $string; return $this; } public function getContentSuffix() { return $this->_contentSuffix; } public function json($data) { $response = BUtil::toJson($data); $callback = BRequest::i()->get('callback'); if ($callback) { $response = $callback.'('.$response.')'; } $this->setContentType('application/json')->set($response)->render(); } public function fileContentType($fileName) { $type = 'application/octet-stream'; switch (strtolower(pathinfo($fileName, PATHINFO_EXTENSION))) { case 'jpeg': case 'jpg': $type = 'image/jpg'; break; case 'png': $type = 'image/png'; break; case 'gif': $type = 'image/gif'; break; } return $type; } public function sendFile($source, $fileName=null, $disposition='attachment') { BSession::i()->close(); if (!$fileName) { $fileName = basename($source); } header('Pragma: public'); header('Cache-Control: must-revalidate, post-check=0, pre-check=0'); header('Content-Length: ' . filesize($source)); header('Last-Modified: ' . date('r')); header('Content-Type: '. $this->fileContentType($fileName)); header('Content-Disposition: '.$disposition.'; filename=' . $fileName); $fs = fopen($source, 'rb'); $fd = fopen('php://output', 'wb'); while (!feof($fs)) fwrite($fd, fread($fs, 8192)); fclose($fs); fclose($fd); $this->shutdown(__METHOD__); } public function sendContent($content, $fileName='download.txt', $disposition='attachment') { BSession::i()->close(); header('Pragma: public'); header('Cache-Control: must-revalidate, post-check=0, pre-check=0'); header('Content-Type: '.$this->fileContentType($fileName)); header('Content-Length: ' . strlen($content)); header('Last-Modified: ' . date('r')); header('Content-Disposition: '.$disposition.'; filename=' . $fileName); echo $content; $this->shutdown(__METHOD__); } public function status($status, $message=null, $output=true) { if (is_null($message)) { if (!empty(static::$_httpStatuses[$status])) { $message = static::$_httpStatuses[$status]; } else { $message = 'Unknown'; } } $protocol = BRequest::i()->serverProtocol(); header("{$protocol} {$status} {$message}"); header("Status: {$status} {$message}"); if (is_string($output)) { echo $output; exit; } elseif ($output) { $this->output(); } return $this; } public function output($type=null) { if (!is_null($type)) { $this->setContentType($type); } header('Content-Type: '.$this->_contentType.'; charset='.$this->_charset); if ($this->_contentType=='application/json') { if (!empty($this->_content)) { $this->_content = is_string($this->_content) ? $this->_content : BUtil::toJson($this->_content); } } elseif (is_null($this->_content)) { $this->_content = BLayout::i()->render(); } BEvents::i()->fire(__METHOD__.':before', array('content'=>&$this->_content)); if ($this->_contentPrefix) { echo $this->_contentPrefix; } if ($this->_content) { echo $this->_content; } if ($this->_contentSuffix) { echo $this->_contentSuffix; } BEvents::i()->fire(__METHOD__.':after', array('content'=>$this->_content)); $this->shutdown(__METHOD__); } public function render() { $this->output(); } public function redirect($url, $status=302) { BSession::i()->close(); $this->status($status, null, false); if (!BUtil::isUrlFull($url)) { $url = BApp::href($url); } header("Location: {$url}", null, $status); $this->shutdown(__METHOD__); } public function httpsRedirect() { $this->redirect(str_replace('http://', 'https://', BRequest::i()->currentUrl())); } public function httpSTS() { header('Strict-Transport-Security: max-age=500; includeSubDomains'); return $this; } public function cors($options=array()) { if (empty($options['origin'])) { $options['origin'] = BRequest::i()->httpOrigin(); } header('Access-Control-Allow-Origin: '.$options['origin']); if (!empty($options['methods'])) { header('Access-Control-Allow-Methods: '.$options['methods']); } if (!empty($options['credentials'])) { header('Access-Control-Allow-Credentials: true'); } if (!empty($options['headers'])) { header('Access-Control-Allow-Headers: '.$options['headers']); } if (!empty($options['expose-headers'])) { header('Access-Control-Expose-Headers: '.$options['expose-headers']); } if (!empty($options['age'])) { header('Access-Control-Max-Age: '.$options['age']); } return $this; } public function nocache() { header("Expires: Sat, 26 Jul 1997 05:00:00 GMT"); header("Last-Modified: " . gmdate("D, d M Y H:i:s") . " GMT"); header("Cache-Control: no-cache, must-revalidate"); header("Pragma: no-cache"); return $this; } public static function startLongResponse() { if (BDebug::is('DEBUG')) { BDebug::mode('DEVELOPMENT'); } BDebug::level(BDebug::MEMORY, false); set_time_limit(0); @ob_end_flush(); ob_implicit_flush(); gc_enable(); session_write_close(); echo str_pad('', 2000, ' '); } public function shutdown($lastMethod=null) { BEvents::i()->fire(__METHOD__, array('last_method'=>$lastMethod)); BSession::i()->close(); exit; } } class BRouting extends BClass { protected $_routes = array(); protected $_routesRegex = array(); protected static $_routeChanges = array(); protected $_currentRoute; protected $_urlTemplates = array(); protected $_controllerName; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function __construct() { $this->route('_ /noroute', 'BActionController.noroute', array(), null, false); } public function changeRoute($from, $opt) { if (!is_array($opt)) { $opt = array('to'=>$opt); } $type = !empty($opt['type']) ? $opt['type'] : 'first'; unset($opt['type']); $this->_routeChanges[$type][$from] = $opt; return $this; } public static function processHref($href) { $href = ltrim($href, '/'); if (!empty(static::$_routeChanges['first'])) { $rules = static::$_routeChanges['first']; $parts = explode('/', $href, 2); if (!empty($rules[$parts[0]])) { $href = ($part0 = $rules[$parts[0]]['to']) .($part0 && isset($parts[1]) ? '/' : '') .(isset($parts[1]) ? $parts[1] : ''); } } return $href; } public function processRoutePath($route, $args=array()) { if (!empty($args['module_name'])) { $module = BModuleRegistry::i()->module($args['module_name']); if ($module && ($prefix = $module->url_prefix)) { $route = $prefix.$route; } } return $route; } public function route($route, $callback=null, $args=null, $name=null, $multiple=true) { if (is_array($route)) { foreach ($route as $a) { if (is_null($callback)) { $this->route($a[0], $a[1], isset($a[2])?$a[2]:null, isset($a[3])?$a[3]:null); } else { $this->route($a, $callback, $args, $name, $multiple); } } return $this; } if (empty($args['module_name'])) { $args['module_name'] = BModuleRegistry::currentModuleName(); } BDebug::debug('ROUTE '.$route); if (empty($this->_routes[$route])) { $this->_routes[$route] = new BRouteNode(array('route_name'=>$route)); } $this->_routes[$route]->observe($callback, $args, $multiple); if (!is_null($name)) { $this->_urlTemplates[$name] = $route; } return $this; } public function get($route, $callback = null, $args = null, $name = null, $multiple = true) { return $this->_route($route, 'get', $callback, $args, $name, $multiple); } public function post($route, $callback = null, $args = null, $name = null, $multiple = true) { return $this->_route($route, 'post', $callback, $args, $name, $multiple); } public function put($route, $callback = null, $args = null, $name = null, $multiple = true) { return $this->_route($route, 'put', $callback, $args, $name, $multiple); } public function any($route, $callback = null, $args = null, $name = null, $multiple = true) { return $this->_route($route, 'any', $callback, $args, $name, $multiple); } protected function _route($route, $verb, $callback = null, $args = null, $name = null, $multiple = true) { if (is_array($route)) { foreach ($route as $a) { if (is_null($callback)) { $this->_route($a[0], $verb, $a[1], isset($a[2]) ? $a[2] : null, isset($a[3]) ? $a[3] : null); } else { $this->any($a, $verb, $callback, $args); } } return $this; } $verb = strtoupper($verb); $isRegex = false; if ($route[0]==='^') { $isRegex = true; $route = substr($route, 1); } if ($verb==='GET' || $verb==='POST' || $verb==='PUT') { $route = $verb.' '.$route; } else { if ($isRegex) { $route = '(GET|POST|DELETE|PUT|HEAD) '.$route; } else { $route = 'GET|POST|DELETE|PUT|HEAD '.$route; } } if ($isRegex) { $route = '^'.$route; } return $this->route($route, $callback, $args, $name, $multiple); } public function findRoute($requestRoute=null) { if (is_null($requestRoute)) { $requestRoute = BRequest::i()->rawPath(); } if (strpos($requestRoute, ' ')===false) { $requestRoute = BRequest::i()->method().' '.$requestRoute; } if (!empty($this->_routes[$requestRoute]) && $this->_routes[$requestRoute]->validObserver()) { BDebug::debug('DIRECT ROUTE: '.$requestRoute); return $this->_routes[$requestRoute]; } BDebug::debug('FIND ROUTE: '.$requestRoute); foreach ($this->_routes as $route) { if ($route->match($requestRoute)) { return $route; } } return null; } public function processRoutes() { uasort($this->_routes, function($a, $b) { $a1 = $a->num_parts; $b1 = $b->num_parts; $res = $a1<$b1 ? 1 : ($a1>$b1 ? -1 : 0); if ($res != 0) { return $res; } $ap = (strpos($a->route_name, '/*') ? 10 : 0)+(strpos($a->route_name, '/.') ? 5 : 0)+(strpos($a->route_name, '/:') ? 1 : 0); $bp = (strpos($b->route_name, '/*') ? 10 : 0)+(strpos($b->route_name, '/.') ? 5 : 0)+(strpos($b->route_name, '/:') ? 1 : 0); return $ap === $bp ? 0 : ($ap < $bp ? -1 : 1 ); }); return $this; } public function forward($from, $to, $args=array()) { $args['target'] = $to; $this->route($from, array($this, '_forwardCallback'), $args); return $this; } protected function _forwardCallback($args) { return $this->processRoutePath($args['target'], $args); } public function redirect($from, $to, $args=array()) { $args['target'] = $to; $this->route($from, array($this, 'redirectCallback'), $args); return $this; } public function redirectCallback($args) { BResponse::i()->redirect(BApp::href($args['target'])); } public function currentRoute() { return $this->_currentRoute; } public function dispatch($requestRoute=null) { BEvents::i()->fire(__METHOD__.':before'); $this->processRoutes(); $attempts = 0; $forward = false; while (($attempts++<100) && (false===$forward || is_array($forward))) { $route = $this->findRoute($requestRoute); if (!$route) { $route = $this->findRoute('_ /noroute'); } $this->_currentRoute = $route; $forward = $route->dispatch(); if (is_array($forward)) { list($actionName, $forwardCtrlName, $params) = $forward; $controllerName = $forwardCtrlName ? $forwardCtrlName : $route->controller_name; $requestRoute = '_ /forward'; $this->route($requestRoute, $controllerName.'.'.$actionName, array(), null, false); } } if ($attempts>=100) { echo "<pre>"; print_r($route); echo "</pre>"; BDebug::error(BLocale::_('BFrontController: Reached 100 route iterations: %s', print_r($route,1))); } } public function debug() { echo "<pre>"; print_r($this->_routes); echo "</pre>"; } } class BFrontController extends BRouting {} class BRouteNode { protected $_flags = array(); protected $_observers = array(); public $controller_name; public $action_idx; public $action_name; public $route_name; public $regex; public $num_parts; public $params; public $params_values; public $multi_method; public function __construct($args=array()) { foreach ($args as $k=>$v) { $this->$k = $v; } if ($this->route_name[0]==='^') { $this->regex = '#'.$this->route_name.'#'; return; } $a = explode(' ', $this->route_name); if (sizeof($a)<2) { throw new BException('Invalid route format: '.$this->route_name); } $this->multi_method = strpos($a[0], '|') !== false; if ($a[1]==='/') { $this->regex = '#^('.$a[0].') (/)$#'; } else { $a1 = explode('/', trim($a[1], '/')); $this->num_parts = sizeof($a1); $paramId = 2; foreach ($a1 as $i=>$k) { $k0 = $k[0]; $part = ''; if ($k0==='?') { $k = substr($k, 1); $k0 = $k[0]; $part = '?'; } if ($k0===':') { $this->params[++$paramId] = substr($k, 1); $part .= '([^/]*)'; } elseif ($k0==='!') { $this->params[++$paramId] = substr($k, 1); $part .= '([^/]+)'; } elseif ($k0==='*') { $this->params[++$paramId] = substr($k, 1); $part .= '(.*)'; } elseif ($k0==='.') { $this->params[++$paramId] = substr($k, 1); $this->action_idx = $paramId; $part .= '([a-zA-Z0-9_]*)'; } else { } if (''!==$part) { $a1[$i] = $part; } } $this->regex = '#^('.$a[0].') (/'.join('/', $a1).'/?)$#'; } } public function match($route) { if (!preg_match($this->regex, $route, $match)) { return false; } if (!$this->validObserver()) { return false; } if ($this->action_idx) { $this->action_name = !empty($match[$this->action_idx]) ? $match[$this->action_idx] : 'index'; } if ($this->route_name[0]==='^') { $this->params_values = $match; } elseif ($this->params) { $this->params_values = array(); foreach ($this->params as $i=>$p) { $this->params_values[$p] = $match[$i]; } } return true; } public function flag($flag, $value=true) { $this->_flags[$flag] = $value; return $this; } public function observe($callback, $args=null, $multiple=true) { $observer = new BRouteObserver(array( 'callback' => $callback, 'args' => $args, 'route_node' => $this, )); if ($multiple) { $this->_observers[] = $observer; } else { $this->_observers = array($observer); } return $this; } public function validObserver() { foreach ($this->_observers as $o) { if (!$o->skip) return $o; } return null; } public function dispatch() { $attempts = 0; $observer = $this->validObserver(); while ((++$attempts<100) && $observer) { $forward = $observer->dispatch(); if (is_array($forward)) { return $forward; } elseif ($forward===false) { $observer->skip = true; $observer = $this->validObserver(); } else { return null; } } if ($attempts>=100) { BDebug::error(BLocale::_('BRouteNode: Reached 100 route iterations: %s', print_r($observer,1))); } return false; } public function __destruct() { unset($this->_observers, $this->_children, $this->_match); } } class BRouteObserver { public $callback; public $args; public $skip; public $route_node; public function __construct($args) { foreach ($args as $k=>$v) { $this->$k = $v; } } public function dispatch() { BModuleRegistry::i()->currentModule(!empty($this->args['module_name']) ? $this->args['module_name'] : null); $node = $this->route_node; BRequest::i()->initParams((array)$node->params_values); if (is_string($this->callback) && $node->action_name) { $actionNameArr = explode('__', $node->action_name, 2); $this->callback .= '.'.$actionNameArr[0]; } if (is_callable($this->callback)) { return call_user_func($this->callback, $this->args); } if (is_string($this->callback)) { foreach (array('.', '->') as $sep) { $r = explode($sep, $this->callback); if (sizeof($r)==2) { $this->callback = $r; break; } } } $actionName = ''; $controllerName = ''; if (is_array($this->callback)) { $controllerName = $this->callback[0]; $node->controller_name = $controllerName; $actionName = $this->callback[1]; } $controller = BClassRegistry::i()->instance($controllerName, array(), true); return $controller->dispatch($actionName, $this->args); } public function __destruct() { unset($this->route_node, $this->callback, $this->args, $this->params); } } class BActionController extends BClass { protected $_action; protected $_forward; protected $_actionMethodPrefix = 'action_'; public function __construct() { } public function view($viewname) { return BLayout::i()->view($viewname); } public function dispatch($actionName, $args=array()) { $this->_action = $actionName; $this->_forward = null; if (!$this->beforeDispatch($args)) { return false; } if (!is_null($this->_forward)) { return $this->_forward; } $authenticated = $this->authenticate($args); if (!$authenticated && $actionName!=='unauthenticated') { $this->forward('unauthenticated'); return $this->_forward; } if ($authenticated && !$this->authorize($args) && $actionName!=='unauthorized') { $this->forward('unauthorized'); return $this->_forward; } $this->tryDispatch($actionName, $args); if (is_null($this->_forward)) { $this->afterDispatch($args); } return $this->_forward; } public function tryDispatch($actionName, $args) { if (is_callable($actionName)) { try { call_user_func($actionName); } catch (Exception $e) { BDebug::exceptionHandler($e); $this->sendError($e->getMessage()); } return $this; } $actionMethod = $this->_actionMethodPrefix.$actionName; $reqMethod = BRequest::i()->method(); if ($reqMethod !== 'GET') { $tmpMethod = $actionMethod.'__'.$reqMethod; if (method_exists($this, $tmpMethod)) { $actionMethod = $tmpMethod; } elseif (BRouting::i()->currentRoute()->multi_method) { $this->forward(false); } } if (!method_exists($this, $actionMethod)) { $this->forward(false); return $this; } try { $this->$actionMethod($args); } catch (Exception $e) { $this->sendError($e->getMessage()); } return $this; } public function forward($actionName=null, $controllerName=null, array $params=array()) { if (false===$actionName) { $this->_forward = false; } else { $this->_forward = array($actionName, $controllerName, $params); } return $this; } public function getForward() { return $this->_forward; } public function authenticate($args=array()) { return true; } public function authorize($args=array()) { return true; } public function beforeDispatch() { BEvents::i()->fire(__METHOD__); return true; } public function afterDispatch() { BEvents::i()->fire(__METHOD__); } public function sendError($message) { BResponse::i()->set($message)->status(503); } public function action_unauthenticated() { BResponse::i()->set("Unauthenticated")->status(401); } public function action_unauthorized() { BResponse::i()->set("Unauthorized")->status(403); } public function action_noroute() { BResponse::i()->set("Route not found")->status(404); } public function renderOutput() { BResponse::i()->output(); } public function getAction() { return $this->_action; } public function getController() { return self::origClass(); } public function viewProxy($viewPrefix, $defaultView='index', $hookName = 'main', $baseLayout = null) { $viewPrefix = trim($viewPrefix, '/').'/'; $page = BRequest::i()->params('view'); if (!$page) { $page = $defaultView; } $view = $this->view($viewPrefix.$page); if ($view instanceof BViewEmpty) { $this->forward(false); return false; } if ($baseLayout) { $this->layout($baseLayout); } BLayout::i()->applyLayout('view-proxy')->applyLayout($viewPrefix.$page); $view->render(); $metaData = $view->param('meta_data'); if ($metaData) { if (!empty($metaData['layout.yml'])) { BLayout::i()->addLayout('viewproxy-metadata', BYAML::i()->parse(trim($metaData['layout.yml']))) ->applyLayout('viewproxy-metadata'); } if (($head = $this->view('head'))) { foreach ($metaData as $k=>$v) { $k = strtolower($k); switch ($k) { case 'title': $head->addTitle($v); break; case 'meta_title': case 'meta_description': case 'meta_keywords': $head->meta(str_replace('meta_','',$k), $v); break; } } } } if (($root = BLayout::i()->view('root'))) { $root->addBodyClass('page-'.$page); } BLayout::i()->hookView($hookName, $viewPrefix . $page); if (!empty($metaData['http_status'])) { BResponse::i()->status($metaData['http_status']); } return $page; } public function _($string, $params=array(), $module=null) { if (empty($module)) { $module = BModuleRegistry::currentModuleName(); } return BLocale::_($string, $params, $module); } }  class BLayout extends BClass { protected $_themes = array(); protected $_defaultTheme; protected $_layouts = array(); protected $_views = array(); protected $_rootViewName = 'root'; protected $_viewRootDir; protected $_defaultViewClass; protected static $_metaDirectives = array( 'remove' => 'BLayout::metaDirectiveRemoveCallback', 'callback' => 'BLayout::metaDirectiveCallback', 'layout' => 'BLayout::metaDirectiveIncludeCallback', 'include' => 'BLayout::metaDirectiveIncludeCallback', 'root' => 'BLayout::metaDirectiveRootCallback', 'hook' => 'BLayout::metaDirectiveHookCallback', 'view' => 'BLayout::metaDirectiveViewCallback', ); protected static $_renderers = array(); protected static $_extRenderers = array( '.php' => array('callback' => null), ); protected static $_extRegex = '\.php'; public static function i($new = false, array $args = array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function viewRootDir($rootDir = null) { if (is_null($rootDir)) { return $this->getViewRootDir(); } return $this->setViewRootDir($rootDir); } public function getViewRootDir() { $module = BModuleRegistry::i()->currentModule(); return $module ? $module->view_root_dir : $this->_viewRootDir; } public function setViewRootDir($rootDir, $module=null) { if (is_null($module)) { $module = BModuleRegistry::i()->currentModule(); } $isAbsPath = strpos($rootDir, '/') === 0 || strpos($rootDir, ':') === 1; if ($module) { $module->view_root_dir = $isAbsPath ? $rootDir : $module->root_dir . '/' . $rootDir; } else { $this->_viewRootDir = $rootDir; } return $this; } public function addRenderer($name, $params) { if (is_string($name) && is_string($params)) { $params = array('file_ext' => array($name), 'callback' => $params); } if (is_string($params['file_ext'])) { $params['file_ext'] = explode(';', $params['file_ext']); } static::$_renderers[$name] = $params; foreach ($params['file_ext'] as $ext) { static::$_extRenderers[$ext] = $params; } static::$_extRegex = join('|', array_map('preg_quote', array_keys(static::$_extRenderers))); BDebug::debug('ADD RENDERER: '.join('; ', $params['file_ext'])); return $this; } public function getAllRenderers($asOptions=false) { if ($asOptions) { $options = array(); foreach (static::$_renderers as $k=>$r) { $options[$k] = !empty($r['description']) ? $r['description'] : $k; } asort($options); return $options; } return static::$_renderers; } public function getRenderer($name) { return !empty(static::$_renderers[$name]) ? static::$_renderers[$name] : null; } public function allViews($rootDir = null, $prefix = '') { return $this->addAllViews($rootDir, $prefix); } public function addAllViews($rootDir = null, $prefix = '') { if (is_null($rootDir)) { return $this->_views; } $curModule = BModuleRegistry::i()->currentModule(); if ($curModule && !BUtil::isPathAbsolute($rootDir)) { $rootDir = $curModule->root_dir . '/' . $rootDir; } if (!is_dir($rootDir)) { BDebug::warning('Not a valid directory: ' . $rootDir); return $this; } $rootDir = realpath($rootDir); $this->setViewRootDir($rootDir); $files = BUtil::globRecursive($rootDir . '/*'); if (!$files) { return $this; } if ($prefix) { $prefix = rtrim($prefix, '/') . '/'; } $re = '#^(' . preg_quote(realpath($rootDir) . '/', '#') . ')(.*)(' . static::$_extRegex . ')$#'; foreach ($files as $file) { if (!is_file($file)) { continue; } if (preg_match($re, $file, $m)) { $viewParams = array('template' => $file, 'file_ext' => $m[3]); $viewParams['renderer'] = static::$_extRenderers[$m[3]]['callback']; $this->addView($prefix . $m[2], $viewParams); } } BEvents::i()->fire(__METHOD__, array('root_dir'=>$rootDir, 'prefix'=>$prefix, 'module'=>$curModule)); return $this; } public function defaultViewClass($className) { $this->_defaultViewClass = $className; return $this; } public function view($viewName, $params = null, $reset = false) { if ($params) { $this->addView($viewName, $params, $reset); return $this; } return $this->getView($viewName); } public function getView($viewName) { return isset($this->_views[$viewName]) ? $this->_views[$viewName] : BViewEmpty::i(); } public function addView($viewName, $params = array(), $reset = false) { if (is_array($viewName)) { foreach ($viewName as $i => $view) { if (!is_numeric($i)) { throw new BException(BLocale::_('Invalid argument: %s', print_r($viewName, 1))); } $this->addView($view[0], $view[1], $reset); } return $this; } if (is_string($params)) { $params = array('view_class' => $params); } if (empty($params['module_name']) && ($moduleName = BModuleRegistry::currentModuleName())) { $params['module_name'] = $moduleName; } $viewAlias = !empty($params['view_alias']) ? $params['view_alias'] : $viewName; if (!isset($this->_views[$viewAlias]) || !empty($params['view_class'])) { if (empty($params['view_class'])) { if (!empty($this->_defaultViewClass)) { $params['view_class'] = $this->_defaultViewClass; } } $this->_views[$viewAlias] = BView::i()->factory($viewName, $params); BEvents::i()->fire('BLayout::view:add:' . $viewAlias, array( 'view' => $this->_views[$viewAlias], )); } else { $this->_views[$viewAlias]->setParam($params); BEvents::i()->fire('BLayout::view:update:' . $viewAlias, array( 'view' => $this->_views[$viewAlias], )); } return $this; } public function findViewsRegex($re) { $views = array(); foreach ($this->_views as $viewName => $view) { if (preg_match($re, $viewName)) { $views[$viewName] = $view; } } return $views; } public function rootView($viewName = BNULL) { if (BNULL === $viewName) { return $this->getRootView(); } $this->_rootViewName = $viewName; return $this; } public function setRootView($viewName) { $this->_rootViewName = $viewName; return $this; } public function getRootView() { return $this->_rootViewName ? $this->getView($this->_rootViewName) : null; } public function getRootViewName() { return $this->_rootViewName; } public function cloneView($from, $to = BNULL) { if (BNULL === $to) { $to = $from . '-copy'; for ($i = 2; !empty($this->_views[$to]); $i++) { $to = $from . '-copy' . $i; } } $this->_views[$to] = clone $this->_views[$from]; $this->_views[$to]->setParam('view_name', $to); return $this->_views[$to]; } public function hook($hookName, $callback, $args = array(), $alias = null) { BEvents::i()->on('BLayout::hook:' . $hookName, $callback, $args, $alias); return $this; } public function hookView($hookName, $viewName, $args = array()) { if (is_array($viewName)) { $params = $viewName; $viewName = array_shift($params); BLayout::i()->addView($viewName, $params); } $view = BLayout::i()->getView($viewName); if (!$view) { BDebug::warning('Invalid view name: ' . $viewName, 1); return $this; } return $this->hook($hookName, $view, $args, $viewName); } public function hookClear($hookName, $viewNames) { $eventHlp = BEvents::i(); $eventName = 'BLayout::hook:' . $hookName; if (true === $viewNames || 'ALL' === $viewNames) { $eventHlp->off($eventName, true); } else { foreach ((array)$viewNames as $clearViewName) { $eventHlp->off($eventName, $clearViewName); } } return $this; } public function layout($layoutName, $layout = null) { if (is_array($layoutName) || !is_null($layout)) { $this->addLayout($layoutName, $layout); } else { $this->applyLayout($layoutName); } return $this; } public function loadLayout($layoutFilename) { $ext = strtolower(pathinfo($layoutFilename, PATHINFO_EXTENSION)); if (!BUtil::isPathAbsolute($layoutFilename)) { $mod = BModuleRegistry::i()->currentModule(); if ($mod) { $layoutFilename = $mod->root_dir.'/'.$layoutFilename; } } BDebug::debug('LAYOUT.LOAD: '.$layoutFilename); switch ($ext) { case 'yml': case 'yaml': $layoutData = BYAML::i()->load($layoutFilename); break; case 'json': $layoutData = json_decode(file_get_contents($layoutFilename)); break; case 'php': $layoutData = include($layoutFilename); break; default: throw new BException('Unknown layout file type: '.$layoutFilename); } BLayout::i()->addLayout($layoutData); return $this; } public function loadLayoutAfterTheme($layoutFilename) { if (!BUtil::isPathAbsolute($layoutFilename)) { $mod = BModuleRegistry::i()->currentModule(); if ($mod) { $layoutFilename = $mod->root_dir.'/'.$layoutFilename; } } $this->onAfterTheme(function() use($layoutFilename) { BLayout::i()->loadLayout($layoutFilename); }); return $this; } public function addLayout($layoutName, $layout = null) { if (is_array($layoutName)) { foreach ($layoutName as $l => $def) { $this->addLayout($l, $def); } return $this; } if (!is_array($layout)) { BDebug::debug('LAYOUT.ADD ' . $layoutName . ': Invalid or empty layout'); } else { if (!isset($this->_layouts[$layoutName])) { BDebug::debug('LAYOUT.ADD ' . $layoutName); $this->_layouts[$layoutName] = $layout; } else { BDebug::debug('LAYOUT.UPDATE ' . $layoutName); $this->_layouts[$layoutName] = array_merge_recursive($this->_layouts[$layoutName], $layout); } } return $this; } public function applyLayout($layoutName) { if (empty($this->_layouts[$layoutName])) { BDebug::debug('LAYOUT.EMPTY ' . $layoutName); return $this; } BDebug::debug('LAYOUT.APPLY ' . $layoutName); $callbacks = array(); foreach ($this->_layouts[$layoutName] as $d) { if (empty($d['type'])) { if (!is_array($d)) { var_dump($layoutName, $d); } if (!empty($d[0])) { $d['type'] = $d[0]; } else { foreach ($d as $k=>$n) { if (!empty(self::$_metaDirectives[$k])) { $d['type'] = $k; $d['name'] = $n; break; } } } if (empty($d['type'])) { BDebug::dump($d); } } $d['type'] = trim($d['type']); if (empty($d['type']) || empty(self::$_metaDirectives[$d['type']])) { BDebug::error('Unknown directive: ' . $d['type']); continue; } if (empty($d['name']) && !empty($d[1])) { $d['name'] = $d[1]; } $d['name'] = trim($d['name']); $d['layout_name'] = $layoutName; $callback = self::$_metaDirectives[$d['type']]; if ($d['type'] === 'remove') { if ($d['name'] === 'all') { $callbacks = array(); } } else { $callbacks[] = array($callback, $d); } } foreach ($callbacks as $cb) { call_user_func($cb[0], $cb[1]); } return $this; } public function metaDirectiveCallback($d) { call_user_func($d['name'], $d); } public function metaDirectiveRemoveCallback($d) { } public function metaDirectiveIncludeCallback($d) { if ($d['name'] == $d['layout_name']) { BDebug::error('Layout recursion detected: ' . $d['name']); return; } static $layoutsApplied = array(); if (!empty($layoutsApplied[$d['name']]) && empty($d['repeat'])) { return; } $layoutsApplied[$d['name']] = 1; $this->applyLayout($d['name']); } public function metaDirectiveRootCallback($d) { $this->setRootView($d['name']); } public function metaDirectiveHookCallback($d) { $args = !empty($d['args']) ? $d['args'] : array(); if (!empty($d['position'])) { $args['position'] = $d['position']; } if (!empty($d['callbacks'])) { foreach ($d['callbacks'] as $cb) { $this->hook($d['name'], $cb, $args); } } if (!empty($d['clear'])) { $this->hookClear($d['name'], $d['clear']); } if (!empty($d['views'])) { foreach ((array)$d['views'] as $v) { $this->hookView($d['name'], $v, $args); } } } public function metaDirectiveViewCallback($d) { $view = $this->getView($d['name']); if (!empty($d['set'])) { foreach ($d['set'] as $k => $v) { $view->set($k, $v); } } if (!empty($d['param'])) { foreach ($d['param'] as $k => $v) { $view->setParam($k, $v); } } if (!empty($d['do'])) { foreach ($d['do'] as $args) { $method = array_shift($args); BDebug::debug('LAYOUT.view.do ' . $method); call_user_func_array(array($view, $method), $args); } } } public function defaultTheme($themeName = null) { if (is_null($themeName)) { return $this->_defaultTheme; } $this->_defaultTheme = $themeName; BDebug::debug('THEME.DEFAULT: ' . $themeName); return $this; } public function setDefaultTheme($themeName) { $this->_defaultTheme = $themeName; BDebug::debug('THEME.DEFAULT: ' . $themeName); return $this; } public function getDefaultTheme() { return $this->_defaultTheme; } public function addTheme($themeName, $params) { BDebug::debug('THEME.ADD ' . $themeName); $this->_themes[$themeName] = $params; return $this; } public function getThemes($area = null, $asOptions = false) { if (is_null($area)) { return $this->_themes; } $themes = array(); foreach ($this->_themes as $name => $theme) { if (!empty($theme['area']) && $theme['area'] === $area) { if ($asOptions) { $themes[$name] = !empty($theme['description']) ? $theme['description'] : $name; } else { $themes[$name] = $theme; } } } return $themes; } public function applyTheme($themeName = null) { if (is_null($themeName)) { if (!$this->_defaultTheme) { BDebug::error('Empty theme supplied and no default theme is set'); } $themeName = $this->_defaultTheme; } if (is_array($themeName)) { foreach ($themeName as $n) { $this->applyTheme($n); } return $this; } BDebug::debug('THEME.APPLY ' . $themeName); BEvents::i()->fire('BLayout::applyTheme:before', array('theme_name' => $themeName)); $this->loadTheme($themeName); BEvents::i()->fire('BLayout::applyTheme:after', array('theme_name' => $themeName)); return $this; } public function loadTheme($themeName) { if (empty($this->_themes[$themeName])) { BDebug::warning('Invalid theme name: ' . $themeName); return false; } $theme = $this->_themes[$themeName]; $area = BApp::i()->get('area'); if (!empty($theme['area']) && !in_array($area, (array)$theme['area'])) { BDebug::debug('Theme ' . $themeName . ' can not be used in ' . $area); return false; } if (!empty($theme['parent'])) { foreach ((array)$theme['parent'] as $parentThemeName) { if ($this->loadTheme($parentThemeName)) { break; } } } BEvents::i()->fire('BLayout::loadTheme:before', array('theme_name' => $themeName, 'theme' => $theme)); $modRootDir = !empty($theme['module_name']) ? BApp::m($theme['module_name'])->root_dir.'/' : ''; if (!empty($theme['layout'])) { BLayout::i()->loadLayout($modRootDir.$theme['layout']); } if (!empty($theme['views'])) { BLayout::i()->addAllViews($modRootDir.$theme['views']); } if (!empty($theme['callback'])) { BUtil::i()->call($theme['callback']); } BEvents::i()->fire('BLayout::loadTheme:after', array('theme_name' => $themeName, 'theme' => $theme)); return true; } public function onAfterTheme($callback) { BEvents::i()->on('BLayout::applyTheme:after', $callback); return $this; } public function dispatch($eventName, $routeName = null, $args = array()) { if (is_null($routeName) && ($route = BRouting::i()->currentRoute())) { $args['route_name'] = $routeName = $route->route_name; } $result = BEvents::i()->fire("BLayout::{$eventName}", $args); $routes = is_string($routeName) ? explode(',', $routeName) : (array)$routeName; foreach ($routes as $route) { $args['route_name'] = $route; $r2 = BEvents::i()->fire("BLayout::{$eventName}: {$route}", $args); $result = BUtil::arrayMerge($result, $r2); } return $result; } public function render($routeName = null, $args = array()) { $this->dispatch('render:before', $routeName, $args); $rootView = $this->getRootView(); BDebug::debug('LAYOUT.RENDER ' . var_export($rootView, 1)); if (!$rootView) { BDebug::error(BLocale::_('Main view not found: %s', $this->_rootViewName)); } $result = $rootView->render($args); $args['output'] =& $result; $this->dispatch('render:after', $routeName, $args); return $result; } public function debugPrintViews() { foreach ($this->_views as $viewName => $view) { echo $viewName . ':<pre>'; print_r($view); echo '</pre><hr>'; } } public function debugPrintLayouts() { echo "<pre>"; print_r($this->_layouts); echo "</pre>"; } } class BView extends BClass { protected static $_renderer; protected static $_metaDataRegex = '#<!--\s*\{\s*([^:]+):\s*(.*?)\s*\}\s*-->#'; protected $_params; static public function factory($viewName, array $params = array()) { $params['view_name'] = $viewName; $className = !empty($params['view_class']) ? $params['view_class'] : get_called_class(); $view = BClassRegistry::i()->instance($className, $params); return $view; } public function __construct(array $params) { $this->_params = $params; } public function param($key = null) { if (is_null($key)) { return $this->_params; } return isset($this->_params[$key]) ? $this->_params[$key] : null; } public function setParam($key, $value = null) { if (is_array($key)) { foreach ($key as $k => $v) { $this->setParam($k, $v); } return $this; } $this->_params[$key] = $value; return $this; } public function getParam($key) { return isset($this->_params[$key]) ? $this->_params[$key] : null; } public function set($name, $value = null) { if (is_array($name)) { foreach ($name as $k => $v) { $this->_params['args'][$k] = $v; } return $this; } $this->_params['args'][$name] = $value; return $this; } public function get($name) { return isset($this->_params['args'][$name]) ? $this->_params['args'][$name] : null; } public function getAllArgs() { return !empty($this->_params['args']) ? $this->_params['args'] : array(); } public function __get($name) { return $this->get($name); } public function __set($name, $value) { return $this->set($name, $value); } public function __isset($name) { return isset($this->_params['args'][$name]); } public function __unset($name) { unset($this->_params['args'][$name]); } public function view($viewName, $params = null) { if ($viewName === $this->param('view_name')) { throw new BException(BLocale::_('Circular reference detected: %s', $viewName)); } $view = BLayout::i()->getView($viewName); if ($view && $params) { $view->set($params); } return $view; } public function hook($hookName, $args = array()) { $args['_viewname'] = $this->param('view_name'); $result = ''; $debug = BDebug::is('DEBUG'); if ($debug) { $result .= "<!-- START HOOK: {$hookName} -->\n"; } $result .= join('', BEvents::i()->fire('BView::hook:before', array('view' => $this, 'name' => $hookName))); $result .= join('', BEvents::i()->fire('BLayout::hook:' . $hookName, $args)); $result .= join('', BEvents::i()->fire('BView::hook:after', array('view' => $this, 'name' => $hookName))); if ($debug) { $result .= "<!-- END HOOK: {$hookName} -->\n"; } return $result; } public function getTemplateFileName($fileExt = null, $quiet = false) { if (is_null($fileExt)) { $fileExt = $this->getParam('file_ext'); } $template = $this->param('template'); if (!$template && ($viewName = $this->param('view_name'))) { $template = $viewName . $fileExt; } if ($template) { if (!BUtil::isPathAbsolute($template)) { $template = BLayout::i()->getViewRootDir() . '/' . $template; } if (!is_readable($template) && !$quiet) { BDebug::notice('TEMPLATE NOT FOUND: ' . $template); } else { BDebug::debug('TEMPLATE ' . $template); } } return $template; } public function renderFile($file) { ob_start(); include $file; return ob_get_clean(); } public function renderEval($source) { ob_start(); eval($source); return ob_get_clean(); } protected function _render() { $renderer = $this->param('renderer'); if ($renderer) { return call_user_func($renderer, $this); } ob_start(); include $this->getTemplateFileName(); return ob_get_clean(); } public function render(array $args = array(), $retrieveMetaData = true) { $debug = BDebug::is('DEBUG') && !$this->get('no_debug'); $viewName = $this->param('view_name'); $timer = BDebug::debug('RENDER.VIEW ' . $viewName); if ($this->param('raw_text') !== null) { return $this->param('raw_text'); } foreach ($args as $k => $v) { $this->_params['args'][$k] = $v; } if (($modName = $this->param('module_name'))) { BModuleRegistry::i()->pushModule($modName); } $result = ''; if (!$this->_beforeRender()) { BDebug::debug('BEFORE.RENDER failed'); if ($debug) { $result .= "<!-- FAILED VIEW: {$viewName} -->\n"; } return $result; } $showDebugTags = $debug && $modName && $viewName && BLayout::i()->getRootViewName()!==$viewName; if ($showDebugTags) { $result .= "<!-- START VIEW: @{$modName}/{$viewName} -->\n"; } $result .= join('', BEvents::i()->fire('BView::render:before', array('view' => $this))); $viewContent = $this->_render(); if ($retrieveMetaData) { $metaData = array(); if (preg_match_all(static::$_metaDataRegex, $viewContent, $matches, PREG_SET_ORDER)) { foreach ($matches as $m) { $metaData[$m[1]] = $m[2]; $viewContent = str_replace($m[0], '', $viewContent); } } $this->setParam('meta_data', $metaData); } $result .= $viewContent; $result .= join('', BEvents::i()->fire('BView::render:after', array('view' => $this))); if ($showDebugTags) { $result .= "<!-- END VIEW: @{$modName}/{$viewName} -->\n"; } BDebug::profile($timer); $this->_afterRender(); if ($modName) { BModuleRegistry::i()->popModule(); } return $result; } protected function _beforeRender() { return true; } protected function _afterRender() { } public function clear() { unset($this->_params); } public function __destruct() { $this->clear(); } public function __toString() { try { $result = $this->render(); } catch (PDOException $e) { $result = '<hr>' . get_class($e) . ': ' . $e->getMessage() . '<hr>' . ORM::get_last_query() . '<hr>'; } catch (Exception $e) { $result = '<hr>' . get_class($e) . ': ' . $e->getMessage() . '<hr>'; } return $result; } public function q($str, $args = array()) { if (is_null($str)) { return ''; } if (!is_scalar($str)) { var_dump($str); return ' ** ERROR ** '; } return htmlspecialchars($args ? BUtil::sprintfn($str, $args) : $str); } public function s($str, $tags = null) { return strip_tags($str, $tags); } public function optionsHtml($options, $default = '') { return BUtil::optionsHtml($options, $default); } public function email($p = array()) { if (is_string($p)) { $p = array('to' => $p); } $body = $this->render($p, true); $data = array_merge( array_change_key_case($this->param('meta_data'), CASE_LOWER), array_change_key_case($p, CASE_LOWER) ); $data['body'] = $body; return BEmail::i()->send($data); } public function _($string, $params = array(), $module = null) { if (empty($module) && !empty($this->_params['module_name'])) { $module = $this->_params['module_name']; } return BLocale::_($string, $params, $module); } } class BViewEmpty extends BView { public function render(array $args = array(), $retrieveMetaData = true) { return ''; } } class BViewHead extends BView { protected $_title = array(); protected $_titleSeparator = ' :: '; protected $_titleReverse = true; protected $_subst = array(); protected $_meta = array(); protected $_elements = array(); protected $_headJs = array('enabled' => false, 'loaded' => false, 'jquery' => null, 'scripts' => array()); protected $_requireJs = array('config' => array(), 'run' => array()); protected $_defaultTag = array( 'js' => '<script type="text/javascript" src="%s" %a></script>', 'js_raw' => '<script type="text/javascript" %a>%c</script>', 'css' => '<link rel="stylesheet" type="text/css" href="%s" %a/>', 'css_raw' => '<style type="text/css" %a>%c</style>', 'less' => '<link rel="stylesheet/less" type="text/css" href="%s" %a/>', 'icon' => '<link rel="icon" href="%s" type="image/x-icon" %a/><link rel="shortcut icon" href="%s" type="image/x-icon" %a/>', ); protected $_currentIfContext = null; public function subst($from, $to = null) { if (is_null($to)) { return str_replace(array_keys($this->_subst), array_values($this->_subst), $from); } $this->_subst['{' . $from . '}'] = $to; return $this; } public function headJs($enable = true) { $this->_headJs['enabled'] = $enable; return $this; } public function title($title, $start = false) { $this->addTitle($title, $start); } public function meta($name = null, $content = null, $httpEquiv = false) { if (is_null($content)) { return $this->getMeta($name); } $this->addMeta($name, $content, $httpEquiv); return $this; } public function csrf_token() { $this->addMeta('csrf-token', BSession::i()->csrfToken()); return $this; } public function canonical($href) { $this->addElement('link', 'canonical', array('tag' => '<link rel="canonical" href="' . $href . '"/>')); return $this; } public function rss($href) { $this->addElement('link', 'rss', array('tag' => '<link rel="alternate" type="application/rss+xml" title="RSS" href="' . $href . '">')); } public function __call($name, $args) { if (!empty($this->_defaultTag[$name])) { array_unshift($args, $name); return call_user_func_array(array($this, 'addElement'), $args); } else { BDebug::error('Invalid method: ' . $name); } } public function removeAll() { $this->_elements = array(); $this->_headJs = array(); return $this; } public function remove($type, $pattern) { if ($type === 'js' && $this->_headJs['loaded']) { foreach ($this->_headJs['scripts'] as $i => $file) { if (true===$pattern || strpos($file, $pattern) !== false) { unset($this->_headJs['scripts'][$i]); } } } foreach ($this->_elements as $k => $args) { if (strpos($k, $type) === 0 && (true===$pattern || strpos($k, $pattern) !== false)) { unset($this->_elements[$k]); } } return $this; } public function setTitle($title) { $this->_title = array($title); return $this; } public function addTitle($title, $start = false) { if ($start) { array_splice($this->_title, 0, 1, $title); } else { $this->_title[] = $title; } return $this; } public function setTitleSeparator($sep) { $this->_titleSeparator = $sep; return $this; } public function setTitleReverse($reverse) { $this->_titleReverse = $reverse; return $this; } public function getTitle() { if (!$this->_title) { return ''; } if ($this->_titleReverse) { $this->_title = array_reverse($this->_title); } return '<title>' . $this->q(join($this->_titleSeparator, $this->_title)) . '</title>'; } public function getMeta($name = null) { if (is_null($name)) { return join("\n", $this->_meta); } return !empty($this->_meta[$name]) ? $this->_meta[$name] : null; } public function addMeta($name, $content, $httpEquiv = false) { if ($httpEquiv) { $this->_meta[$name] = '<meta http-equiv="' . $name . '" content="' . htmlspecialchars($content) . '" />'; } else { $this->_meta[$name] = '<meta name="' . $name . '" content="' . htmlspecialchars($content) . '" />'; } return $this; } public function addElement($type, $name, $args = array()) { if (is_string($args)) { $args = array('content' => $args); } if (!empty($args['alias'])) { $args['file'] = trim($name); $name = trim($args['alias']); } if (!isset($args['module_name']) && ($moduleName = BModuleRegistry::currentModuleName())) { $args['module_name'] = $moduleName; } if (!isset($args['if']) && $this->_currentIfContext) { $args['if'] = $this->_currentIfContext; } $args['type'] = $type; if (empty($args['position'])) { $this->_elements[$type . ':' . $name] = (array)$args; } else { $this->_elements = BUtil::arrayInsert( $this->_elements, array($type . ':' . $name => (array)$args), $args['position'] ); } if ($this->_headJs['enabled']) { $basename = basename($name); if ($basename === 'head.js' || $basename === 'head.min.js' || $basename === 'head.load.min.js') { $this->_headJs['loaded'] = $name; } } return $this; } public function src($file, $ts = false) { if (is_array($file)) { $files = array(); foreach ($file as $k=>$f) { $files[$k] = $this->src($f, $ts); } return $files; } if ($file[0] === '@') { preg_match('#^@([^/]+)(.*)$#', $file, $m); $mod = BApp::m($m[1]); if (!$mod) { BDebug::notice('Module not found: ' . $file); return ''; } $fsFile = BApp::m($m[1])->root_dir . $m[2]; $file = BApp::m($m[1])->baseSrc() . $m[2]; if ($ts && file_exists($fsFile)) { $file .= '?' . substr(md5(filemtime($fsFile)), 0, 10); } } elseif (preg_match('#\{([A-Za-z0-9_]+)\}#', $file, $m)) { $mod = BApp::m($m[1]); if (!$mod) { BDebug::notice('Module not found: ' . $file); return ''; } $fsFile = str_replace('{' . $m[1] . '}', BApp::m($m[1])->root_dir, $file); $file = str_replace('{' . $m[1] . '}', BApp::m($m[1])->baseSrc(), $file); if ($ts && file_exists($fsFile)) { $file .= '?' . substr(md5(filemtime($fsFile)), 0, 10); } } return $file; } public function getElement($type, $name) { $typeName = $type . ':' . $name; if (!isset($this->_elements[$typeName])) { return null; } $args = $this->_elements[$typeName]; $file = !empty($args['file']) ? $args['file'] : $name; $file = $this->src($file, true); if (strpos($file, 'http:') === false && strpos($file, 'https:') === false && $file[0] !== '/') { $module = !empty($args['module_name']) ? BModuleRegistry::i()->module($args['module_name']) : null; $baseUrl = $module ? $module->baseSrc() : BApp::baseUrl(); $file = $baseUrl . '/' . $file; } if ($type === 'js' && $this->_headJs['loaded'] && $this->_headJs['loaded'] !== $name && empty($args['separate']) && empty($args['tag']) && empty($args['params']) && empty($args['if']) ) { if (!$this->_headJs['jquery'] && strpos($name, 'jquery') !== false) { $this->_headJs['jquery'] = $file; } else { $this->_headJs['scripts'][] = $file; } return ''; } $tag = !empty($args['tag']) ? $args['tag'] : $this->_defaultTag[$type]; $tag = str_replace('%s', htmlspecialchars($file), $tag); $tag = str_replace('%c', !empty($args['content']) ? $args['content'] : '', $tag); $tag = str_replace('%a', !empty($args['params']) ? $args['params'] : '', $tag); if (!empty($args['if'])) { $tag = '<!--[if ' . $args['if'] . ']>' . $tag . '<![endif]-->'; } return $tag; } public function getAllElements() { $result = array(); $res1 = array(); foreach ($this->_elements as $typeName => $els) { list($type, $name) = explode(':', $typeName, 2); $res1[$type == 'css' ? 0 : 1][] = $this->getElement($type, $name); } for ($i = 0; $i <= 1; $i++) { if (!empty($res1[$i])) $result[] = join("\n", $res1[$i]); } return preg_replace('#\n{2,}#', "\n", join("\n", $result)); } public function ifContext($context = null) { $this->_currentIfContext = $context; return $this; } public function requireModulePath($name = null, $path = null) { if (is_null($name)) { $m = BApp::m(); $name = $m->name; } else { $m = BApp::m($name); } if (is_null($path)) { $path = trim($m->base_src, '/').'/js'; } BDebug::debug(__METHOD__.':'.$name.':'.$path); $this->_requireJs['config']['paths'][$name] = $path; return $this; } public function requireJs($name, $path, $shim = null) { $this->_requireJs['config']['paths'][$name] = $path; if (!is_null($shim)) { $this->_requireJs['config']['shim'][$name] = $shim; } return $this; } public function requireConfig($config) { $this->_requireJs['config'] = BUtil::arrayMerge($this->_requireJs['config'], $config); return $this; } public function requireRun($names) { $this->_requireJs['run'] = array_merge($this->_requireJs['run'], (array)$names); return $this; } public function renderRequireJs() { $jsArr = array(); if (!empty($this->_requireJs['config'])) { $config = $this->_requireJs['config']; if (empty($config['baseUrl'])) { $config['baseUrl'] = BConfig::i()->get('web/base_src'); } if (!empty($config['paths'])) { foreach ($config['paths'] as $name => $file) { $config['paths'][$name] = $this->src($file); } } $jsArr[] = "require.config(".BUtil::toJavaScript($config)."); "; } if (!empty($this->_requireJs['run'])) { $jsArr[] = "require(['" . join("', '", $this->_requireJs['run']) . "']);"; } return join("\n", $jsArr); } public function render(array $args = array(), $retrieveMetaData = true) { if (!$this->param('template')) { $html = $this->getTitle() . "\n" . $this->getMeta() . "\n" . $this->getAllElements(); $scriptsArr = array(); if ($this->_headJs['scripts'] || $this->_headJs['jquery']) { if ($this->_headJs['scripts']) { $scriptsArr[] = 'head.js("' . join('", "', $this->_headJs['scripts']) . '");'; } if ($this->_headJs['jquery']) { $scriptsArr[] = 'head.js({jquery:"' . $this->_headJs['jquery'] . '"}, function() { jQuery.fn.ready = head; ' . $scripts . '});'; } } $requireJs = $this->renderRequireJs(); if ($requireJs) { $scriptsArr[] = $requireJs; } if ($scriptsArr) { $html .= "<script>" . join("\n", $scriptsArr) . "</script>"; } return $html; } return parent::render($args); } } class BViewList extends BView { protected $_children = array(); protected $_lastPosition = 0; public function append($viewname, array $params = array()) { if (is_string($viewname)) { $viewname = explode(',', $viewname); } if (isset($params['position'])) { $this->_lastPosition = $params['position']; } foreach ($viewname as $v) { $params['name'] = $v; $params['position'] = $this->_lastPosition++; $this->_children[] = $params; } return $this; } public function appendText($text) { $layout = BLayout::i(); for ($viewname = md5(mt_rand()); $layout->getView($viewname);) ; $layout->addView($viewname, array('raw_text' => (string)$text)); $this->append($viewname); return $this; } public function find($content) { foreach ($this->_children as $i => $child) { $view = $this->view($child['name']); if (strpos($view->render(), $content) !== false) { return $view; } } return null; } public function remove($viewname) { if (true === $viewname) { $this->_children = array(); return $this; } foreach ($this->_children as $i => $child) { if ($child['name'] == $viewname) { unset($this->_children[$i]); break; } } return $this; } public function render(array $args = array(), $retrieveMetaData = true) { $output = array(); uasort($this->_children, array($this, 'sortChildren')); $layout = BLayout::i(); foreach ($this->_children as $child) { $childView = $layout->getView($child['name']); if (!$childView) { throw new BException(BLocale::_('Invalid view name: %s', $child['name'])); } $output[] = $childView->render($args); } return join('', $output); } public function sortChildren($a, $b) { return $a['position'] < $b['position'] ? -1 : ($a['position'] > $b['position'] ? 1 : 0); } }  class BCache extends BClass { protected $_backends = array(); protected $_backendStatus = array(); protected $_defaultBackend; public static function i($new=false, array $args=array()) { return BClassRegistry::i()->instance(__CLASS__, $args, !$new); } public function __construct() { foreach (array('File','Shmop','Apc','Memcache','Db') as $type) { $this->addBackend($type, 'BCache_Backend_'.$type); } } public function addBackend($type, $backend) { $type = strtolower($type); if (is_string($backend)) { if (!class_exists($backend)) { throw new BException('Invalid cache backend class name: '.$backend.' ('.$type.')'); } $backend = $backend::i(); } if (!is_object($backend)) { throw new BException('Invalid backend for type: '.$type); } if (!$backend instanceof BCache_Backend_Interface) { throw new BException('Invalid cache backend class interface: '.$type); } $this->_backends[$type] = $backend; return $this; } public function getBackend($type=null) { if (is_null($type)) { if (empty($this->_defaultBackend)) { $minRank = 1000; $fastest = null; foreach ($this->_backends as $t => $backend) { $info = $backend->info(); if (empty($info['available'])) { continue; } if ($info['rank'] < $minRank) { $minRank = $info['rank']; $fastest = $t; } } $this->_defaultBackend = $fastest; } $type = $this->_defaultBackend; } $type = strtolower($type); $backend = $this->_backends[$type]; if (empty($this->_backendStatus[$type])) { $info = $backend->info(); if (empty($info['available'])) { throw new BException('Cache backend is not available: '.$type); } $config = (array)BConfig::i()->get('cache/'.$type); $backend->init($config); $this->_backendsStatus[$type] = true; } return $this->_backends[$type]; } public function load($key) { return $this->getBackend()->load($key); } public function loadMany($pattern) { return $this->getBackend()->loadMany($pattern); } public function save($key, $data, $ttl=null) { return $this->getBackend()->save($key, $data, $ttl); } public function delete($key) { return $this->getBackend()->delete($key); } public function gc() { return $this->getBackend()->gc(); } } interface BCache_Backend_Interface { public function info(); public function init($config = array()); public function load($key); public function save($key, $data, $ttl = null); public function delete($key); public function loadMany($pattern); public function deleteMany($pattern); public function gc(); } class BCache_Backend_File extends BClass implements BCache_Backend_Interface { protected $_config = array(); public function info() { return array('available' => true, 'rank' => 70); } public function init($config = array()) { if (empty($config['dir'])) { $config['dir'] = BConfig::i()->get('fs/cache_dir'); } if (!is_writable($config['dir'])) { $config['dir'] = sys_get_temp_dir().'/fulleron/'.md5(__DIR__).'/cache'; } if (empty($config['default_ttl'])) { $config['default_ttl'] = 3600; } $this->_config = $config; return true; } protected function _filename($key) { $md5 = md5($key); return $this->_config['dir'].'/'.substr($md5, 0, 2).'/'.BUtil::simplifyString($key).'.'.substr($md5, 0, 10).'.dat'; } public function load($key) { $filename = $this->_filename($key); if (!file_exists($filename)) { return null; } $fp = fopen($filename, 'r'); $meta = @unserialize(fgets($fp, 1024)); if (!$meta || $meta['ttl'] !== false && $meta['ts'] + $meta['ttl'] < time()) { fclose($fp); @unlink($filename); return null; } for ($data = ''; $chunk = fread($fp, 4096); $data .= $chunk); fclose($fp); return $data; } public function save($key, $data, $ttl = null) { $filename = $this->_filename($key); $dir = dirname($filename); BUtil::ensureDir($dir); $meta = array( 'ts' => time(), 'ttl' => !is_null($ttl) ? $ttl : $this->_config['default_ttl'], 'key' => $key, ); file_put_contents($filename, serialize($meta)."\n".serialize($data)); return true; } public function delete($key) { $filename = $this->_filename($key); if (!file_exists($filename)) { return false; } @unlink($filename); return true; } public function loadMany($pattern) { $files = glob($this->_config['dir'].'/*/*'.BUtil::simplifyString($pattern).'*'); if (!$files) { return array(); } $result = array(); foreach ($files as $filename) { $fp = fopen($filename, 'r'); $meta = unserialize(fgets($fp, 1024)); if (!$meta || $meta['ttl'] !== false && $meta['ts'] + $meta['ttl'] < time()) { fclose($fp); @unlink($filename); continue; } if (strpos($meta['key'], $pattern)!==false) { for ($data = ''; $chunk = fread($fp, 4096); $data .= $chunk); $result[$meta['key']] = $data; } fclose($fp); } return $result; } public function deleteMany($pattern) { if ($pattern===true || $pattern===false) { $files = glob($this->_config['dir'].'/*/*'); } else { $files = glob($this->_config['dir'].'/*/*'.BUtil::simplifyString($pattern).'*'); } if (!$files) { return false; } $result = array(); foreach ($files as $filename) { if ($pattern===true) { @unlink($filename); continue; } $fp = fopen($filename, 'r'); $meta = unserialize(fgets($fp, 1024)); fclose($fp); if (!$meta || $meta['ttl'] !== false && $meta['ts'] + $meta['ttl'] < time() || $pattern===false || strpos($meta['key'], $pattern)!==false ) { @unlink($filename); } } return true; } public function gc() { $this->deleteMany(false); return true; } } class BCache_Backend_Apc extends BClass implements BCache_Backend_Interface { protected $_config; public function info() { return array('available' => function_exists('apc_fetch'), 'rank' => 10); } public function init($config = array()) { if (empty($config['prefix'])) { $config['prefix'] = substr(md5(__DIR__), 0, 16).'/'; } if (empty($config['default_ttl'])) { $config['default_ttl'] = 3600; } $this->_config = $config; return true; } public function load($key) { $fullKey = $this->_config['prefix'].$key; return apc_fetch($fullKey); } public function save($key, $data, $ttl = null) { $ttl = !is_null($ttl) ? $ttl : $this->_config['default_ttl']; $cacheKey = $this->_config['prefix'].$key; return apc_store($cacheKey, $data, (int)$ttl); } public function delete($key) { return apc_delete($this->_config['prefix'].$key); } public function loadMany($pattern) { $items = new APCIterator('user'); $prefix = $this->_config['prefix']; $result = array(); foreach ($items as $item) { $key = $item['key']; if (strpos($key, $prefix)!==0) { continue; } if ($pattern===true || strpos($key, $pattern)!==false) { $result[$key] = apc_fetch($key); } } return $result; } public function deleteMany($pattern) { if ($pattern===false) { return false; } $items = new APCIterator('user'); $prefix = $this->_config['prefix']; foreach ($items as $item) { $key = $item['key']; if (strpos($key, $prefix)!==0) { continue; } if ($pattern===true || strpos($key, $pattern)!==false) { apc_delete($key); } } return true; } public function gc() { return true; } } class BCache_Backend_Memcache extends BClass implements BCache_Backend_Interface { protected $_config; protected $_conn; public function info() { return array('available' => class_exists('Memcache', false), 'rank' => 10); } public function init($config = array()) { if (empty($config['prefix'])) { $config['prefix'] = substr(md5(__DIR__), 0, 16).'/'; } if (empty($config['host'])) { $config['host'] = 'localhost'; } if (empty($config['port'])) { $config['port'] = 11211; } $this->_config = $config; $this->_flags = !empty($config['compress']) ? MEMCACHE_COMPRESSED : 0; $this->_conn = new Memcache; return $this->_conn->pconnect($config['host'], $config['port']); } public function load($key) { return $this->_conn->get($this->_config['prefix'].$key); } public function save($key, $data, $ttl = null) { $flag = !empty($this->_config['compress']) ? MEMCACHE_COMPRESSED : 0; $ttl1 = is_null($ttl) ? 0 : time()+$ttl; return $this->_conn->set($this->_config['prefix'].$key, $data, $flag, $ttl1); } public function delete($key) { return $this->_conn->delete($this->_config['prefix'].$key); } public function loadMany($pattern) { return false; } public function deleteMany($pattern) { return false; } public function gc() { return false; } } class BCache_Backend_Db extends BClass implements BCache_Backend_Interface { public function info() { $avail = (boolean)BConfig::i()->get('db/dbname'); return array('available' => $avail, 'rank' => 90); } public function init($config = array()) { $this->migrate(); } public function load($key) { $cache = BCache_Backend_Db_Model_Cache::i()->load($key, 'cache_key'); if (!$cache) { return null; } if ($cache->get('expires_at')<time()) { $cache->delete(); return null; } return unserialize($cache->get('cache_value')); } public function save($key, $data, $ttl = null) { $hlp = BCache_Backend_Db_Model_Cache::i(); $cache = $hlp->load($key, 'cache_key'); if (!$cache) { $cache = $hlp->create(array('cache_key' => $key)); } $cache->set(array( 'expires_at' => is_null($ttl) ? null : time()+$ttl, 'cache_value' => serialize($data), ))->save(); return true; } public function delete($key) { BCache_Backend_Db_Model_Cache::i()->delete_many(array('cache_key' => $key)); return true; } public function loadMany($pattern) { return false; } public function deleteMany($pattern) { return false; } public function gc() { BCache_Backend_Db_Model_Cache::i()->delete_many('expires_at<'.time()); return true; } public function migrate() { $t = BCache_Backend_Db_Model_Cache::table(); if (!BDb::ddlTableExists($t)) { BDb::ddlTableDef($t, array( 'COLUMNS' => array( 'id' => 'int unsigned not null auto_increment', 'cache_key' => 'varchar(255) not null', 'cache_value' => 'mediumtext not null', 'expires_at' => 'int unsigned null', ), 'PRIMARY' => '(id)', 'KEYS' => array( 'UNQ_cache_key' => '(cache_key)', 'IDX_expires_at' => '(expires_at)', ), 'OPTIONS' => array( 'engine' => 'MyISAM', ), )); } } } class BCache_Backend_Db_Model_Cache extends BModel { static protected $_table = 'buckyball_cache'; static protected $_origClass = __CLASS__; } class BCache_Backend_Shmop extends BClass implements BCache_Backend_Interface { public function info() { return array('available' => false, 'rank' => 10); } public function init($config = array()) { } public function load($key) { } public function save($key, $data, $ttl = null) { } public function delete($key) { } public function loadMany($pattern) { } public function deleteMany($pattern) { } public function gc() { } } 